//! This

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc, Mutex,
};

use lazy_static::lazy_static;
use windows::{
    core::{w, HSTRING, PCWSTR},
    Win32::{
        Foundation::{COLORREF, HWND, LPARAM, LRESULT, WPARAM},
        Graphics::Dwm::DwmIsCompositionEnabled,
        System::{
            LibraryLoader::{GetModuleHandleA, GetModuleHandleW},
            SystemInformation::{GetVersionExW, OSVERSIONINFOW},
        },
        UI::WindowsAndMessaging::{
            CreateWindowExW, DefWindowProcW, DispatchMessageW, GetMessageW, GetWindowLongPtrW,
            LoadCursorW, PostMessageW, PostQuitMessage, RegisterClassExW,
            SetLayeredWindowAttributes, SetParent, SetWindowLongPtrW, TranslateMessage, CS_HREDRAW,
            CS_NOCLOSE, CS_OWNDC, CS_VREDRAW, GWL_EXSTYLE, GWL_STYLE, HTTRANSPARENT, IDC_ARROW,
            LWA_ALPHA, MSG, WM_NCHITTEST, WNDCLASSEXW, WS_CHILD, WS_EX_COMPOSITED, WS_EX_LAYERED,
            WS_EX_TRANSPARENT, WS_POPUP, WS_VISIBLE,
        },
    },
};

use crate::unsafe_send::{WrappedHWND, WrappedObsDisplay};

mod position_trait;
mod show_hide;
pub use position_trait::WindowPositionTrait;
pub use show_hide::ShowHideTrait;

const WM_DESTROY_WINDOW: u32 = 0x8001; // Custom message
extern "system" fn wndproc(
    window: HWND,
    message: u32,
    w_param: WPARAM,
    l_param: LPARAM,
) -> LRESULT {
    unsafe {
        match message {
            WM_NCHITTEST => {
                return LRESULT(HTTRANSPARENT as _);
            }
            WM_DESTROY_WINDOW => {
                PostQuitMessage(0);
                return LRESULT(0);
            }
            _ => {
                return DefWindowProcW(window, message, w_param, l_param);
            }
        }
    }
}

//TODO generated by AI, check later
fn is_windows8_or_greater() -> windows::core::Result<bool> {
    let mut os_info: OSVERSIONINFOW = unsafe { std::mem::zeroed() };
    os_info.dwOSVersionInfoSize = std::mem::size_of::<OSVERSIONINFOW>() as u32;

    unsafe {
        GetVersionExW(&mut os_info)?;
    }

    let r = (os_info.dwMajorVersion > 6)
        || (os_info.dwMajorVersion == 6 && os_info.dwMinorVersion >= 2);
    Ok(r)
}

lazy_static! {
    static ref REGISTERED_CLASS: AtomicBool = AtomicBool::new(false);
}

fn try_register_class() -> windows::core::Result<()> {
    if REGISTERED_CLASS.load(Ordering::Relaxed) {
        return Ok(());
    }

    unsafe {
        let instance = GetModuleHandleA(None)?;
        let cursor = LoadCursorW(None, IDC_ARROW)?;

        let mut style = CS_HREDRAW | CS_VREDRAW | CS_NOCLOSE;

        let enabled = DwmIsCompositionEnabled()?.as_bool();
        if is_windows8_or_greater()? || !enabled {
            style |= CS_OWNDC;
        }

        let window_class = w!("Win32DisplayClass");
        let wc = WNDCLASSEXW {
            cbSize: std::mem::size_of::<WNDCLASSEXW>() as u32,
            hCursor: cursor,
            hInstance: instance.into(),
            lpszClassName: window_class,
            style: CS_HREDRAW | CS_VREDRAW,
            lpfnWndProc: Some(wndproc),
            cbClsExtra: 0,
            cbWndExtra: 0,
            ..Default::default()
        };

        let atom = RegisterClassExW(&wc as *const _);
        if atom == 0 {
            return Err(std::io::Error::last_os_error().into());
        }
    }

    REGISTERED_CLASS.store(true, Ordering::Relaxed);
    Ok(())
}

#[derive(Debug)]
pub struct DisplayWindowManager {
    // Shouldn't really be needed
    message_thread: Option<std::thread::JoinHandle<()>>,
    should_exit: Arc<AtomicBool>,
    hwnd: WrappedHWND,

    x: i32,
    y: i32,

    width: u32,
    height: u32,

    scale: f32,

    is_hidden: AtomicBool,

    render_at_bottom: bool,

    pub(super) obs_display: Option<WrappedObsDisplay>,
}

#[derive(Debug, Clone, Copy)]
struct SendableHWND(pub HWND);

unsafe impl Sync for SendableHWND {}
unsafe impl Send for SendableHWND {}

impl DisplayWindowManager {
    pub fn new(parent: HWND, x: i32, y: i32, width: u32, height: u32) -> anyhow::Result<Self> {
        let (tx, rx) = oneshot::channel();

        let should_exit = Arc::new(AtomicBool::new(false));
        let tmp = should_exit.clone();

        let parent = Mutex::new(SendableHWND(parent));
        let message_thread = std::thread::spawn(move || {
            let parent = parent.lock().unwrap().0;
            // We have to have the whole window creation stuff here as well so the message loop functions
            let create = move || {
                log::trace!("Registering class...");
                try_register_class()?;
                let win8 = is_windows8_or_greater()?;
                let enabled = unsafe { DwmIsCompositionEnabled()?.as_bool() };

                let mut window_style = WS_EX_TRANSPARENT;
                if win8 && enabled {
                    window_style |= WS_EX_COMPOSITED;
                }

                let instance = unsafe { GetModuleHandleW(PCWSTR::null())? };

                let class_name = HSTRING::from("Win32DisplayClass");
                let window_name = HSTRING::from("LibObsChildWindowPreview");
                log::trace!("Creating window...");

                log::debug!(
                    "Creating window with x: {}, y: {}, width: {}, height: {}",
                    x,
                    y,
                    width,
                    height
                );
                let window = unsafe {
                    // More at https://github.com/stream-labs/obs-studio-node/blob/4e19d8a61a4dd7744e75ce77624c664e371cbfcf/obs-studio-server/source/nodeobs_display.cpp#L170
                    CreateWindowExW(
                        WS_EX_LAYERED,
                        &class_name,
                        &window_name,
                        WS_POPUP | WS_VISIBLE,
                        x,
                        y,
                        width as i32,
                        height as i32,
                        None,
                        None,
                        Some(instance.into()),
                        None,
                    )?
                };

                log::trace!("HWND is {:?}", window);
                if win8 || !enabled {
                    log::trace!("Setting attributes alpha...");
                    unsafe {
                        SetLayeredWindowAttributes(window, COLORREF(0), 255, LWA_ALPHA)?;
                    }
                }

                unsafe {
                    log::trace!("Setting parent...");
                    SetParent(window, Some(parent))?;
                    log::trace!("Setting styles...");
                    let mut style = GetWindowLongPtrW(window, GWL_STYLE);
                    //TODO Check casts here
                    style &= !(WS_POPUP.0 as isize);
                    style |= WS_CHILD.0 as isize;

                    SetWindowLongPtrW(window, GWL_STYLE, style);

                    let mut ex_style = GetWindowLongPtrW(window, GWL_EXSTYLE);
                    ex_style |= window_style.0 as isize;

                    SetWindowLongPtrW(window, GWL_EXSTYLE, ex_style);
                }

                Result::<SendableHWND, anyhow::Error>::Ok(SendableHWND(window))
            };

            let r = create();
            let window = r.as_ref().ok().map(|r| r.0.clone());
            tx.send(r).unwrap();
            if window.is_none() {
                return;
            }
            let window = window.unwrap();

            log::trace!("Starting up message thread...");
            let mut msg = MSG::default();
            unsafe {
                while !tmp.load(Ordering::Relaxed)
                    && GetMessageW(&mut msg, Some(window), 0, 0).as_bool()
                {
                    //TODO check if this can really be ignored
                    let _ = TranslateMessage(&msg);
                    DispatchMessageW(&msg);
                }
            }

            log::trace!("Exiting message thread...");
        });

        let window = rx.recv();
        let window = window??;
        Ok(Self {
            x,
            y,
            width,
            height,
            scale: 1.0,
            hwnd: WrappedHWND(window.0),
            should_exit,
            message_thread: Some(message_thread),
            render_at_bottom: false,
            is_hidden: AtomicBool::new(false),
            obs_display: None,
        })
    }

    pub fn get_child_handle(&self) -> HWND {
        self.hwnd.0.clone()
    }
}

impl Drop for DisplayWindowManager {
    fn drop(&mut self) {
        unsafe {
            self.should_exit.store(true, Ordering::Relaxed);

            log::trace!("Destroying window...");
            let res = PostMessageW(Some(self.hwnd.0), WM_DESTROY_WINDOW, WPARAM(0), LPARAM(0));
            if let Err(err) = res {
                log::error!("Failed to post destroy window message: {:?}", err);
            }

            let thread = self.message_thread.take();
            if let Some(thread) = thread {
                log::trace!("Waiting for message thread to exit...");
                thread.join().unwrap();
            }
        }
    }
}
