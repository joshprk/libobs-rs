E:\Rust\libobs-rs\cargo-obs-build\src\download.rs:
    1|       |use std::{
    2|       |    fs::File,
    3|       |    io::{stdout, BufReader, Write},
    4|       |    path::{Path, PathBuf},
    5|       |    sync::mpsc::{self},
    6|       |    thread,
    7|       |    time::{Duration, Instant},
    8|       |};
    9|       |
   10|       |use anyhow::{anyhow, bail};
   11|       |use colored::Colorize;
   12|       |use http_req::{
   13|       |    chunked::ChunkReader,
   14|       |    request::RequestMessage,
   15|       |    response::Response,
   16|       |    stream::{Stream, ThreadReceive, ThreadSend},
   17|       |    uri::Uri,
   18|       |};
   19|       |use indicatif::{ProgressBar, ProgressStyle};
   20|       |use log::{debug, error, info, trace};
   21|       |use sha2::{Digest, Sha256};
   22|       |
   23|       |use crate::git::ReleaseInfo;
   24|       |
   25|       |const DEFAULT_REQ_TIMEOUT: u64 = 60 * 60;
   26|       |
   27|      0|pub fn download_binaries(build_dir: &Path, info: &ReleaseInfo) -> anyhow::Result<PathBuf> {
   28|      0|    let architecture = if cfg!(target_arch = "x86_64") {
   29|      0|        "x64"
   30|       |    } else {
   31|      0|        "arm64"
   32|       |    };
   33|      0|    let to_download = &info.assets.iter().find(|e| {
   34|      0|        let name = e["name"].as_str().unwrap_or("").to_lowercase();
   35|       |
   36|       |        // OBS-Studio-30.2.1-Windows.zip
   37|      0|        name.contains("obs-studio")
   38|      0|            && (name.contains("windows") || name.contains("full"))
   39|      0|            && name.contains(".zip")
   40|      0|            && !name.contains("pdb")
   41|      0|            && name.contains(architecture)
   42|      0|    });
   43|       |
   44|      0|    if to_download.is_none() {
   45|      0|        bail!("No OBS Studio binaries found");
   46|      0|    }
   47|       |
   48|      0|    let to_download = to_download.unwrap();
   49|      0|    let url = to_download["browser_download_url"]
   50|      0|        .as_str()
   51|      0|        .ok_or(anyhow!("No download url found"))?;
   52|       |
   53|      0|    let download_path = build_dir.join("obs-prebuilt-windows.zip");
   54|       |
   55|      0|    println!("Downloading OBS from {}", url.green());
   56|      0|    let hash = download_file(url, &download_path)?;
   57|       |
   58|      0|    let name = to_download["name"].as_str().unwrap_or("");
   59|      0|    let checksum = &info.checksums.get(&name.to_lowercase());
   60|       |
   61|      0|    if let Some(checksum) = checksum {
   62|      0|        if checksum.to_lowercase() != hash.to_lowercase() {
   63|      0|            bail!("Checksums do not match");
   64|       |        } else {
   65|      0|            info!("{}", "Checksums match".on_green());
   66|       |        }
   67|       |    } else {
   68|      0|        error!("No checksum found for {}", name);
   69|       |    }
   70|       |
   71|      0|    Ok(download_path)
   72|      0|}
   73|       |
   74|       |/// Returns hash
   75|      0|pub fn download_file(url: &str, path: &Path) -> anyhow::Result<String> {
   76|      0|    let timeout = Duration::from_secs(60);
   77|      0|    debug!("Downloading OBS binaries from {}", url.green());
   78|       |
   79|      0|    let uri = Uri::try_from(url)?;
   80|      0|    let mut stream = Stream::connect(&uri, Some(timeout))?;
   81|       |
   82|      0|    stream.set_read_timeout(Some(timeout))?;
   83|      0|    stream.set_write_timeout(Some(timeout))?;
   84|       |
   85|      0|    stream = Stream::try_to_https(stream, &uri, None)?;
   86|       |
   87|      0|    let res = RequestMessage::new(&uri)
   88|      0|        .header("Connection", "Close")
   89|      0|        .header("User-Agent", "cargo-obs-build")
   90|      0|        .parse();
   91|      0|    stream.write_all(&res)?;
   92|       |
   93|       |    // Set up variables
   94|      0|    let (sender, receiver) = mpsc::channel();
   95|      0|    let (sender_supp, receiver_supp) = mpsc::channel();
   96|      0|    let mut raw_response_head: Vec<u8> = Vec::new();
   97|      0|    let mut buf_reader = BufReader::new(stream);
   98|       |
   99|       |    // Read from the stream and send over data via `sender`.
  100|      0|    thread::spawn(move || {
  101|      0|        buf_reader.send_head(&sender);
  102|       |
  103|      0|        let params = receiver_supp.recv();
  104|      0|        if params.is_err() {
  105|      0|            return;
  106|      0|        }
  107|       |
  108|      0|        let params: Vec<&str> = params.unwrap();
  109|       |        //TODO this never exists
  110|      0|        if params.contains(&"chunked") {
  111|      0|            let mut buf_reader = ChunkReader::from(buf_reader);
  112|      0|            buf_reader.send_all(&sender);
  113|      0|        } else {
  114|      0|            buf_reader.send_all(&sender);
  115|      0|        }
  116|      0|    });
  117|       |
  118|      0|    let deadline = Instant::now() + Duration::from_secs(DEFAULT_REQ_TIMEOUT);
  119|       |
  120|       |    // Receive and process `head` of the response.
  121|      0|    raw_response_head.receive(&receiver, deadline)?;
  122|       |
  123|      0|    let response = Response::from_head(&raw_response_head)?;
  124|      0|    let content_len = response.content_len().unwrap_or(1) as u64;
  125|      0|    let encoding = response.headers().get("Transfer-Encoding");
  126|      0|    let mut params = Vec::with_capacity(4);
  127|       |
  128|      0|    if response.status_code().is_redirect() {
  129|      0|        let location = response.headers().get("Location");
  130|      0|        if location.is_none() {
  131|      0|            bail!("No location header found");
  132|      0|        }
  133|       |
  134|      0|        let location = location.unwrap();
  135|      0|        return download_file(location, path);
  136|      0|    }
  137|       |
  138|      0|    if let Some(encode) = encoding {
  139|      0|        if encode == "chunked" {
  140|      0|            params.push("chunked");
  141|      0|        }
  142|      0|    }
  143|       |
  144|      0|    sender_supp.send(params).unwrap();
  145|       |
  146|      0|    if content_len == 0 {
  147|      0|        bail!("Content length is 0");
  148|      0|    }
  149|       |
  150|      0|    let style = ProgressStyle::default_bar()
  151|      0|    .template("{msg}\n{spinner:.green} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {bytes}/{total_bytes} ({bytes_per_sec}, {eta})")
  152|      0|    .map_err(|e| anyhow!("Couldn't create style {:#?}", e))?
  153|      0|    .progress_chars("#>-");
  154|       |
  155|      0|    let pb = ProgressBar::new(content_len);
  156|      0|    pb.set_style(style);
  157|      0|    pb.set_message("Downloading OBS binaries".to_string());
  158|       |
  159|      0|    let mut file =
  160|      0|        File::create(path).or(Err(anyhow!("Failed to create file '{}'", path.display())))?;
  161|      0|    let mut downloaded: u64 = 0;
  162|       |
  163|      0|    let mut hasher = Sha256::new();
  164|       |    loop {
  165|      0|        let now = Instant::now();
  166|      0|        let remaining_time = deadline - now;
  167|       |
  168|      0|        let item = receiver.recv_timeout(remaining_time);
  169|      0|        if let Err(_e) = item {
  170|      0|            break;
  171|      0|        }
  172|       |
  173|      0|        let chunk = item.unwrap();
  174|       |
  175|      0|        hasher.write_all(&chunk)?;
  176|      0|        file.write_all(&chunk)
  177|      0|            .or(Err(anyhow!("Error while writing to file")))?;
  178|       |
  179|      0|        let new = std::cmp::min(downloaded + (chunk.len() as u64), content_len);
  180|      0|        downloaded = new;
  181|      0|        pb.set_position(new);
  182|       |    }
  183|       |
  184|      0|    pb.finish_with_message(format!("Downloaded OBS to {}", path.display()));
  185|      0|    trace!("Hashing...");
  186|      0|    stdout().flush().unwrap();
  187|      0|    Ok(hex::encode(hasher.finalize()))
  188|      0|}

E:\Rust\libobs-rs\cargo-obs-build\src\git.rs:
    1|       |use anyhow::{anyhow, bail};
    2|       |use http_req::{request::Request, response::StatusCode, uri::Uri};
    3|       |use serde_json::Value;
    4|       |use std::collections::HashMap;
    5|       |
    6|       |#[derive(Clone, Debug)]
    7|       |pub struct ReleaseInfo {
    8|       |    pub tag: String,
    9|       |    pub assets: Vec<Value>,
   10|       |    pub checksums: HashMap<String, String>,
   11|       |}
   12|       |
   13|      0|pub fn fetch_release(repo_id: &str, tag: &Option<String>) -> anyhow::Result<ReleaseInfo> {
   14|      0|    let tag = tag.clone();
   15|      0|    let tag = if tag.is_none() {
   16|      0|        "latest"
   17|       |    } else {
   18|      0|        &format!("tags/{}", tag.unwrap())
   19|       |    };
   20|      0|    let url = format!("https://api.github.com/repos/{}/releases/{}", repo_id, tag);
   21|      0|    let url = Uri::try_from(url.as_str())?;
   22|       |
   23|      0|    let mut body = Vec::new(); //Container for body of a response.
   24|      0|    let res = Request::new(&url)
   25|      0|        .header("User-Agent", "cargo-obs-build")
   26|      0|        .send(&mut body)?;
   27|       |
   28|      0|    if res.status_code() != StatusCode::new(200) {
   29|      0|        bail!(
   30|      0|            "Failed to fetch latest release: {} with {}",
   31|      0|            res.status_code(),
   32|      0|            String::from_utf8(body).unwrap_or("Couldn't parse".to_string())
   33|       |        );
   34|      0|    }
   35|       |
   36|      0|    let body = String::from_utf8(body)?;
   37|      0|    let body: Value = serde_json::from_str(&body)?;
   38|      0|    let tag_name = body["tag_name"].as_str();
   39|       |
   40|      0|    if tag_name.is_none() {
   41|      0|        bail!("Tag name in release is none");
   42|      0|    }
   43|       |
   44|      0|    let tag = tag_name.unwrap();
   45|      0|    let assets = body["assets"]
   46|      0|        .as_array()
   47|      0|        .ok_or(anyhow!("No assets found"))?;
   48|       |
   49|      0|    let mut checksums = HashMap::new();
   50|      0|    let note = body["body"].as_str().unwrap_or("");
   51|       |
   52|      0|    let split = note.replace("\r", "");
   53|      0|    let split = split.split("\n");
   54|       |
   55|      0|    let mut is_checksums = false;
   56|      0|    for line in split {
   57|      0|        if line.to_lowercase().contains("checksums") {
   58|      0|            is_checksums = true;
   59|      0|            continue;
   60|      0|        }
   61|       |
   62|      0|        if !is_checksums {
   63|      0|            continue;
   64|      0|        }
   65|       |
   66|      0|        let split: Vec<&str> = line.trim().split(":").collect();
   67|      0|        if split.len() != 2 {
   68|      0|            continue;
   69|      0|        }
   70|       |
   71|      0|        checksums.insert(
   72|      0|            split[0].trim().to_lowercase().to_string(),
   73|      0|            split[1].trim().to_string(),
   74|       |        );
   75|       |    }
   76|       |
   77|      0|    Ok(ReleaseInfo {
   78|      0|        tag: tag.to_string(),
   79|      0|        assets: assets.clone(),
   80|      0|        checksums,
   81|      0|    })
   82|      0|}
   83|       |
   84|      0|pub fn fetch_latest_patch_release(
   85|      0|    repo_id: &str,
   86|      0|    major: u32,
   87|      0|    minor: u32,
   88|      0|) -> anyhow::Result<Option<String>> {
   89|      0|    let url = format!("https://api.github.com/repos/{}/releases", repo_id);
   90|      0|    let url = Uri::try_from(url.as_str())?;
   91|       |
   92|      0|    let mut body = Vec::new();
   93|      0|    let res = Request::new(&url)
   94|      0|        .header("User-Agent", "cargo-obs-build")
   95|      0|        .send(&mut body)?;
   96|       |
   97|      0|    if res.status_code() != StatusCode::new(200) {
   98|      0|        bail!(
   99|      0|            "Failed to fetch releases: {} with {}",
  100|      0|            res.status_code(),
  101|      0|            String::from_utf8(body).unwrap_or("Couldn't parse".to_string())
  102|       |        );
  103|      0|    }
  104|       |
  105|      0|    let body = String::from_utf8(body)?;
  106|      0|    let arr: Vec<Value> = serde_json::from_str(&body)?;
  107|       |
  108|      0|    let mut best_patch: Option<u32> = None;
  109|      0|    let mut best_tag: Option<String> = None;
  110|       |
  111|      0|    for rel in arr.iter() {
  112|       |        // skip drafts and prereleases
  113|      0|        if rel["draft"].as_bool().unwrap_or(false) || rel["prerelease"].as_bool().unwrap_or(false) {
  114|      0|            continue;
  115|      0|        }
  116|      0|        let tag_name = rel["tag_name"].as_str().unwrap_or("").to_string();
  117|      0|        if tag_name.is_empty() {
  118|      0|            continue;
  119|      0|        }
  120|      0|        let parts: Vec<&str> = tag_name.trim_start_matches('v').split('.').collect();
  121|      0|        if parts.len() < 3 {
  122|      0|            continue;
  123|      0|        }
  124|      0|        let r_major = parts[0].parse::<u32>().unwrap_or(0);
  125|      0|        let r_minor = parts[1].parse::<u32>().unwrap_or(0);
  126|      0|        let r_patch = parts[2].parse::<u32>().unwrap_or(0);
  127|       |
  128|      0|        if r_major == major
  129|      0|            && r_minor == minor
  130|      0|            && (best_patch.is_none() || r_patch > best_patch.unwrap())
  131|      0|        {
  132|      0|            best_patch = Some(r_patch);
  133|      0|            best_tag = Some(tag_name);
  134|      0|        }
  135|       |    }
  136|       |
  137|      0|    Ok(best_tag)
  138|      0|}

E:\Rust\libobs-rs\cargo-obs-build\src\lib_version.rs:
    1|       |use std::path::PathBuf;
    2|       |
    3|       |use anyhow::Context;
    4|       |use cargo_metadata::{MetadataCommand, Package};
    5|       |use log::{debug, info, warn};
    6|       |use regex::Regex;
    7|       |
    8|      0|pub fn get_lib_obs_version() -> anyhow::Result<(u32, u32, u32)> {
    9|      0|    let re = Regex::new(r"^(#define LIBOBS_API_(MAJOR|MINOR|PATCH)_VER\s*)(\d+)$").unwrap();
   10|       |
   11|      0|    info!("Getting libobs version from bindings...");
   12|      0|    let meta = MetadataCommand::new().exec()?;
   13|       |
   14|      0|    let pkgs = meta
   15|      0|        .packages
   16|      0|        .iter()
   17|      0|        .filter(|p| p.name == "libobs")
   18|      0|        .collect::<Vec<&Package>>();
   19|       |
   20|      0|    if pkgs.is_empty() {
   21|      0|        anyhow::bail!("could not find libobs package in metadata");
   22|      0|    }
   23|       |
   24|       |    // Check if every package has the same version
   25|      0|    let mut pkg = &pkgs[0];
   26|      0|    if pkgs.len() > 1 {
   27|      0|        for p in &pkgs[1..] {
   28|      0|            if p.version > pkg.version {
   29|      0|                pkg = p;
   30|      0|            }
   31|       |        }
   32|       |
   33|      0|        warn!(
   34|      0|            "multiple libobs packages found in metadata, using the one with the highest version: {}",
   35|       |            pkg.version
   36|       |        );
   37|      0|    }
   38|       |
   39|      0|    let manifest = PathBuf::from(pkg.manifest_path.clone());
   40|      0|    let dir = manifest
   41|      0|        .parent()
   42|      0|        .context("manifest path has no parent directory")?;
   43|       |
   44|      0|    let bindings_file = dir.join("headers").join("obs").join("obs-config.h");
   45|      0|    let bindings = std::fs::read_to_string(&bindings_file)
   46|      0|        .with_context(|| format!("failed to read bindings file: {}", bindings_file.display()))?;
   47|       |
   48|      0|    debug!("bindings file: {}", bindings_file.display());
   49|      0|    let version_parts = bindings
   50|      0|        .lines()
   51|      0|        .filter_map(|line| {
   52|       |            // use the Option result directly and propagate missing groups via `?`
   53|      0|            re.captures(line).and_then(|captures| {
   54|      0|                let name = captures.get(2)?.as_str();
   55|      0|                let version = captures.get(3)?.as_str();
   56|      0|                Some((name, version))
   57|      0|            })
   58|      0|        })
   59|      0|        .collect::<Vec<_>>();
   60|       |
   61|      0|    let major_version: Option<u32> = version_parts.iter().find_map(|(name, version)| {
   62|      0|        if name.contains("MAJOR") {
   63|      0|            version.parse().ok()
   64|       |        } else {
   65|      0|            None
   66|       |        }
   67|      0|    });
   68|      0|    let minor_version: Option<u32> = version_parts.iter().find_map(|(name, version)| {
   69|      0|        if name.contains("MINOR") {
   70|      0|            version.parse().ok()
   71|       |        } else {
   72|      0|            None
   73|       |        }
   74|      0|    });
   75|       |
   76|      0|    let patch_version: Option<u32> = version_parts.iter().find_map(|(name, version)| {
   77|      0|        if name.contains("PATCH") {
   78|      0|            version.parse().ok()
   79|       |        } else {
   80|      0|            None
   81|       |        }
   82|      0|    });
   83|       |
   84|      0|    if major_version.is_none() || minor_version.is_none() || patch_version.is_none() {
   85|      0|        anyhow::bail!("failed to find version parts in bindings");
   86|      0|    }
   87|       |
   88|      0|    let obs_version = (
   89|      0|        major_version.unwrap(),
   90|      0|        minor_version.unwrap(),
   91|      0|        patch_version.unwrap(),
   92|      0|    );
   93|       |
   94|      0|    Ok(obs_version)
   95|      0|}

E:\Rust\libobs-rs\cargo-obs-build\src\lock.rs:
    1|       |use std::{
    2|       |    fs::{self, File},
    3|       |    io::{stdout, Read, Write},
    4|       |    path::{Path, PathBuf},
    5|       |};
    6|       |
    7|       |use process_alive::Pid;
    8|       |
    9|      0|pub fn wait_for_lock(lock: &Path) -> anyhow::Result<()> {
   10|      0|    if !lock.is_file() {
   11|      0|        return Ok(());
   12|      0|    }
   13|       |
   14|      0|    let mut f = File::open(lock)?;
   15|      0|    let mut pid = String::new();
   16|       |
   17|      0|    f.read_to_string(&mut pid)?;
   18|      0|    let pid = pid
   19|      0|        .trim()
   20|      0|        .parse::<u32>()
   21|      0|        .map_err(|e| anyhow::anyhow!("Failed to parse PID from lock file: {}", e));
   22|       |
   23|      0|    if pid.is_err() {
   24|      0|        fs::remove_file(lock)?;
   25|      0|        return Ok(());
   26|      0|    }
   27|       |
   28|      0|    let pid = Pid::from(pid?);
   29|      0|    let state = process_alive::state(pid);
   30|       |
   31|      0|    if state.is_alive() {
   32|      0|        println!("Another instance is already running, waiting");
   33|      0|        while process_alive::state(pid).is_alive() {
   34|      0|            std::thread::sleep(std::time::Duration::from_secs(1));
   35|      0|            print!(".");
   36|      0|            stdout().flush()?;
   37|       |        }
   38|       |
   39|      0|        println!();
   40|      0|    }
   41|      0|    Ok(())
   42|      0|}
   43|       |
   44|       |pub struct LockGuard {
   45|       |    lock: PathBuf,
   46|       |}
   47|       |
   48|       |impl Drop for LockGuard {
   49|      0|    fn drop(&mut self) {
   50|      0|        fs::remove_file(&self.lock).unwrap();
   51|      0|    }
   52|       |}
   53|       |
   54|      0|pub fn acquire_lock(lock: &Path) -> anyhow::Result<LockGuard> {
   55|      0|    let pid = std::process::id().to_string();
   56|      0|    fs::write(lock, pid)?;
   57|       |
   58|      0|    Ok(LockGuard {
   59|      0|        lock: lock.to_path_buf(),
   60|      0|    })
   61|      0|}

E:\Rust\libobs-rs\cargo-obs-build\src\main.rs:
    1|       |use download::download_binaries;
    2|       |use git::{fetch_latest_patch_release, fetch_release, ReleaseInfo};
    3|       |use lock::{acquire_lock, wait_for_lock};
    4|       |use log::{debug, info, warn};
    5|       |use metadata::{fetch_latest_release_tag, get_meta_info};
    6|       |use std::{
    7|       |    env::{self, args},
    8|       |    fs::{self, File},
    9|       |    path::{Path, PathBuf},
   10|       |};
   11|       |use util::{copy_to_dir, delete_all_except};
   12|       |use walkdir::WalkDir;
   13|       |use zip::ZipArchive;
   14|       |
   15|       |use clap::Parser;
   16|       |use colored::Colorize;
   17|       |
   18|       |use crate::lib_version::get_lib_obs_version;
   19|       |
   20|       |mod download;
   21|       |mod git;
   22|       |mod lib_version;
   23|       |mod lock;
   24|       |mod metadata;
   25|       |mod util;
   26|       |
   27|       |#[derive(Parser, Debug)]
   28|       |#[command(version, about, long_about = None)]
   29|       |struct RunArgs {
   30|       |    /// The directory the OBS Studio binaries should be copied to
   31|       |    #[arg(short, long)]
   32|       |    out_dir: String,
   33|       |
   34|       |    /// The location where the OBS Studio sources should be cloned to
   35|       |    #[arg(short, long, default_value = "obs-build")]
   36|       |    cache_dir: PathBuf,
   37|       |
   38|       |    /// The github repository to clone OBS Studio from
   39|       |    #[arg(long, default_value = "obsproject/obs-studio")]
   40|       |    repo_id: String,
   41|       |
   42|       |    #[arg(long)]
   43|       |    /// If this is specified, the specified zip file will be used instead of downloading the latest release
   44|       |    /// This is useful for testing purposes, but it is not recommended to use this in production
   45|       |    override_zip: Option<PathBuf>,
   46|       |
   47|       |    /// When this flag is active, the cache will be cleared and a new build will be started
   48|       |    #[arg(short, long, default_value_t = false)]
   49|       |    rebuild: bool,
   50|       |
   51|       |    /// If the browser should be included in the build
   52|       |    #[arg(short, long, default_value_t = false)]
   53|       |    browser: bool,
   54|       |
   55|       |    /// The tag of the OBS Studio release to build.
   56|       |    /// If none is specified, the matching release for the libobs crate will be used.
   57|       |    /// Use `latest` for the latest obs release. If a version in the `workspace.metadata` is set, that version will be used.
   58|       |    #[arg(short, long)]
   59|       |    tag: Option<String>,
   60|       |
   61|       |    /// If the browser should be included in the build
   62|       |    #[arg(short, long, default_value_t = false)]
   63|       |    skip_compatibility_check: bool,
   64|       |}
   65|       |
   66|      0|fn setup_logger() -> Result<(), fern::InitError> {
   67|      0|    let level = env::var("RUST_LOG")
   68|      0|        .ok()
   69|      0|        .and_then(|val| val.parse().ok()) // Try parsing e.g. "debug", "warn", etc.
   70|      0|        .unwrap_or(log::LevelFilter::Info); // Default if not set
   71|       |
   72|      0|    fern::Dispatch::new()
   73|      0|        .format(|out, message, record| {
   74|      0|            let level_color = match record.level() {
   75|      0|                log::Level::Error => "red",
   76|      0|                log::Level::Warn => "yellow",
   77|      0|                log::Level::Info => "green",
   78|      0|                log::Level::Debug => "blue",
   79|      0|                log::Level::Trace => "bright_black",
   80|       |            };
   81|      0|            out.finish(format_args!(
   82|      0|                "[{}] {}",
   83|      0|                record.level().to_string().color(level_color),
   84|       |                message
   85|       |            ))
   86|      0|        })
   87|      0|        .level(level)
   88|      0|        .chain(std::io::stdout())
   89|      0|        .apply()?;
   90|      0|    Ok(())
   91|      0|}
   92|       |
   93|      0|fn main() -> anyhow::Result<()> {
   94|      0|    setup_logger()?;
   95|       |
   96|      0|    let mut args: Vec<_> = args().collect();
   97|      0|    if args.get(1).is_some_and(|e| e == "obs-build") {
   98|      0|        args.remove(1);
   99|      0|    }
  100|       |
  101|      0|    let args = RunArgs::parse_from(args);
  102|       |
  103|       |    let RunArgs {
  104|      0|        mut cache_dir,
  105|      0|        repo_id,
  106|      0|        out_dir,
  107|      0|        rebuild,
  108|      0|        browser,
  109|      0|        mut tag,
  110|      0|        override_zip,
  111|      0|        skip_compatibility_check,
  112|      0|    } = args;
  113|       |
  114|      0|    let mut obs_ver = None;
  115|      0|    if tag.is_none() {
  116|      0|        obs_ver = Some(get_lib_obs_version()?);
  117|      0|        let (major, minor, patch) = obs_ver.as_ref().unwrap();
  118|      0|        let lib_tag = format!("{}.{}.{}", major, minor, patch);
  119|       |
  120|       |        // Check if a newer version of libobs (same major/minor, higher patch) exists in releases.
  121|       |        // If found, use that tag; otherwise fall back to the crate version tag.
  122|      0|        match fetch_latest_patch_release(&repo_id, *major, *minor) {
  123|      0|            Ok(Some(found_tag)) => {
  124|      0|                let parts: Vec<&str> = found_tag.trim_start_matches('v').split('.').collect();
  125|      0|                let found_patch = parts
  126|      0|                    .get(2)
  127|      0|                    .and_then(|s| s.parse::<u32>().ok())
  128|      0|                    .unwrap_or(0);
  129|      0|                if found_patch > *patch {
  130|      0|                    info!(
  131|      0|                        "Found newer libobs binaries release {} (crate: {}). Using {}",
  132|      0|                        found_tag.green(),
  133|       |                        lib_tag,
  134|      0|                        found_tag.green()
  135|       |                    );
  136|      0|                    tag = Some(found_tag);
  137|      0|                } else {
  138|      0|                    // no newer patch found -> use crate version
  139|      0|                    tag = Some(lib_tag);
  140|      0|                }
  141|       |            }
  142|      0|            Ok(None) => {
  143|      0|                // none found -> use crate version
  144|      0|                tag = Some(lib_tag);
  145|      0|            }
  146|      0|            Err(e) => {
  147|       |                // On error, log debug and fall back to crate version
  148|      0|                warn!("Failed to check for newer compatible libobs release: {}", e);
  149|      0|                tag = Some(lib_tag);
  150|       |            }
  151|       |        }
  152|      0|    }
  153|       |
  154|      0|    let mut tag = tag.unwrap();
  155|      0|    let target_out_dir = PathBuf::new().join(&out_dir);
  156|      0|    get_meta_info(&mut cache_dir, &mut tag)?;
  157|       |
  158|      0|    let tag = if tag.trim() == "latest" {
  159|      0|        fetch_latest_release_tag(&repo_id)?
  160|       |    } else {
  161|      0|        tag
  162|       |    };
  163|       |
  164|      0|    if !skip_compatibility_check {
  165|      0|        let (major, minor, patch) = if let Some(v) = obs_ver {
  166|      0|            v
  167|       |        } else {
  168|      0|            get_lib_obs_version()?
  169|       |        };
  170|       |
  171|      0|        info!(
  172|      0|            "Detected libobs crate version: {}.{}.{}",
  173|       |            major, minor, patch
  174|       |        );
  175|      0|        let tag_parts: Vec<&str> = tag.trim_start_matches('v').split('.').collect();
  176|      0|        let tag_parts = tag_parts
  177|      0|            .iter()
  178|      0|            .map(|e| e.parse::<u32>().unwrap_or(0))
  179|      0|            .collect::<Vec<u32>>();
  180|       |
  181|      0|        if tag_parts.len() < 3 {
  182|      0|            info!(
  183|      0|                "{}",
  184|      0|                "Warning: Could not determine libobs compatibility, tag does not have 3 parts"
  185|      0|                    .red()
  186|       |            );
  187|       |        } else {
  188|      0|            let (tag_major, tag_minor, tag_patch) = (tag_parts[0], tag_parts[1], tag_parts[2]);
  189|      0|            if major != tag_major || minor != tag_minor {
  190|       |                use log::warn;
  191|       |
  192|      0|                warn!(
  193|      0|                    "{}",
  194|      0|                    format!("libobs (crate) version {}.{}.{} may not be compatible with libobs (binaries) {}.{}.{}",
  195|      0|                        major, minor, patch, tag_major, tag_minor, tag_patch).red()
  196|       |                );
  197|      0|                warn!(
  198|      0|                    "{} {} {}",
  199|      0|                    "Set the `libobs-version` in `[workspace.metadata]` to".red(),
  200|      0|                    format!("{}.{}.{}", major, minor, patch).red(),
  201|       |                    "to avoid runtime issues"
  202|       |                );
  203|       |            } else {
  204|      0|                info!(
  205|      0|                        "{}",
  206|      0|                        format!(
  207|      0|                            "libobs (crate) version {}.{}.{} should be compatible with libobs (binaries) {}.{}.{}",
  208|      0|                            major, minor, patch, tag_major, tag_minor, tag_patch
  209|      0|                        )
  210|      0|                        .green()
  211|       |                    );
  212|       |            }
  213|       |        }
  214|      0|    }
  215|       |
  216|      0|    let repo_dir = cache_dir.join(&tag);
  217|      0|    let repo_exists = repo_dir.is_dir();
  218|       |
  219|      0|    if !repo_exists {
  220|      0|        fs::create_dir_all(&repo_dir)?;
  221|      0|    }
  222|       |
  223|      0|    let build_out = repo_dir.join("build_out");
  224|      0|    let lock_file = cache_dir.join(format!("{}.lock", tag));
  225|      0|    let success_file = repo_dir.join(".success");
  226|       |
  227|      0|    wait_for_lock(&lock_file)?;
  228|       |
  229|      0|    if !success_file.is_file() || rebuild {
  230|      0|        let lock = acquire_lock(&lock_file)?;
  231|      0|        if repo_exists || rebuild {
  232|      0|            debug!("{}", "Cleaning up old build...".bright_black());
  233|      0|            delete_all_except(&repo_dir, None)?;
  234|      0|        }
  235|       |
  236|      0|        debug!("Fetching {} version of OBS Studio...", tag.on_blue());
  237|       |
  238|      0|        let release = fetch_release(&repo_id, &Some(tag.clone()))?;
  239|      0|        build_obs(release, &build_out, browser, override_zip)?;
  240|       |
  241|      0|        File::create(&success_file)?;
  242|      0|        drop(lock);
  243|      0|    }
  244|       |
  245|      0|    info!(
  246|      0|        "Copying files from {} to {}",
  247|      0|        build_out.display().to_string().green(),
  248|      0|        target_out_dir.display().to_string().green()
  249|       |    );
  250|      0|    copy_to_dir(&build_out, &target_out_dir, None)?;
  251|       |
  252|      0|    info!("Done!");
  253|       |
  254|      0|    Ok(())
  255|      0|}
  256|       |
  257|      0|fn build_obs(
  258|      0|    release: ReleaseInfo,
  259|      0|    build_out: &Path,
  260|      0|    include_browser: bool,
  261|      0|    override_zip: Option<PathBuf>,
  262|      0|) -> anyhow::Result<()> {
  263|       |    #[cfg(not(target_family = "windows"))]
  264|       |    panic!("Unsupported platform");
  265|       |
  266|      0|    fs::create_dir_all(build_out)?;
  267|       |
  268|      0|    let obs_path = if let Some(e) = override_zip {
  269|      0|        e
  270|       |    } else {
  271|      0|        download_binaries(build_out, &release)?
  272|       |    };
  273|       |
  274|      0|    let obs_archive = File::open(&obs_path)?;
  275|      0|    let mut archive = ZipArchive::new(&obs_archive)?;
  276|       |
  277|      0|    info!("{} OBS Studio binaries...", "Extracting".on_blue());
  278|      0|    archive.extract(build_out)?;
  279|      0|    let bin_path = build_out.join("bin").join("64bit");
  280|      0|    copy_to_dir(&bin_path, build_out, None)?;
  281|      0|    fs::remove_dir_all(build_out.join("bin"))?;
  282|       |
  283|      0|    clean_up_files(build_out, include_browser)?;
  284|       |
  285|      0|    fs::remove_file(&obs_path)?;
  286|       |
  287|      0|    Ok(())
  288|      0|}
  289|       |
  290|      0|fn clean_up_files(build_out: &Path, include_browser: bool) -> anyhow::Result<()> {
  291|      0|    let mut to_exclude = vec![
  292|       |        "obs64",
  293|      0|        "frontend",
  294|      0|        "obs-webrtc",
  295|      0|        "obs-websocket",
  296|      0|        "decklink",
  297|      0|        "obs-scripting",
  298|      0|        "qt6",
  299|      0|        "qminimal",
  300|      0|        "qwindows",
  301|      0|        "imageformats",
  302|      0|        "obs-studio",
  303|      0|        "aja-output-ui",
  304|      0|        "obs-vst",
  305|       |    ];
  306|       |
  307|      0|    if !include_browser {
  308|      0|        to_exclude.append(&mut vec![
  309|      0|            "obs-browser",
  310|      0|            "obs-browser-page",
  311|      0|            "chrome_",
  312|      0|            "resources",
  313|      0|            "cef",
  314|      0|            "snapshot",
  315|      0|            "locales",
  316|      0|        ]);
  317|      0|    }
  318|       |
  319|      0|    info!("{}", "Cleaning up unnecessary files...".red());
  320|      0|    for entry in WalkDir::new(build_out).into_iter().flatten() {
  321|      0|        let path = entry.path();
  322|      0|        if to_exclude.iter().any(|e| {
  323|      0|            path.file_name().is_some_and(|x| {
  324|      0|                let x_l = x.to_string_lossy().to_lowercase();
  325|      0|                x_l.contains(e) || x_l == *e
  326|      0|            })
  327|      0|        }) {
  328|      0|            debug!("Deleting: {}", path.display().to_string().red());
  329|      0|            if path.is_dir() {
  330|      0|                fs::remove_dir_all(path)?;
  331|       |            } else {
  332|      0|                fs::remove_file(path)?;
  333|       |            }
  334|      0|        }
  335|       |    }
  336|       |
  337|      0|    Ok(())
  338|      0|}

E:\Rust\libobs-rs\cargo-obs-build\src\metadata.rs:
    1|       |use std::{env::current_dir, path::PathBuf};
    2|       |
    3|       |use crate::git::fetch_release;
    4|       |use anyhow::{anyhow, Context, Result};
    5|       |use toml::{map::Map, Table, Value};
    6|       |
    7|      0|pub fn get_main_meta() -> Result<Option<Map<String, Value>>> {
    8|      0|    let dir = current_dir()?;
    9|       |
   10|      0|    let meta = dir.join("Cargo.toml");
   11|      0|    if !meta.is_file() {
   12|      0|        return Ok(None);
   13|      0|    }
   14|       |
   15|      0|    let meta = std::fs::read_to_string(meta).context("Reading Cargo.toml")?;
   16|       |
   17|      0|    let parsed: Table = toml::from_str(&meta)?;
   18|      0|    let val = parsed
   19|      0|        .get("package")
   20|      0|        .or_else(|| parsed.get("workspace"))
   21|      0|        .and_then(|package| package.as_table())
   22|      0|        .and_then(|package| package.get("metadata"))
   23|      0|        .and_then(|metadata| metadata.as_table())
   24|      0|        .cloned();
   25|       |
   26|      0|    Ok(val)
   27|      0|}
   28|       |
   29|      0|pub fn read_val_from_meta(m: &Map<String, Value>, key: &str) -> anyhow::Result<String> {
   30|      0|    let tag = m.get(key).and_then(|tag| tag.as_str()).ok_or_else(|| {
   31|      0|        anyhow!(
   32|      0|            "Failed to read `{}` from Cargo.toml under `package.metadata` or `workspace.metadata`",
   33|       |            key
   34|       |        )
   35|      0|    })?;
   36|       |
   37|      0|    Ok(tag.to_string())
   38|      0|}
   39|       |
   40|      0|pub fn get_meta_info(cache_dir: &mut PathBuf, tag: &mut String) -> anyhow::Result<()> {
   41|      0|    let meta = get_main_meta()?;
   42|       |
   43|      0|    if let Some(meta) = meta {
   44|      0|        if let Ok(dir) = read_val_from_meta(&meta, "libobs-cache-dir").map(PathBuf::from) {
   45|      0|            *cache_dir = dir;
   46|      0|        }
   47|       |
   48|      0|        if let Ok(version) = read_val_from_meta(&meta, "libobs-version") {
   49|      0|            *tag = version;
   50|      0|        }
   51|      0|    }
   52|       |
   53|      0|    Ok(())
   54|      0|}
   55|       |
   56|      0|pub fn fetch_latest_release_tag(repo_id: &str) -> anyhow::Result<String> {
   57|      0|    let release = fetch_release(repo_id, &None)?;
   58|      0|    Ok(release.tag)
   59|      0|}

E:\Rust\libobs-rs\cargo-obs-build\src\util.rs:
    1|       |use std::{fs, path::Path};
    2|       |
    3|       |use walkdir::WalkDir;
    4|       |
    5|      0|pub fn copy_to_dir(src: &Path, out: &Path, except_dir: Option<&Path>) -> anyhow::Result<()> {
    6|      0|    for entry in WalkDir::new(src) {
    7|      0|        if entry.is_err() {
    8|      0|            continue;
    9|      0|        }
   10|       |
   11|      0|        let entry = entry.unwrap();
   12|      0|        let path = entry.path();
   13|       |
   14|      0|        if except_dir.is_some_and(|e| path.starts_with(e)) {
   15|      0|            continue;
   16|      0|        }
   17|       |
   18|      0|        let copy_to = out.join(path.strip_prefix(src).unwrap());
   19|      0|        if path.is_dir() {
   20|      0|            fs::create_dir_all(&copy_to)?;
   21|      0|            continue;
   22|      0|        }
   23|       |
   24|      0|        fs::copy(entry.path(), copy_to)?;
   25|       |    }
   26|       |
   27|      0|    Ok(())
   28|      0|}
   29|       |
   30|      0|pub fn delete_all_except(src: &Path, except_dir: Option<&Path>) -> anyhow::Result<()> {
   31|      0|    for entry in fs::read_dir(src)? {
   32|      0|        if entry.is_err() {
   33|      0|            continue;
   34|      0|        }
   35|       |
   36|      0|        let entry = entry.unwrap();
   37|      0|        let path = entry.path();
   38|       |
   39|      0|        if except_dir.is_some_and(|e| path.starts_with(e)) {
   40|      0|            continue;
   41|      0|        }
   42|       |
   43|      0|        if path.is_dir() {
   44|      0|            fs::remove_dir_all(path).unwrap();
   45|      0|        } else {
   46|      0|            fs::remove_file(path).unwrap();
   47|      0|        }
   48|       |    }
   49|       |
   50|      0|    Ok(())
   51|      0|}

E:\Rust\libobs-rs\libobs-bootstrapper\src\download.rs:
    1|       |use std::{env::temp_dir, path::PathBuf};
    2|       |
    3|       |use anyhow::Context;
    4|       |use async_stream::stream;
    5|       |use futures_core::Stream;
    6|       |use futures_util::StreamExt;
    7|       |use libobs::{LIBOBS_API_MAJOR_VER, LIBOBS_API_MINOR_VER};
    8|       |use semver::Version;
    9|       |use sha2::{Digest, Sha256};
   10|       |use tokio::{fs::File, io::AsyncWriteExt};
   11|       |use uuid::Uuid;
   12|       |
   13|       |use super::{LIBRARY_OBS_VERSION, github_types};
   14|       |
   15|       |pub enum DownloadStatus {
   16|       |    Error(anyhow::Error),
   17|       |    Progress(f32, String),
   18|       |    Done(PathBuf),
   19|       |}
   20|       |
   21|      0|pub(crate) async fn download_obs(repo: &str) -> anyhow::Result<impl Stream<Item = DownloadStatus>> {
   22|       |    // Fetch latest OBS release
   23|      0|    let client = reqwest::ClientBuilder::new()
   24|      0|        .user_agent("libobs-rs")
   25|      0|        .build()?;
   26|       |
   27|      0|    let releases_url = format!("https://api.github.com/repos/{}/releases", repo);
   28|      0|    let releases: github_types::Root = client.get(&releases_url).send().await?.json().await?;
   29|       |
   30|      0|    let mut possible_versions = vec![];
   31|      0|    for release in releases {
   32|      0|        let tag = release.tag_name.replace("obs-build-", "");
   33|      0|        let version = Version::parse(&tag).context("Parsing version")?;
   34|       |
   35|       |        // The minor and major version must be the same, patches shouldn't have braking changes
   36|      0|        if version.major == LIBOBS_API_MAJOR_VER as u64
   37|      0|            && version.minor == LIBOBS_API_MINOR_VER as u64
   38|      0|        {
   39|      0|            possible_versions.push(release);
   40|      0|        }
   41|       |    }
   42|       |
   43|      0|    let latest_version = possible_versions
   44|      0|        .iter()
   45|      0|        .max_by_key(|r| &r.published_at)
   46|      0|        .context(format!(
   47|      0|            "Finding a matching obs version for {}",
   48|      0|            *LIBRARY_OBS_VERSION
   49|      0|        ))?;
   50|       |
   51|      0|    let archive_url = latest_version
   52|      0|        .assets
   53|      0|        .iter()
   54|      0|        .find(|a| a.name.ends_with(".7z"))
   55|      0|        .context("Finding 7z asset")?
   56|       |        .browser_download_url
   57|      0|        .clone();
   58|       |
   59|      0|    let hash_url = latest_version
   60|      0|        .assets
   61|      0|        .iter()
   62|      0|        .find(|a| a.name.ends_with(".sha256"))
   63|      0|        .context("Finding sha256 asset")?
   64|       |        .browser_download_url
   65|      0|        .clone();
   66|       |
   67|      0|    let res = client.get(archive_url).send().await?;
   68|      0|    let length = res.content_length().unwrap_or(0);
   69|       |
   70|      0|    let mut bytes_stream = res.bytes_stream();
   71|       |
   72|      0|    let path = PathBuf::new()
   73|      0|        .join(temp_dir())
   74|      0|        .join(format!("{}.7z", Uuid::new_v4()));
   75|      0|    let mut tmp_file = File::create_new(&path)
   76|      0|        .await
   77|      0|        .context("Creating temporary file")?;
   78|       |
   79|      0|    let mut curr_len = 0;
   80|      0|    let mut hasher = Sha256::new();
   81|      0|    Ok(stream! {
   82|      0|        yield DownloadStatus::Progress(0.0, "Downloading OBS".to_string());
   83|      0|        while let Some(chunk) = bytes_stream.next().await {
   84|      0|            let chunk = chunk.context("Retrieving data from stream");
   85|      0|            if let Err(e) = chunk {
   86|      0|                yield DownloadStatus::Error(e);
   87|      0|                return;
   88|      0|            }
   89|      0|
   90|      0|            let chunk = chunk.unwrap();
   91|      0|            hasher.update(&chunk);
   92|      0|            let r = tmp_file.write_all(&chunk).await.context("Writing to temporary file");
   93|      0|            if let Err(e) = r {
   94|      0|                yield DownloadStatus::Error(e);
   95|      0|                return;
   96|      0|            }
   97|      0|
   98|      0|            curr_len = std::cmp::min(curr_len + chunk.len() as u64, length);
   99|      0|            yield DownloadStatus::Progress(curr_len as  f32 / length as f32, "Downloading OBS".to_string());
  100|      0|        }
  101|      0|
  102|      0|        // Getting remote hash
  103|      0|        let remote_hash = client.get(hash_url).send().await.context("Fetching hash");
  104|      0|        if let Err(e) = remote_hash {
  105|      0|            yield DownloadStatus::Error(e);
  106|      0|            return;
  107|      0|        }
  108|      0|
  109|      0|        let remote_hash = remote_hash.unwrap().text().await.context("Reading hash");
  110|      0|        if let Err(e) = remote_hash {
  111|      0|            yield DownloadStatus::Error(e);
  112|      0|            return;
  113|      0|        }
  114|      0|
  115|      0|        let remote_hash = remote_hash.unwrap();
  116|      0|        let remote_hash = hex::decode(remote_hash.trim()).context("Decoding hash");
  117|      0|        if let Err(e) = remote_hash {
  118|      0|            yield DownloadStatus::Error(e);
  119|      0|            return;
  120|      0|        }
  121|      0|
  122|      0|        let remote_hash = remote_hash.unwrap();
  123|      0|
  124|      0|        // Calculating local hash
  125|      0|        let local_hash = hasher.finalize();
  126|      0|        if local_hash.as_slice() != remote_hash {
  127|      0|            yield DownloadStatus::Error(anyhow::anyhow!("Hash mismatch"));
  128|      0|            return;
  129|      0|        }
  130|      0|
  131|      0|        log::info!("Hashes match");
  132|      0|        yield DownloadStatus::Done(path);
  133|      0|    })
  134|      0|}

E:\Rust\libobs-rs\libobs-bootstrapper\src\error.rs:
    1|       |#[derive(Clone, Debug, PartialEq, Eq)]
    2|       |pub enum ObsBootstrapError {
    3|       |    GeneralError(String),
    4|       |    DownloadError(String),
    5|       |    ExtractError(String),
    6|       |}
    7|       |
    8|       |impl std::fmt::Display for ObsBootstrapError {
    9|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   10|      0|        match self {
   11|      0|            ObsBootstrapError::GeneralError(e) => write!(f, "Bootstrapper error: {:?}", e),
   12|      0|            ObsBootstrapError::DownloadError(e) => {
   13|      0|                write!(f, "Bootstrapper download error: {:?}", e)
   14|       |            }
   15|      0|            ObsBootstrapError::ExtractError(e) => write!(f, "Bootstrapper extract error: {:?}", e),
   16|       |        }
   17|      0|    }
   18|       |}
   19|       |impl std::error::Error for ObsBootstrapError {}

E:\Rust\libobs-rs\libobs-bootstrapper\src\extract.rs:
    1|       |use std::{
    2|       |    env::current_exe,
    3|       |    path::{Path, PathBuf},
    4|       |};
    5|       |
    6|       |use async_stream::stream;
    7|       |use futures_core::Stream;
    8|       |use futures_util::{StreamExt, pin_mut};
    9|       |use sevenz_rust::{Password, SevenZReader, default_entry_extract_fn};
   10|       |use tokio::task;
   11|       |pub enum ExtractStatus {
   12|       |    Error(anyhow::Error),
   13|       |    Progress(f32, String),
   14|       |}
   15|       |
   16|      0|pub(crate) async fn extract_obs(
   17|      0|    archive_file: &Path,
   18|      0|) -> anyhow::Result<impl Stream<Item = ExtractStatus>> {
   19|      0|    log::info!("Extracting OBS at {}", archive_file.display());
   20|       |
   21|      0|    let path = PathBuf::from(archive_file);
   22|       |
   23|      0|    let destination = current_exe()?;
   24|      0|    let destination = destination
   25|      0|        .parent()
   26|      0|        .ok_or_else(|| anyhow::anyhow!("Should be able to get parent of exe"))?
   27|      0|        .join("obs_new");
   28|       |
   29|       |    //TODO delete old obs dlls and plugins
   30|      0|    let dest = destination.clone();
   31|      0|    let stream = stream! {
   32|       |        yield Ok((0.0, "Reading file...".to_string()));
   33|       |        let mut sz = SevenZReader::open(&path, Password::empty())?;
   34|       |        let (tx, mut rx) = tokio::sync::mpsc::channel(5);
   35|       |
   36|       |        let total = sz.archive().files.len() as f32;
   37|       |        if !dest.exists() {
   38|       |            std::fs::create_dir_all(&dest)?;
   39|       |        }
   40|       |
   41|       |        let mut curr = 0;
   42|      0|        let mut r = task::spawn_blocking(move || {
   43|      0|            sz.for_each_entries(|entry, reader| {
   44|      0|                curr += 1;
   45|      0|                tx.blocking_send((curr as f32 / total, format!("Extracting {}", entry.name()))).unwrap();
   46|       |
   47|      0|                let dest_path = dest.join(entry.name());
   48|       |
   49|      0|                default_entry_extract_fn(entry, reader, &dest_path)
   50|      0|            })?;
   51|       |
   52|      0|            Result::<_, anyhow::Error>::Ok((1.0, "Extraction done".to_string()))
   53|      0|        });
   54|       |
   55|       |        loop {
   56|       |            tokio::select! {
   57|       |                m = rx.recv() => {
   58|       |                    match m {
   59|       |                        Some(e) => yield Ok(e),
   60|       |                        None => break
   61|       |                    }
   62|       |                },
   63|       |                res = &mut r => {
   64|       |                    match res {
   65|       |                        Ok(e) => yield e,
   66|       |                        Err(e) => {
   67|       |                            yield Err(e.into());
   68|       |                        }
   69|       |                    }
   70|       |
   71|       |                    break;
   72|       |                }
   73|       |            };
   74|       |        }
   75|       |
   76|       |        yield Ok((1.0, "Extraction done".to_string()));
   77|       |    };
   78|       |
   79|      0|    Ok(stream! {
   80|      0|            pin_mut!(stream);
   81|      0|            while let Some(status) = stream.next().await {
   82|      0|                match status {
   83|      0|                    Ok(e) => yield ExtractStatus::Progress(e.0, e.1),
   84|      0|                    Err(err) => {
   85|      0|                        log::error!("Error extracting OBS: {:?}", err);
   86|      0|                        yield ExtractStatus::Error(err);
   87|      0|                        return;
   88|      0|                    }
   89|      0|                }
   90|      0|            }
   91|      0|
   92|      0|    })
   93|      0|}

E:\Rust\libobs-rs\libobs-bootstrapper\src\lib.rs:
    1|       |use std::{env, path::PathBuf, process};
    2|       |
    3|       |use anyhow::Context;
    4|       |use async_stream::stream;
    5|       |use download::DownloadStatus;
    6|       |use extract::ExtractStatus;
    7|       |use futures_core::Stream;
    8|       |use futures_util::{StreamExt, pin_mut};
    9|       |use lazy_static::lazy_static;
   10|       |use libobs::{LIBOBS_API_MAJOR_VER, LIBOBS_API_MINOR_VER, LIBOBS_API_PATCH_VER};
   11|       |use tokio::{fs::File, io::AsyncWriteExt, process::Command};
   12|       |
   13|       |mod download;
   14|       |mod error;
   15|       |mod extract;
   16|       |mod github_types;
   17|       |mod options;
   18|       |pub mod status_handler;
   19|       |mod version;
   20|       |pub use error::ObsBootstrapError;
   21|       |
   22|       |pub use options::ObsBootstrapperOptions;
   23|       |
   24|       |use crate::status_handler::{ObsBootstrapConsoleHandler, ObsBootstrapStatusHandler};
   25|       |
   26|       |pub enum BootstrapStatus {
   27|       |    /// Downloading status (first is progress from 0.0 to 1.0 and second is message)
   28|       |    Downloading(f32, String),
   29|       |
   30|       |    /// Extracting status (first is progress from 0.0 to 1.0 and second is message)
   31|       |    Extracting(f32, String),
   32|       |    Error(anyhow::Error),
   33|       |    /// The application must be restarted to use the new version of OBS.
   34|       |    /// This is because the obs.dll file is in use by the application and can not be replaced while running.
   35|       |    /// Therefore the "updater" is spawned to watch for the application to exit and rename the "obs_new.dll" file to "obs.dll".
   36|       |    /// The updater will start the application again with the same arguments as the original application.
   37|       |    RestartRequired,
   38|       |}
   39|       |
   40|       |/// A struct for bootstrapping OBS Studio.
   41|       |///
   42|       |/// This struct provides functionality to download, extract, and set up OBS Studio
   43|       |/// for use with libobs-rs. It also handles updates to OBS when necessary.
   44|       |///
   45|       |/// If you want to use this bootstrapper to also install required OBS binaries at runtime,
   46|       |/// do the following:
   47|       |/// - Add a `obs.dll` file to your executable directory. This file will be replaced by the obs installer.
   48|       |///   Recommended to use is the a dll dummy (found [here](https://github.com/sshcrack/libobs-builds/releases), make sure you use the correct OBS version)
   49|       |///   and rename it to `obs.dll`.
   50|       |/// - Call `ObsBootstrapper::bootstrap()` at the start of your application. Options must be configured. For more documentation look at the [tauri example app](https://github.com/joshprk/libobs-rs/tree/main/examples/tauri-app). This will download the latest version of OBS and extract it in the executable directory.
   51|       |/// - If BootstrapStatus::RestartRequired is returned, call `ObsBootstrapper::spawn_updater()` to spawn the updater process.
   52|       |/// - Exit the application. The updater process will wait for the application to exit and rename the `obs_new.dll` file to `obs.dll` and restart your application with the same arguments as before.
   53|       |///
   54|       |/// [Example project](https://github.com/joshprk/libobs-rs/tree/main/examples/download-at-runtime)
   55|       |pub struct ObsBootstrapper {}
   56|       |
   57|       |lazy_static! {
   58|       |    pub(crate) static ref LIBRARY_OBS_VERSION: String = format!(
   59|       |        "{}.{}.{}",
   60|       |        LIBOBS_API_MAJOR_VER, LIBOBS_API_MINOR_VER, LIBOBS_API_PATCH_VER
   61|       |    );
   62|       |}
   63|       |
   64|       |pub const UPDATER_SCRIPT: &str = include_str!("./updater.ps1");
   65|       |
   66|      0|fn get_obs_dll_path() -> anyhow::Result<PathBuf> {
   67|      0|    let executable = env::current_exe()?;
   68|      0|    let obs_dll = executable
   69|      0|        .parent()
   70|      0|        .ok_or_else(|| anyhow::anyhow!("Failed to get parent directory"))?
   71|      0|        .join("obs.dll");
   72|       |
   73|      0|    Ok(obs_dll)
   74|      0|}
   75|       |
   76|      0|pub(crate) fn bootstrap(
   77|      0|    options: &options::ObsBootstrapperOptions,
   78|      0|) -> anyhow::Result<Option<impl Stream<Item = BootstrapStatus>>> {
   79|      0|    let repo = options.repository.to_string();
   80|       |
   81|      0|    log::trace!("Checking for update...");
   82|      0|    let update = if options.update {
   83|      0|        ObsBootstrapper::is_update_available()?
   84|       |    } else {
   85|      0|        ObsBootstrapper::is_valid_installation()?
   86|       |    };
   87|       |
   88|      0|    if !update {
   89|      0|        log::debug!("No update needed.");
   90|      0|        return Ok(None);
   91|      0|    }
   92|       |
   93|      0|    let options = options.clone();
   94|      0|    Ok(Some(stream! {
   95|      0|        log::debug!("Downloading OBS from {}", repo);
   96|      0|        let download_stream = download::download_obs(&repo).await;
   97|      0|        if let Err(err) = download_stream {
   98|      0|            yield BootstrapStatus::Error(err);
   99|      0|            return;
  100|      0|        }
  101|      0|
  102|      0|        let download_stream = download_stream.unwrap();
  103|      0|        pin_mut!(download_stream);
  104|      0|
  105|      0|        let mut file = None;
  106|      0|        while let Some(item) = download_stream.next().await {
  107|      0|            match item {
  108|      0|                DownloadStatus::Error(err) => {
  109|      0|                    yield BootstrapStatus::Error(err);
  110|      0|                    return;
  111|      0|                }
  112|      0|                DownloadStatus::Progress(progress, message) => {
  113|      0|                    yield BootstrapStatus::Downloading(progress, message);
  114|      0|                }
  115|      0|                DownloadStatus::Done(path) => {
  116|      0|                    file = Some(path)
  117|      0|                }
  118|      0|            }
  119|      0|        }
  120|      0|
  121|      0|        let archive_file = file.ok_or_else(|| anyhow::anyhow!("OBS Archive could not be downloaded."));
  122|      0|        if let Err(err) = archive_file {
  123|      0|            yield BootstrapStatus::Error(err);
  124|      0|            return;
  125|      0|        }
  126|      0|
  127|      0|        log::debug!("Extracting OBS to {:?}", archive_file);
  128|      0|        let archive_file = archive_file.unwrap();
  129|      0|        let extract_stream = extract::extract_obs(&archive_file).await;
  130|      0|        if let Err(err) = extract_stream {
  131|      0|            yield BootstrapStatus::Error(err);
  132|      0|            return;
  133|      0|        }
  134|      0|
  135|      0|        let extract_stream = extract_stream.unwrap();
  136|      0|        pin_mut!(extract_stream);
  137|      0|
  138|      0|        while let Some(item) = extract_stream.next().await {
  139|      0|            match item {
  140|      0|                ExtractStatus::Error(err) => {
  141|      0|                    yield BootstrapStatus::Error(err);
  142|      0|                    return;
  143|      0|                }
  144|      0|                ExtractStatus::Progress(progress, message) => {
  145|      0|                    yield BootstrapStatus::Extracting(progress, message);
  146|      0|                }
  147|      0|            }
  148|      0|        }
  149|      0|
  150|      0|        let r = spawn_updater(options).await;
  151|      0|        if let Err(err) = r {
  152|      0|            yield BootstrapStatus::Error(err);
  153|      0|            return;
  154|      0|        }
  155|      0|
  156|      0|        yield BootstrapStatus::RestartRequired;
  157|      0|    }))
  158|      0|}
  159|       |
  160|      0|pub(crate) async fn spawn_updater(options: options::ObsBootstrapperOptions) -> anyhow::Result<()> {
  161|      0|    let pid = process::id();
  162|      0|    let args = env::args().collect::<Vec<_>>();
  163|       |    // Skip the first argument which is the executable path
  164|      0|    let args = args.into_iter().skip(1).collect::<Vec<_>>();
  165|       |
  166|      0|    let updater_path = env::temp_dir().join("libobs_updater.ps1");
  167|      0|    let mut updater_file = File::create(&updater_path)
  168|      0|        .await
  169|      0|        .context("Creating updater script")?;
  170|       |
  171|      0|    updater_file
  172|      0|        .write_all(UPDATER_SCRIPT.as_bytes())
  173|      0|        .await
  174|      0|        .context("Writing updater script")?;
  175|       |
  176|      0|    let mut command = Command::new("powershell");
  177|      0|    command
  178|      0|        .arg("-ExecutionPolicy")
  179|      0|        .arg("Bypass")
  180|      0|        .arg("-NoProfile")
  181|      0|        .arg("-WindowStyle")
  182|      0|        .arg("Hidden")
  183|      0|        .arg("-File")
  184|      0|        .arg(updater_path)
  185|      0|        .arg("-processPid")
  186|      0|        .arg(pid.to_string())
  187|      0|        .arg("-binary")
  188|      0|        .arg(env::current_exe()?.to_string_lossy().to_string());
  189|       |
  190|      0|    if options.restart_after_update {
  191|      0|        command.arg("-restart");
  192|      0|    }
  193|       |
  194|       |    // Encode arguments as hex string (UTF-8, null-separated)
  195|      0|    if !args.is_empty() {
  196|      0|        let joined = args.join("\0");
  197|      0|        let bytes = joined.as_bytes();
  198|      0|        let hex_str = hex::encode(bytes);
  199|      0|        command.arg("-argumentHex");
  200|      0|        command.arg(hex_str);
  201|      0|    }
  202|       |
  203|      0|    command.spawn().context("Spawning updater process")?;
  204|       |
  205|      0|    Ok(())
  206|      0|}
  207|       |
  208|       |pub enum ObsBootstrapperResult {
  209|       |    /// No action was needed, OBS is already installed and up to date.
  210|       |    None,
  211|       |    /// The application must be restarted to complete the installation or update of OBS.
  212|       |    Restart,
  213|       |}
  214|       |
  215|       |/// A convenience type that exposes high-level helpers to detect, update and
  216|       |/// bootstrap an OBS installation.
  217|       |///
  218|       |/// The bootstrapper coordinates version checks and the streaming bootstrap
  219|       |/// process. It does not itself perform low-level network or extraction work;
  220|       |/// instead it delegates to internal modules (version checking and the
  221|       |/// bootstrap stream) and surfaces a simple API for callers.
  222|       |impl ObsBootstrapper {
  223|       |    /// Returns true if a valid OBS installation (as determined by locating the
  224|       |    /// OBS DLL and querying the installed version) is present on the system.
  225|       |    ///
  226|       |    /// # Returns
  227|       |    ///
  228|       |    /// - `Ok(true)` if an installed OBS version could be detected.
  229|       |    /// - `Ok(false)` if no installed OBS version was found.
  230|       |    ///
  231|       |    /// # Errors
  232|       |    ///
  233|       |    /// Returns an `Err` (anyhow) if there was an error locating the OBS DLL or
  234|       |    /// reading the installed version information.
  235|      0|    pub fn is_valid_installation() -> anyhow::Result<bool> {
  236|      0|        let installed = version::get_installed_version(&get_obs_dll_path()?)?;
  237|      0|        Ok(installed.is_some())
  238|      0|    }
  239|       |
  240|       |    /// Returns true when an update to OBS should be performed.
  241|       |    ///
  242|       |    /// The function first checks whether OBS is installed. If no installation
  243|       |    /// is found it treats that as an available update (returns `Ok(true)`).
  244|       |    /// Otherwise it consults the internal version logic to determine whether
  245|       |    /// the installed version should be updated.
  246|       |    ///
  247|       |    /// # Returns
  248|       |    ///
  249|       |    /// - `Ok(true)` when an update is recommended or when OBS is not installed.
  250|       |    /// - `Ok(false)` when the installed version is up-to-date.
  251|       |    ///
  252|       |    /// # Errors
  253|       |    ///
  254|       |    /// Returns an `Err` (anyhow) if there was an error locating the OBS DLL or
  255|       |    /// determining the currently installed version or update necessity.
  256|      0|    pub fn is_update_available() -> anyhow::Result<bool> {
  257|      0|        let installed = version::get_installed_version(&get_obs_dll_path()?)?;
  258|      0|        if installed.is_none() {
  259|      0|            return Ok(true);
  260|      0|        }
  261|       |
  262|      0|        let installed = installed.unwrap();
  263|       |
  264|      0|        version::should_update(&installed)
  265|      0|    }
  266|       |
  267|       |    /// Bootstraps OBS using the provided options and a default console status
  268|       |    /// handler.
  269|       |    ///
  270|       |    /// This is a convenience wrapper around `bootstrap_with_handler` that
  271|       |    /// supplies an `ObsBootstrapConsoleHandler` as the status consumer.
  272|       |    ///
  273|       |    /// # Returns
  274|       |    ///
  275|       |    /// - `Ok(ObsBootstrapperResult::None)` if no action was necessary.
  276|       |    /// - `Ok(ObsBootstrapperResult::Restart)` if the bootstrap completed and a
  277|       |    ///   restart is required.
  278|       |    ///
  279|       |    /// # Errors
  280|       |    ///
  281|       |    /// Returns `Err(ObsBootstrapError)` for any failure that prevents the
  282|       |    /// bootstrap from completing (download failures, extraction failures,
  283|       |    /// general errors).
  284|      0|    pub async fn bootstrap(
  285|      0|        options: &options::ObsBootstrapperOptions,
  286|      0|    ) -> Result<ObsBootstrapperResult, ObsBootstrapError> {
  287|      0|        ObsBootstrapper::bootstrap_with_handler(options, Box::new(ObsBootstrapConsoleHandler)).await
  288|      0|    }
  289|       |
  290|       |    /// Bootstraps OBS using the provided options and a custom status handler.
  291|       |    ///
  292|       |    /// The handler will receive progress updates as the bootstrap stream emits
  293|       |    /// statuses. The method drives the bootstrap stream to completion and maps
  294|       |    /// stream statuses into handler calls or final results:
  295|       |    ///
  296|       |    /// - `BootstrapStatus::Downloading(progress, message)`  calls
  297|       |    ///   `handler.handle_downloading(progress, message)`. Handler errors are
  298|       |    ///   mapped to `ObsBootstrapError::DownloadError`.
  299|       |    /// - `BootstrapStatus::Extracting(progress, message)`  calls
  300|       |    ///   `handler.handle_extraction(progress, message)`. Handler errors are
  301|       |    ///   mapped to `ObsBootstrapError::ExtractError`.
  302|       |    /// - `BootstrapStatus::Error(err)`  returns `Err(ObsBootstrapError::GeneralError(_))`.
  303|       |    /// - `BootstrapStatus::RestartRequired`  returns `Ok(ObsBootstrapperResult::Restart)`.
  304|       |    ///
  305|       |    /// If the underlying `bootstrap(options)` call returns `None` there is
  306|       |    /// nothing to do and the function returns `Ok(ObsBootstrapperResult::None)`.
  307|       |    ///
  308|       |    /// # Parameters
  309|       |    ///
  310|       |    /// - `options`: configuration that controls download/extraction behavior.
  311|       |    /// - `handler`: user-provided boxed trait object that receives progress
  312|       |    ///   notifications; it is called on each progress update and can fail.
  313|       |    ///
  314|       |    /// # Returns
  315|       |    ///
  316|       |    /// - `Ok(ObsBootstrapperResult::None)` when no work was required or the
  317|       |    ///   stream completed without requiring a restart.
  318|       |    /// - `Ok(ObsBootstrapperResult::Restart)` when the bootstrap succeeded and
  319|       |    ///   a restart is required.
  320|       |    ///
  321|       |    /// # Errors
  322|       |    ///
  323|       |    /// Returns `Err(ObsBootstrapError)` when:
  324|       |    /// - the bootstrap pipeline could not be started,
  325|       |    /// - the handler returns an error while handling a download or extraction
  326|       |    ///   update (mapped respectively to `DownloadError` / `ExtractError`),
  327|       |    /// - or when the bootstrap stream yields a general error.
  328|      0|    pub async fn bootstrap_with_handler(
  329|      0|        options: &options::ObsBootstrapperOptions,
  330|      0|        mut handler: Box<dyn ObsBootstrapStatusHandler>,
  331|      0|    ) -> Result<ObsBootstrapperResult, ObsBootstrapError> {
  332|      0|        let stream =
  333|      0|            bootstrap(options).map_err(|e| ObsBootstrapError::GeneralError(e.to_string()))?;
  334|       |
  335|      0|        if let Some(stream) = stream {
  336|      0|            pin_mut!(stream);
  337|       |
  338|      0|            log::trace!("Waiting for bootstrapper to finish");
  339|      0|            while let Some(item) = stream.next().await {
  340|      0|                match item {
  341|      0|                    BootstrapStatus::Downloading(progress, message) => {
  342|      0|                        handler
  343|      0|                            .handle_downloading(progress, message)
  344|      0|                            .map_err(|e| ObsBootstrapError::DownloadError(e.to_string()))?;
  345|       |                    }
  346|      0|                    BootstrapStatus::Extracting(progress, message) => {
  347|      0|                        handler
  348|      0|                            .handle_extraction(progress, message)
  349|      0|                            .map_err(|e| ObsBootstrapError::ExtractError(e.to_string()))?;
  350|       |                    }
  351|      0|                    BootstrapStatus::Error(err) => {
  352|      0|                        return Err(ObsBootstrapError::GeneralError(err.to_string()));
  353|       |                    }
  354|       |                    BootstrapStatus::RestartRequired => {
  355|      0|                        return Ok(ObsBootstrapperResult::Restart);
  356|       |                    }
  357|       |                }
  358|       |            }
  359|      0|        }
  360|       |
  361|      0|        Ok(ObsBootstrapperResult::None)
  362|      0|    }
  363|       |}

E:\Rust\libobs-rs\libobs-bootstrapper\src\options.rs:
    1|       |pub const GITHUB_REPO: &str = "sshcrack/libobs-builds";
    2|       |
    3|       |#[derive(Debug, Clone)]
    4|       |pub struct ObsBootstrapperOptions {
    5|       |    pub(crate) repository: String,
    6|       |    pub(crate) update: bool,
    7|       |    pub(crate) restart_after_update: bool,
    8|       |}
    9|       |
   10|       |impl ObsBootstrapperOptions {
   11|      0|    pub fn new() -> Self {
   12|      0|        ObsBootstrapperOptions {
   13|      0|            repository: GITHUB_REPO.to_string(),
   14|      0|            update: true,
   15|      0|            restart_after_update: true,
   16|      0|        }
   17|      0|    }
   18|       |
   19|      0|    pub fn set_repository(mut self, repository: &str) -> Self {
   20|      0|        self.repository = repository.to_string();
   21|      0|        self
   22|      0|    }
   23|       |
   24|      0|    pub fn get_repository(&self) -> &str {
   25|      0|        &self.repository
   26|      0|    }
   27|       |
   28|       |    /// `true` if the updater should check for updates and download them if available.
   29|       |    /// `false` if the updater should not check for updates and only install OBS if required.
   30|      0|    pub fn set_update(mut self, update: bool) -> Self {
   31|      0|        self.update = update;
   32|      0|        self
   33|      0|    }
   34|       |
   35|       |    /// Disables the automatic restart of the application after the update is applied.
   36|      0|    pub fn set_no_restart(mut self) -> Self {
   37|      0|        self.restart_after_update = false;
   38|      0|        self
   39|      0|    }
   40|       |}
   41|       |
   42|       |impl Default for ObsBootstrapperOptions {
   43|      0|    fn default() -> Self {
   44|      0|        ObsBootstrapperOptions::new()
   45|      0|    }
   46|       |}

E:\Rust\libobs-rs\libobs-bootstrapper\src\status_handler.rs:
    1|       |use std::fmt::Debug;
    2|       |
    3|       |//NOTE: Maybe do not require to implement Debug here?
    4|       |pub trait ObsBootstrapStatusHandler: Debug + Send + Sync {
    5|       |    fn handle_downloading(&mut self, progress: f32, message: String) -> anyhow::Result<()>;
    6|       |    fn handle_extraction(&mut self, progress: f32, message: String) -> anyhow::Result<()>;
    7|       |}
    8|       |
    9|       |#[derive(Debug)]
   10|       |pub struct ObsBootstrapConsoleHandler;
   11|       |
   12|       |impl Default for ObsBootstrapConsoleHandler {
   13|      0|    fn default() -> Self {
   14|      0|        Self
   15|      0|    }
   16|       |}
   17|       |
   18|       |impl ObsBootstrapStatusHandler for ObsBootstrapConsoleHandler {
   19|      0|    fn handle_downloading(&mut self, progress: f32, message: String) -> anyhow::Result<()> {
   20|      0|        println!("Downloading: {}% - {}", progress * 100.0, message);
   21|      0|        Ok(())
   22|      0|    }
   23|       |
   24|      0|    fn handle_extraction(&mut self, progress: f32, message: String) -> anyhow::Result<()> {
   25|      0|        println!("Extracting: {}% - {}", progress * 100.0, message);
   26|      0|        Ok(())
   27|      0|    }
   28|       |}

E:\Rust\libobs-rs\libobs-bootstrapper\src\version.rs:
    1|       |use std::path::Path;
    2|       |
    3|       |use libloading::Library;
    4|       |use libobs::{LIBOBS_API_MAJOR_VER, LIBOBS_API_MINOR_VER, LIBOBS_API_PATCH_VER};
    5|       |
    6|       |pub type GetVersionFunc = unsafe extern "C" fn() -> *const ::std::os::raw::c_char;
    7|       |
    8|      0|pub fn get_installed_version(obs_dll: &Path) -> anyhow::Result<Option<String>> {
    9|       |    // The obs.dll should always exist
   10|      0|    let dll_exists = obs_dll.exists() && obs_dll.is_file();
   11|      0|    if !dll_exists {
   12|      0|        log::trace!("obs.dll does not exist at {}", obs_dll.display());
   13|      0|        return Ok(None);
   14|      0|    }
   15|       |
   16|      0|    log::trace!("Getting obs.dll version string");
   17|       |    unsafe {
   18|      0|        let lib = Library::new(obs_dll)?;
   19|      0|        let get_version: libloading::Symbol<GetVersionFunc> = lib.get(b"obs_get_version_string")?;
   20|      0|        let version = get_version();
   21|       |
   22|      0|        if version.is_null() {
   23|      0|            lib.close()?;
   24|      0|            log::trace!("obs.dll does not have a version string");
   25|      0|            return Ok(None);
   26|      0|        }
   27|       |
   28|      0|        let version_str = std::ffi::CStr::from_ptr(version).to_str();
   29|      0|        if version_str.is_err() {
   30|      0|            lib.close()?;
   31|      0|            log::trace!(
   32|      0|                "obs.dll version string is not valid UTF-8: {}",
   33|      0|                version_str.err().unwrap()
   34|       |            );
   35|      0|            return Ok(None);
   36|      0|        }
   37|       |
   38|      0|        lib.close()?;
   39|      0|        Ok(Some(version_str.unwrap().to_string()))
   40|       |    }
   41|      0|}
   42|       |
   43|      0|pub fn should_update(version_str: &str) -> anyhow::Result<bool> {
   44|      0|    let version = version_str.split('.').collect::<Vec<_>>();
   45|      0|    if version.len() != 3 {
   46|      0|        anyhow::bail!("Invalid version string: {}", version_str);
   47|      0|    }
   48|      0|    let major = version[0].parse::<u64>();
   49|      0|    let minor = version[1].parse::<u64>();
   50|      0|    let patch = version[2].parse::<u64>();
   51|       |
   52|      0|    if major.is_err() || minor.is_err() || patch.is_err() {
   53|      0|        anyhow::bail!("Invalid version string: {}", version_str);
   54|      0|    }
   55|       |
   56|      0|    let major = major.unwrap();
   57|      0|    let minor = minor.unwrap();
   58|      0|    let patch = patch.unwrap();
   59|       |
   60|      0|    Ok(major != LIBOBS_API_MAJOR_VER as u64
   61|      0|        || minor != LIBOBS_API_MINOR_VER as u64
   62|      0|        || patch < LIBOBS_API_PATCH_VER as u64)
   63|      0|}

E:\Rust\libobs-rs\libobs-source-macro\src\docs.rs:
    1|       |use syn::{Attribute, Expr};
    2|       |
    3|    140|pub fn collect_doc(attrs: &Vec<Attribute>) -> (Vec<String>, Vec<&Attribute>) {
    4|    140|    let mut docs_str = Vec::new();
    5|    140|    let mut docs_attr = Vec::new();
    6|    516|    for attr in attrs {
                      ^376
    7|    376|        let name_val = match &attr.meta {
                          ^236
    8|    236|            syn::Meta::NameValue(n) => n,
    9|    140|            _ => continue,
   10|       |        };
   11|       |
   12|    236|        let is_doc = name_val.path.is_ident("doc");
   13|    236|        if !is_doc {
   14|      0|            continue;
   15|    236|        }
   16|       |
   17|    236|        let lit = match &name_val.value {
   18|    236|            Expr::Lit(l) => match &l.lit {
   19|    236|                syn::Lit::Str(s) => s.value(),
   20|      0|                _ => continue,
   21|       |            },
   22|      0|            _ => continue,
   23|       |        };
   24|       |
   25|    236|        docs_str.push(lit);
   26|    236|        docs_attr.push(attr);
   27|       |    }
   28|       |
   29|    140|    (docs_str, docs_attr)
   30|    140|}

E:\Rust\libobs-rs\libobs-source-macro\src\fields.rs:
    1|       |use proc_macro2::TokenStream;
    2|       |use quote::quote;
    3|       |use syn::{punctuated::Punctuated, token::Comma, Field};
    4|       |
    5|     16|pub fn generate_struct_fields(
    6|     16|    fields: &Punctuated<Field, Comma>,
    7|     16|) -> (Vec<TokenStream>, Vec<TokenStream>) {
    8|     16|    let maybe_obs_properties = fields
    9|     16|        .iter()
   10|    148|        .map(|f| {
                       ^16
   11|    288|            let attr = f.attrs.iter().find(|e| e.path().is_ident("obs_property"));
                              ^148   ^148           ^148
   12|       |
   13|    148|            (f, attr)
   14|    148|        })
   15|     16|        .collect::<Vec<_>>();
   16|       |
   17|     16|    let obs_properties = maybe_obs_properties
   18|     16|        .iter()
   19|    148|        .filter_map(|(f, attr)| if attr.is_some() { Some(f) } else { None })
                       ^16                                        ^140             ^8
   20|     16|        .collect::<Vec<_>>();
   21|       |
   22|     16|    let non_obs_properties = maybe_obs_properties
   23|     16|        .iter()
   24|    148|        .filter_map(|(f, attr)| if let Some(_a) = attr { None } else { Some(f) })
                       ^16                                ^140         ^140          ^8
   25|     16|        .collect::<Vec<_>>();
   26|       |
   27|     16|    let mut struct_fields = Vec::<TokenStream>::new();
   28|     16|    let mut struct_initializers = Vec::<TokenStream>::new();
   29|       |
   30|    156|    for field in obs_properties {
                      ^140
   31|    140|        let name = &field.ident;
   32|    140|        struct_fields.push(quote! {
   33|    140|            /// IGNORE THIS FIELD. This is just so intellisense doesn't get confused and isn't complaining
   34|    140|            #name: u8
   35|    140|        });
   36|    140|
   37|    140|        struct_initializers.push(quote! {
   38|    140|            #name: 0
   39|    140|        });
   40|    140|    }
   41|       |
   42|     24|    for ele in non_obs_properties {
                      ^8
   43|      8|        let name = &ele.ident;
   44|      8|        #[allow(dead_code)]
   45|      8|        let field_type = &ele.ty;
   46|      8|        struct_fields.push(quote! {
   47|      8|            #name: #field_type
   48|      8|        });
   49|      8|
   50|      8|        struct_initializers.push(quote! {
   51|      8|            #name: Default::default()
   52|      8|        });
   53|      8|    }
   54|       |
   55|     16|    (struct_fields, struct_initializers)
   56|     16|}

E:\Rust\libobs-rs\libobs-source-macro\src\lib.rs:
    1|       |use obs_properties::obs_properties_to_functions;
    2|       |use parse::UpdaterInput;
    3|       |use proc_macro::TokenStream;
    4|       |use quote::{format_ident, quote};
    5|       |use syn::{parse_macro_input, Data, DeriveInput, Fields, ItemImpl, LitStr, Type, TypePath};
    6|       |
    7|       |mod docs;
    8|       |mod fields;
    9|       |mod obs_properties;
   10|       |mod parse;
   11|       |
   12|       |#[proc_macro_attribute]
   13|       |//TODO more documents here
   14|       |/// This macro is used to generate an updater pattern for an obs object (for example a source).
   15|       |/// For more examples look at libobs-sources
   16|      6|pub fn obs_object_updater(attr: TokenStream, item: TokenStream) -> TokenStream {
   17|      6|    let u_input = parse_macro_input!(attr as UpdaterInput);
   18|      6|    let id_value = u_input.name.value();
   19|      6|    let updatable_type = u_input.updatable_type;
   20|       |
   21|      6|    let input = parse_macro_input!(item as DeriveInput);
   22|       |
   23|      6|    let i_ident = input.ident;
   24|      6|    let updater_name = format_ident!("{}", i_ident);
   25|       |
   26|      6|    let visibility = input.vis;
   27|      6|    let attributes = input.attrs;
   28|       |
   29|      6|    let fields = match input.data {
   30|      6|        Data::Struct(data) => match data.fields {
   31|      6|            Fields::Named(fields) => fields.named,
   32|      0|            _ => panic!("Only named fields are supported"),
   33|       |        },
   34|      0|        _ => panic!("Only structs are supported"),
   35|       |    };
   36|       |
   37|      6|    let (struct_fields, struct_initializers) = fields::generate_struct_fields(&fields);
   38|      6|    let functions = obs_properties_to_functions(
   39|      6|        &fields,
   40|      6|        quote! {
   41|       |            use libobs_wrapper::data::ObsObjectUpdater;
   42|       |            self.get_settings_updater()
   43|       |        },
   44|       |    );
   45|       |
   46|      6|    let updatable_type2 = updatable_type.clone();
   47|      6|    let expanded = quote! {
   48|       |        #(#attributes)*
   49|       |        #[allow(dead_code)]
   50|       |        #visibility struct #updater_name<'a> {
   51|       |            #(#struct_fields,)*
   52|       |            settings: libobs_wrapper::data::ObsData,
   53|       |            settings_updater: libobs_wrapper::data::ObsDataUpdater,
   54|       |            updatable: &'a mut #updatable_type2
   55|       |        }
   56|       |
   57|       |        impl <'a> libobs_wrapper::data::ObsObjectUpdater<'a> for #updater_name<'a> {
   58|       |            type ToUpdate = #updatable_type;
   59|       |
   60|       |            fn create_update(runtime: libobs_wrapper::runtime::ObsRuntime, updatable: &'a mut Self::ToUpdate) -> Result<Self, libobs_wrapper::utils::ObsError> {
   61|       |                let mut settings = libobs_wrapper::data::ObsData::new(runtime.clone())?;
   62|       |
   63|       |                Ok(Self {
   64|       |                    #(#struct_initializers,)*
   65|       |                    settings_updater: settings.bulk_update(),
   66|       |                    settings,
   67|       |                    updatable,
   68|       |                })
   69|       |            }
   70|       |
   71|       |            fn get_settings(&self) -> &libobs_wrapper::data::ObsData {
   72|       |                &self.settings
   73|       |            }
   74|       |
   75|       |            fn get_settings_updater(&mut self) -> &mut libobs_wrapper::data::ObsDataUpdater {
   76|       |                &mut self.settings_updater
   77|       |            }
   78|       |
   79|       |            fn get_id() -> libobs_wrapper::utils::ObsString {
   80|       |                #id_value.into()
   81|       |            }
   82|       |
   83|       |            fn update(self) -> Result<(), libobs_wrapper::utils::ObsError> {
   84|       |                use libobs_wrapper::utils::traits::ObsUpdatable;
   85|       |                let #updater_name {
   86|       |                    settings_updater,
   87|       |                    updatable,
   88|       |                    settings,
   89|       |                    ..
   90|       |                } = self;
   91|       |
   92|       |                log::trace!("Updating settings for {:?}", Self::get_id());
   93|       |                settings_updater.update()?;
   94|       |
   95|       |                log::trace!("Updating raw settings for {:?}", Self::get_id());
   96|       |                let e = updatable.update_raw(settings);
   97|       |                log::trace!("Update done for {:?}", Self::get_id());
   98|       |
   99|       |                e
  100|       |            }
  101|       |        }
  102|       |
  103|       |        impl <'a> #updater_name <'a> {
  104|       |            #(#functions)*
  105|       |        }
  106|       |    };
  107|       |
  108|      6|    TokenStream::from(expanded)
  109|      6|}
  110|       |
  111|       |#[proc_macro_attribute]
  112|       |/// This macro is used to generate a builder pattern for an obs source. <br>
  113|       |/// The attribute should be the id of the source.<br>
  114|       |/// The struct should have named fields, each field should have an attribute `#[obs_property(type_t="your_type")]`. <br>
  115|       |/// `type_t` can be `enum`, `enum_string`, `string`, `bool` or `int`. <br>
  116|       |/// - `enum`: the field should be an enum with `num_derive::{FromPrimitive, ToPrimitive}`.
  117|       |/// - `enum_string`: the field should be an enum which implements `StringEnum`.
  118|       |/// - `string`: the field should be a string.
  119|       |/// - `bool`: the field should be a bool.
  120|       |/// - `type_t`: `int`, the field should be an i64.
  121|       |///   The attribute can also have a `settings_key` which is the key used in the settings, if this attribute is not given, the macro defaults to the field name.
  122|       |///
  123|       |/// Documentation is inherited from the field to the setter function.
  124|       |///
  125|       |/// Example:
  126|       |///
  127|       |/// ```
  128|       |/// use libobs_wrapper::data::StringEnum;
  129|       |/// use libobs_source_macro::obs_object_builder;
  130|       |/// use num_derive::{FromPrimitive, ToPrimitive};
  131|       |///
  132|       |/// #[repr(i32)]
  133|       |/// #[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
  134|       |/// pub enum ObsWindowCaptureMethod {
  135|       |///        MethodAuto = libobs::window_capture_method_METHOD_AUTO,
  136|       |///        MethodBitBlt = libobs::window_capture_method_METHOD_BITBLT,
  137|       |///        MethodWgc = libobs::window_capture_method_METHOD_WGC,
  138|       |/// }
  139|       |///
  140|       |/// #[derive(Clone, Copy, Debug, PartialEq, Eq)]
  141|       |/// pub enum ObsGameCaptureRgbaSpace {
  142|       |///     SRgb,
  143|       |///     RGBA2100pq
  144|       |/// }
  145|       |///
  146|       |/// impl StringEnum for ObsGameCaptureRgbaSpace {
  147|       |///     fn to_str(&self) -> &str {
  148|       |///         match self {
  149|       |///             ObsGameCaptureRgbaSpace::SRgb => "sRGB",
  150|       |///             ObsGameCaptureRgbaSpace::RGBA2100pq => "Rec. 2100 (PQ)"
  151|       |///         }
  152|       |///     }
  153|       |/// }
  154|       |///
  155|       |/// /// Provides a easy to use builder for the window capture source.
  156|       |/// #[derive(Debug)]
  157|       |/// #[obs_object_builder("window_capture")]
  158|       |/// pub struct WindowCaptureSourceBuilder {
  159|       |/// #[obs_property(type_t="enum")]
  160|       |///     /// Sets the capture method for the window capture
  161|       |///     capture_method: ObsWindowCaptureMethod,
  162|       |///
  163|       |///     /// Sets the window to capture.
  164|       |///     #[obs_property(type_t = "string", settings_key = "window")]
  165|       |///     window_raw: String,
  166|       |///
  167|       |///     #[obs_property(type_t = "bool")]
  168|       |///     /// Sets whether the cursor should be captured
  169|       |///     cursor: bool,
  170|       |///
  171|       |///     /// Sets the capture mode for the game capture source. Look at doc for `ObsGameCaptureMode`
  172|       |///     #[obs_property(type_t = "enum_string")]
  173|       |///     capture_mode: ObsGameCaptureMode,
  174|       |/// }
  175|       |/// ```
  176|     10|pub fn obs_object_builder(attr: TokenStream, item: TokenStream) -> TokenStream {
  177|     10|    let id = parse_macro_input!(attr as LitStr);
  178|       |
  179|     10|    let input = parse_macro_input!(item as DeriveInput);
  180|       |
  181|     10|    let i_ident = input.ident;
  182|     10|    let builder_name = format_ident!("{}", i_ident);
  183|       |
  184|     10|    let generics = input.generics;
  185|     10|    let visibility = input.vis;
  186|     10|    let attributes = input.attrs;
  187|       |
  188|     10|    let fields = match input.data {
  189|     10|        Data::Struct(data) => match data.fields {
  190|     10|            Fields::Named(fields) => fields.named,
  191|      0|            _ => panic!("Only named fields are supported"),
  192|       |        },
  193|      0|        _ => panic!("Only structs are supported"),
  194|       |    };
  195|       |
  196|     10|    let id_value = id.value();
  197|     10|    let (struct_fields, struct_initializers) = fields::generate_struct_fields(&fields);
  198|       |
  199|     10|    let functions = obs_properties_to_functions(
  200|     10|        &fields,
  201|     10|        quote! {
  202|       |            use libobs_wrapper::data::ObsObjectBuilder;
  203|       |            self.get_settings_updater()
  204|       |        },
  205|       |    );
  206|       |
  207|     10|    let expanded = quote! {
  208|       |        #(#attributes)*
  209|       |        #[allow(dead_code)]
  210|       |        #visibility struct #builder_name #generics {
  211|       |            #(#struct_fields,)*
  212|       |            settings: libobs_wrapper::data::ObsData,
  213|       |            settings_updater: libobs_wrapper::data::ObsDataUpdater,
  214|       |            hotkeys: libobs_wrapper::data::ObsData,
  215|       |            hotkeys_updater: libobs_wrapper::data::ObsDataUpdater,
  216|       |            name: libobs_wrapper::utils::ObsString,
  217|       |            runtime: libobs_wrapper::runtime::ObsRuntime
  218|       |        }
  219|       |
  220|       |        impl libobs_wrapper::data::ObsObjectBuilder for #builder_name {
  221|       |            fn new<T: Into<libobs_wrapper::utils::ObsString> + Send + Sync>(name: T, runtime: libobs_wrapper::runtime::ObsRuntime) -> Result<Self, libobs_wrapper::utils::ObsError> {
  222|       |                let mut hotkeys = libobs_wrapper::data::ObsData::new(runtime.clone())?;
  223|       |                let mut settings = libobs_wrapper::data::ObsData::new(runtime.clone())?;
  224|       |
  225|       |                Ok(Self {
  226|       |                    #(#struct_initializers,)*
  227|       |                    name: name.into(),
  228|       |                    settings_updater: settings.bulk_update(),
  229|       |                    settings,
  230|       |                    hotkeys_updater: hotkeys.bulk_update(),
  231|       |                    hotkeys,
  232|       |                    runtime
  233|       |                })
  234|       |            }
  235|       |
  236|       |            fn get_settings(&self) -> &libobs_wrapper::data::ObsData {
  237|       |                &self.settings
  238|       |            }
  239|       |
  240|       |            fn get_settings_updater(&mut self) -> &mut libobs_wrapper::data::ObsDataUpdater {
  241|       |                &mut self.settings_updater
  242|       |            }
  243|       |
  244|       |            fn get_hotkeys(&self) -> &libobs_wrapper::data::ObsData {
  245|       |                &self.hotkeys
  246|       |            }
  247|       |
  248|       |            fn get_hotkeys_updater(&mut self) -> &mut libobs_wrapper::data::ObsDataUpdater {
  249|       |                &mut self.hotkeys_updater
  250|       |            }
  251|       |
  252|       |            fn get_name(&self) -> libobs_wrapper::utils::ObsString {
  253|       |                self.name.clone()
  254|       |            }
  255|       |
  256|       |            fn get_id() -> libobs_wrapper::utils::ObsString {
  257|       |                #id_value.into()
  258|       |            }
  259|       |
  260|       |            fn build(self) -> Result<libobs_wrapper::utils::ObjectInfo, libobs_wrapper::utils::ObsError> {
  261|       |                let name = self.get_name();
  262|       |                let #builder_name {
  263|       |                    settings_updater,
  264|       |                    hotkeys_updater,
  265|       |                    settings,
  266|       |                    hotkeys,
  267|       |                    ..
  268|       |                } = self;
  269|       |
  270|       |                settings_updater.update()?;
  271|       |                hotkeys_updater.update()?;
  272|       |
  273|       |                Ok(libobs_wrapper::utils::ObjectInfo::new(
  274|       |                    Self::get_id(),
  275|       |                    name,
  276|       |                    Some(settings),
  277|       |                    Some(hotkeys),
  278|       |                ))
  279|       |            }
  280|       |        }
  281|       |
  282|       |        impl #builder_name {
  283|       |            #(#functions)*
  284|       |        }
  285|       |    };
  286|       |
  287|     10|    TokenStream::from(expanded)
  288|     10|}
  289|       |
  290|       |#[proc_macro_attribute]
  291|      4|pub fn obs_object_impl(_attr: TokenStream, item: TokenStream) -> TokenStream {
  292|      4|    let input = parse_macro_input!(item as ItemImpl);
  293|       |
  294|       |    // Extract the function from the implementation
  295|      4|    let impl_item = input.items;
  296|      4|    let impl_item2 = impl_item.clone();
  297|       |
  298|       |    // Create the builder and updater struct names
  299|      4|    let base_name = if let Type::Path(TypePath { path, .. }) = &*input.self_ty {
  300|      4|        path.segments.last().unwrap().ident.to_string()
  301|       |    } else {
  302|      0|        panic!("Only path types are supported in self_ty")
  303|       |    };
  304|       |
  305|      4|    let builder_name = format_ident!("{}Builder", base_name);
  306|      4|    let updater_name = format_ident!("{}Updater", base_name);
  307|       |
  308|      4|    let expanded = quote! {
  309|       |        // Builder implementation
  310|       |        impl #builder_name {
  311|       |            #(#impl_item)*
  312|       |        }
  313|       |
  314|       |        // Updater implementation with lifetime
  315|       |        impl<'a> #updater_name<'a> {
  316|       |            #(#impl_item2)*
  317|       |        }
  318|       |    };
  319|       |
  320|      4|    TokenStream::from(expanded)
  321|      4|}

E:\Rust\libobs-rs\libobs-source-macro\src\obs_properties.rs:
    1|       |use proc_macro2::{Span, TokenStream};
    2|       |use quote::quote;
    3|       |use syn::{punctuated::Punctuated, token::Comma, Field, LitStr, MetaNameValue, Token};
    4|       |
    5|       |use crate::docs::collect_doc;
    6|       |
    7|     16|pub fn obs_properties_to_functions(
    8|     16|    fields: &Punctuated<Field, Comma>,
    9|     16|    settings_getter: TokenStream,
   10|     16|) -> Vec<TokenStream> {
   11|     16|    let obs_properties = fields
   12|     16|        .iter()
   13|    148|        .filter_map(|f| {
                       ^16
   14|    288|            let attr = f.attrs.iter().find(|e| e.path().is_ident("obs_property"));
                              ^148   ^148           ^148
   15|       |
   16|    148|            attr.map(|a| (f, a))
                                        ^140^140
   17|    148|        })
   18|     16|        .collect::<Vec<_>>();
   19|       |
   20|     16|    let mut functions = Vec::new();
   21|    156|    for (field, attr) in obs_properties {
                       ^140   ^140
   22|    140|        let field_type = &field.ty;
   23|    140|        let field_name = field.ident.as_ref().unwrap();
   24|       |
   25|    140|        let name_values: Punctuated<MetaNameValue, Token![,]> = attr
   26|    140|            .parse_args_with(Punctuated::parse_terminated)
   27|    140|            .unwrap_or_else(|_| {
                                              ^0
   28|      0|                panic!(
   29|      0|                    "Field {} has invalid obs_property, should be name value",
   30|       |                    field_name
   31|       |                )
   32|       |            });
   33|       |
   34|    140|        let type_t = &name_values
   35|    140|            .iter()
   36|    140|            .find(|e| *e.path.get_ident().unwrap() == "type_t")
   37|    140|            .expect("type_t is required for obs_property")
   38|       |            .value;
   39|       |
   40|    140|        let type_t = match type_t {
   41|    140|            syn::Expr::Lit(e) => match &e.lit {
   42|    140|                syn::Lit::Str(s) => s.value(),
   43|      0|                _ => panic!("type_t must be a string"),
   44|       |            },
   45|      0|            _ => panic!("type_t must be a string"),
   46|       |        };
   47|       |
   48|       |        #[allow(unused_variables)]
   49|    140|        let mut obs_settings_name = field_name.to_string();
   50|    140|        let pot_name = &name_values
   51|    140|            .iter()
   52|    152|            .find(|e| *e.path.get_ident().unwrap() == "settings_key");
                           ^140
   53|       |
   54|    140|        if let Some(n) = pot_name {
                                  ^12
   55|     12|            obs_settings_name = match &n.value {
   56|     12|                syn::Expr::Lit(e) => match &e.lit {
   57|     12|                    syn::Lit::Str(s) => s.value(),
   58|      0|                    _ => panic!("setings_key must be a string"),
   59|       |                },
   60|      0|                _ => panic!("settings_key must be a string"),
   61|       |            };
   62|    128|        }
   63|       |
   64|    140|        let (_docs_str, docs_attr) = collect_doc(&field.attrs);
   65|       |
   66|    140|        let obs_settings_key = LitStr::new(&obs_settings_name, Span::call_site());
   67|    140|        let set_field = quote::format_ident!("set_{}", field_name);
   68|    140|        let type_t_str = type_t.as_str();
   69|    140|        let to_add = match type_t_str {
   70|    140|            "enum" => {
   71|     12|                quote! {
   72|       |                    #(#docs_attr)*
   73|       |                    pub fn #set_field(mut self, #field_name: #field_type) -> Self {
   74|       |                        use num_traits::ToPrimitive;
   75|       |                        let val = #field_name.to_i32().unwrap();
   76|       |
   77|       |                        #settings_getter
   78|       |                            .set_int_ref(#obs_settings_key, val as i64);
   79|       |
   80|       |                        self
   81|       |                    }
   82|       |                }
   83|       |            }
   84|    128|            "enum_string" => {
   85|      8|                quote! {
   86|       |                    #(#docs_attr)*
   87|       |                    pub fn #set_field(mut self, #field_name: #field_type) -> Self {
   88|       |                        use libobs_wrapper::data::StringEnum;
   89|       |
   90|       |                        #settings_getter
   91|       |                            .set_string_ref(#obs_settings_key, #field_name.to_str());
   92|       |
   93|       |                        self
   94|       |                    }
   95|       |                }
   96|       |            }
   97|    120|            "string" => {
   98|     32|                quote! {
   99|       |                    #(#docs_attr)*
  100|       |                    pub fn #set_field<T: Into<libobs_wrapper::utils::ObsString> + Sync + Send>(mut self, #field_name: T) -> Self {
  101|       |                        #settings_getter
  102|       |                            .set_string_ref(#obs_settings_key, #field_name);
  103|       |                        self
  104|       |                    }
  105|       |                }
  106|       |            }
  107|     88|            "bool" => {
  108|     72|                quote! {
  109|       |                    #(#docs_attr)*
  110|       |                    pub fn #set_field(mut self, #field_name: bool) -> Self {
  111|       |                        #settings_getter
  112|       |                            .set_bool_ref(#obs_settings_key, #field_name);
  113|       |                        self
  114|       |                    }
  115|       |                }
  116|       |            }
  117|     16|            "int" => {
  118|     16|                quote! {
  119|       |                    #(#docs_attr)*
  120|       |                    pub fn #set_field(mut self, #field_name: i64) -> Self {
  121|       |                        #settings_getter
  122|       |                            .set_int_ref(#obs_settings_key, #field_name);
  123|       |                        self
  124|       |                    }
  125|       |                }
  126|       |            }
  127|      0|            _ => panic!(
  128|      0|                "Unsupported type_t {}. Should either be `enum`, `string`, `bool` or `int`",
  129|       |                type_t
  130|       |            ),
  131|       |        };
  132|       |
  133|    140|        functions.push(to_add);
  134|       |    }
  135|       |
  136|     16|    functions
  137|     16|}

E:\Rust\libobs-rs\libobs-source-macro\src\parse.rs:
    1|       |use syn::{
    2|       |    parse::{Parse, ParseStream},
    3|       |    Ident, LitStr, Result, Token,
    4|       |};
    5|       |
    6|       |pub struct UpdaterInput {
    7|       |    pub name: LitStr,
    8|       |    pub updatable_type: Ident,
    9|       |}
   10|       |
   11|       |impl Parse for UpdaterInput {
   12|      6|    fn parse(input: ParseStream) -> Result<Self> {
   13|      6|        let n = input.parse()?;
                                           ^0
   14|      6|        input.parse::<Token![,]>()?;
                                                ^0
   15|       |        Ok(UpdaterInput {
   16|      6|            name: n,
   17|      6|            updatable_type: input.parse()?,
                                                       ^0
   18|       |        })
   19|      6|    }
   20|       |}

E:\Rust\libobs-rs\libobs-sources\src\macro_helper.rs:
    1|       |macro_rules! define_object_manager {
    2|       |    ($(#[$parent_meta:meta])* struct $struct_name:ident($obs_id:literal) for $updatable_name:ident {
    3|       |        $(
    4|       |            $(#[$meta:meta])*
    5|       |            $field:ident: $ty:ty,
    6|       |        )*
    7|       |    }) => {
    8|       |        paste::paste! {
    9|      0|            #[libobs_source_macro::obs_object_builder($obs_id)]
   10|       |            $(#[$parent_meta])*
   11|       |            pub struct [<$struct_name Builder>] {
   12|       |                $(
   13|       |                    $(#[$meta])*
   14|       |                    $field: $ty,
   15|       |                )*
   16|       |            }
   17|       |
   18|      0|            #[libobs_source_macro::obs_object_updater($obs_id, $updatable_name)]
   19|       |            /// Used to update the source this updater was created from. For more details look
   20|       |            /// at docs for the corresponding builder.
   21|       |            pub struct [<$struct_name Updater>] {
   22|       |                $(
   23|       |                    $(#[$meta])*
   24|       |                    $field: $ty,
   25|       |                )*
   26|       |            }
   27|       |        }
   28|       |    };
   29|       |}
   30|       |
   31|       |pub(crate) use define_object_manager;

E:\Rust\libobs-rs\libobs-sources\src\output.rs:
    1|       |use libobs_source_macro::obs_object_builder;
    2|       |
    3|       |macro_rules! new_output_builder {
    4|       |    ($builder:ident, $output_type:literal) => {
    5|      0|        #[obs_object_builder($output_type)]
    6|       |        pub struct $builder {
    7|       |            #[obs_property(type_t = "string")]
    8|       |            /// The path the recording should be saved to
    9|       |            path: String,
   10|       |
   11|       |            #[obs_property(type_t = "int")]
   12|       |            bitrate: i32,
   13|       |
   14|       |            #[obs_property(type_t = "int")]
   15|       |            codec_type: i32,
   16|       |
   17|       |            #[obs_property(type_t = "string")]
   18|       |            // Custom Arguments for the muxer to use
   19|       |            muxer_settings: String,
   20|       |
   21|       |            #[obs_property(type_t = "int")]
   22|       |            // The maximum time in seconds that the recording should hold
   23|       |            max_time_sec: i32,
   24|       |
   25|       |            #[obs_property(type_t = "int")]
   26|       |            // The maximum size in megabytes that the recording should hold
   27|       |            max_size_mb: i32,
   28|       |
   29|       |            #[obs_property(type_t = "bool")]
   30|       |            /// Whether the recording should be split into multiple files and merged later
   31|       |            split_file: bool,
   32|       |
   33|       |            #[obs_property(type_t = "bool")]
   34|       |            /// Whether it should be permitted to overwrite the old file
   35|       |            allow_overwrite: bool,
   36|       |
   37|       |            #[obs_property(type_t = "string")]
   38|       |            /// The directory the recording should be saved to
   39|       |            directory: String,
   40|       |
   41|       |            #[obs_property(type_t = "string")]
   42|       |            /// The format to use for the file name of the recording.
   43|       |            /// e.g. "%CCYY-%MM-%DD %hh-%mm-%ss"
   44|       |            /// Code for formatting can be found [here](https://github.com/obsproject/obs-studio/blob/5854f3b9e5861246ea57dd4a26d3d847a8552c4b/libobs/util/platform.c#L715)
   45|       |            format: String,
   46|       |
   47|       |            #[obs_property(type_t = "string")]
   48|       |            /// The extension to use for the file name of the recording (without the dot, e.g. "mpr")
   49|       |            extension: String,
   50|       |
   51|       |            #[obs_property(type_t = "bool")]
   52|       |            /// Whether spaces are allowed in the file name
   53|       |            allow_spaces: bool,
   54|       |        }
   55|       |    };
   56|       |}
   57|       |
   58|       |new_output_builder!(FFmpegMuxerOutput, "ffmpeg_muxer");
   59|       |new_output_builder!(ReplayBufferOutput, "replay_buffer");

E:\Rust\libobs-rs\libobs-sources\src\windows\sources\game_capture.rs:
    1|       |#[cfg(feature = "window-list")]
    2|       |use libobs_window_helper::{get_all_windows, WindowInfo, WindowSearchMode};
    3|       |use libobs_wrapper::{
    4|       |    data::StringEnum,
    5|       |    sources::{ObsSourceBuilder, ObsSourceRef},
    6|       |};
    7|       |
    8|       |use crate::macro_helper::define_object_manager;
    9|       |
   10|       |use super::{ObsHookRate, ObsWindowPriority};
   11|       |
   12|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   13|       |/// Describes the capture mode of the game capture source.
   14|       |pub enum ObsGameCaptureMode {
   15|       |    /// Captures any fullscreen application
   16|       |    Any,
   17|       |    /// Captures a specific window, specified under the `window` property
   18|       |    CaptureSpecificWindow,
   19|       |    /// CApture the foreground window when a hotkey is pressed
   20|       |    CaptureForegroundWindow,
   21|       |}
   22|       |
   23|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   24|       |pub enum ObsGameCaptureRgbaSpace {
   25|       |    /// sRGB color space
   26|       |    SRgb,
   27|       |    /// Rec. 2100 (PQ)
   28|       |    RGBA2100pq,
   29|       |}
   30|       |
   31|       |impl StringEnum for ObsGameCaptureRgbaSpace {
   32|      0|    fn to_str(&self) -> &str {
   33|      0|        match self {
   34|      0|            ObsGameCaptureRgbaSpace::SRgb => "sRGB",
   35|      0|            ObsGameCaptureRgbaSpace::RGBA2100pq => "Rec. 2100 (PQ)",
   36|       |        }
   37|      0|    }
   38|       |}
   39|       |
   40|       |impl StringEnum for ObsGameCaptureMode {
   41|      0|    fn to_str(&self) -> &str {
   42|      0|        match self {
   43|      0|            ObsGameCaptureMode::Any => "any_fullscreen",
   44|      0|            ObsGameCaptureMode::CaptureSpecificWindow => "window",
   45|      0|            ObsGameCaptureMode::CaptureForegroundWindow => "hotkey",
   46|       |        }
   47|      0|    }
   48|       |}
   49|       |
   50|       |define_object_manager!(
   51|       |    #[derive(Debug)]
   52|       |    /// A source to capture a game or fullscreen application.
   53|       |    ///
   54|       |    ///
   55|       |    /// Use `GameCaptureSourceBuilder::get_windows` to get a list of windows that can be captured (feature `window-list` needs to be enabled).
   56|       |    /// Requires OBS to be running with administrator privileges to capture certain games.
   57|       |    ///
   58|       |    /// ## Important Notice
   59|       |    /// This source fails to capture if another instance (OBS studio, another instance of your program, etc.) has a game capture source for the same game/application active.
   60|       |    /// If the window can be captured can be checked using `GameCaptureSourceBuilder::is_window_in_use_by_other_instance` (feature `window-list` needs to be enabled).
   61|       |    struct GameCaptureSource("game_capture") for ObsSourceRef {
   62|       |        /// Sets the capture mode for the game capture source. Look at doc for `ObsGameCaptureMode`
   63|       |        #[obs_property(type_t = "enum_string")]
   64|       |        capture_mode: ObsGameCaptureMode,
   65|       |
   66|       |        /// Sets the window to capture.
   67|       |        ///
   68|       |        /// # Arguments
   69|       |        ///
   70|       |        /// * `window` - The window to capture, represented as `ObsString`. Must be in the format of an obs window id
   71|       |        ///
   72|       |        /// # Returns
   73|       |        ///
   74|       |        /// The updated `WindowCaptureSourceBuilder` instance.
   75|       |        #[obs_property(type_t = "string", settings_key = "window")]
   76|       |        window_raw: String,
   77|       |
   78|       |        #[obs_property(type_t = "enum")]
   79|       |        /// Window Match Priority
   80|       |        priority: ObsWindowPriority,
   81|       |
   82|       |        #[obs_property(type_t = "bool")]
   83|       |        /// SLI/Crossfire Capture Mode (Slow)
   84|       |        sli_compatability: bool,
   85|       |
   86|       |        #[obs_property(type_t = "bool")]
   87|       |        /// Whether the cursor should be captured
   88|       |        capture_cursor: bool,
   89|       |
   90|       |        #[obs_property(type_t = "bool")]
   91|       |        /// If transparency of windows should be allowed
   92|       |        allow_transparency: bool,
   93|       |
   94|       |        #[obs_property(type_t = "bool")]
   95|       |        /// Premultiplied Alpha
   96|       |        premultiplied_alpha: bool,
   97|       |
   98|       |        /// Limit capture framerate
   99|       |        #[obs_property(type_t = "bool")]
  100|       |        limit_framerate: bool,
  101|       |
  102|       |        /// Capture third party overlays (such as steam overlays)
  103|       |        #[obs_property(type_t = "bool")]
  104|       |        capture_overlays: bool,
  105|       |
  106|       |        /// Use anti-cheat compatibility hook
  107|       |        #[obs_property(type_t = "bool")]
  108|       |        anti_cheat_hook: bool,
  109|       |
  110|       |        /// Hook rate (Ranging from slow to fastest)
  111|       |        #[obs_property(type_t = "enum")]
  112|       |        hook_rate: ObsHookRate,
  113|       |
  114|       |        /// The color space to capture in
  115|       |        #[obs_property(type_t = "enum_string")]
  116|       |        rgb10a2_space: ObsGameCaptureRgbaSpace,
  117|       |
  118|       |        /// Whether to capture audio from window source (BETA) <br>
  119|       |        /// When enabled, creates an "Application Audio Capture" source that automatically updates to the currently captured window/application. <br>
  120|       |        /// Note that if Desktop Audio is configured, this could result in doubled audio.
  121|       |        #[obs_property(type_t = "bool")]
  122|       |        capture_audio: bool,
  123|       |    }
  124|       |);
  125|       |
  126|       |#[cfg(feature = "window-list")]
  127|       |impl GameCaptureSourceBuilder {
  128|       |    /// Gets a list of windows that can be captured by this source.
  129|      0|    pub fn get_windows(mode: WindowSearchMode) -> anyhow::Result<Vec<WindowInfo>> {
  130|      0|        get_all_windows(mode).map(|e| e.into_iter().filter(|x| x.is_game).collect::<Vec<_>>())
  131|      0|    }
  132|       |
  133|       |    /// Checks if a window with the given process ID can be captured by this source.
  134|       |    /// This does not guarantee that the window can be captured, only that it is not black
  135|      0|    pub fn is_window_in_use_by_other_instance(window_pid: u32) -> std::io::Result<bool> {
  136|       |        use libobs_window_helper::is_window_in_use_by_other_instance;
  137|       |
  138|      0|        is_window_in_use_by_other_instance(window_pid)
  139|      0|    }
  140|       |
  141|       |    /// Sets the window to capture.
  142|       |    ///
  143|       |    /// # Arguments
  144|       |    ///
  145|       |    /// * `window` - The window to capture. A list of available windows can be retrieved using `GameCaptureSourceBuilder::get_windows`
  146|       |    ///
  147|       |    /// # Returns
  148|       |    ///
  149|       |    /// The updated `GameCaptureSourceBuilder` instance.
  150|      0|    pub fn set_window(self, window: &WindowInfo) -> Self {
  151|      0|        self.set_window_raw(window.obs_id.as_str())
  152|      0|    }
  153|       |}
  154|       |
  155|       |impl ObsSourceBuilder for GameCaptureSourceBuilder {}

E:\Rust\libobs-rs\libobs-sources\src\windows\sources\monitor_capture.rs:
    1|       |//! Monitor capture source for Windows using libobs-rs
    2|       |//! This source captures the entire monitor and is used for screen recording.
    3|       |
    4|       |/// Note: This does not update the capture method directly, instead the capture method gets
    5|       |/// stored in the struct. The capture method is being set to WGC at first, then the source is created and then the capture method is updated to the desired method.
    6|       |use display_info::DisplayInfo;
    7|       |use libobs_source_macro::obs_object_impl;
    8|       |use libobs_wrapper::{
    9|       |    data::{ObsObjectBuilder, ObsObjectUpdater},
   10|       |    scenes::ObsSceneRef,
   11|       |    sources::{ObsSourceBuilder, ObsSourceRef},
   12|       |    unsafe_send::Sendable,
   13|       |    utils::ObsError,
   14|       |};
   15|       |use num_traits::ToPrimitive;
   16|       |
   17|       |use crate::macro_helper::define_object_manager;
   18|       |
   19|       |use super::ObsDisplayCaptureMethod;
   20|       |
   21|       |// Usage example
   22|       |define_object_manager!(
   23|       |    /// Provides a easy to use builder for the monitor capture source.
   24|       |    #[derive(Debug)]
   25|       |    struct MonitorCaptureSource("monitor_capture") for ObsSourceRef {
   26|       |        #[obs_property(type_t = "string", settings_key = "monitor_id")]
   27|       |        monitor_id_raw: String,
   28|       |
   29|       |        #[obs_property(type_t = "bool")]
   30|       |        /// Sets whether the cursor should be captured.
   31|       |        capture_cursor: bool,
   32|       |
   33|       |        #[obs_property(type_t = "bool")]
   34|       |        /// Compatibility mode for the monitor capture source.
   35|       |        compatibility: bool,
   36|       |
   37|       |        capture_method: Option<ObsDisplayCaptureMethod>,
   38|       |    }
   39|       |);
   40|       |
   41|       |#[obs_object_impl]
   42|       |impl MonitorCaptureSource {
   43|       |    /// Gets all available monitors
   44|      3|    pub fn get_monitors() -> anyhow::Result<Vec<Sendable<DisplayInfo>>> {
   45|      3|        Ok(DisplayInfo::all()?.into_iter().map(Sendable).collect())
                                           ^0
   46|      3|    }
   47|       |
   48|      2|    pub fn set_monitor(self, monitor: &Sendable<DisplayInfo>) -> Self {
   49|      2|        self.set_monitor_id_raw(monitor.0.name.as_str())
   50|      2|    }
   51|       |}
   52|       |
   53|       |impl<'a> MonitorCaptureSourceUpdater<'a> {
   54|      0|    pub fn set_capture_method(mut self, method: ObsDisplayCaptureMethod) -> Self {
   55|      0|        self.get_settings_updater()
   56|      0|            .set_int_ref("method", method.to_i32().unwrap() as i64);
   57|       |
   58|      0|        self
   59|      0|    }
   60|       |}
   61|       |
   62|       |impl MonitorCaptureSourceBuilder {
   63|       |    /// Sets the capture method for the monitor capture source.
   64|       |    /// Only MethodWgc works for now as the other DXGI method does not work and only records a black screen (Failed to DuplicateOutput1)
   65|       |    /// Workaround for black screen bug: [issue](https://github.com/joshprk/libobs-rs/issues/5)
   66|      0|    pub fn set_capture_method(mut self, method: ObsDisplayCaptureMethod) -> Self {
   67|      0|        self.capture_method = Some(method);
   68|      0|        self
   69|      0|    }
   70|       |}
   71|       |
   72|       |impl ObsSourceBuilder for MonitorCaptureSourceBuilder {
   73|      2|    fn add_to_scene(mut self, scene: &mut ObsSceneRef) -> Result<ObsSourceRef, ObsError>
   74|      2|    where
   75|      2|        Self: Sized,
   76|       |    {
   77|       |        // Because of a black screen bug, we need to set the method to WGC first and then update
   78|      2|        self.get_settings_updater().set_int_ref(
   79|       |            "method",
   80|      2|            ObsDisplayCaptureMethod::MethodWgc.to_i32().unwrap() as i64,
   81|       |        );
   82|       |
   83|      2|        let method_to_set = self.capture_method;
   84|      2|        let runtime = self.runtime.clone();
   85|       |
   86|      2|        let b = self.build()?;
                                          ^0
   87|      2|        let mut res = scene.add_source(b)?;
                                                       ^0
   88|       |
   89|      2|        if let Some(method) = method_to_set {
                                  ^0
   90|      0|            MonitorCaptureSourceUpdater::create_update(runtime, &mut res)?
   91|      0|                .set_capture_method(method)
   92|      0|                .update()?;
   93|      2|        }
   94|       |
   95|      2|        Ok(res)
   96|      2|    }
   97|       |}

E:\Rust\libobs-rs\libobs-sources\src\windows\sources\window_capture.rs:
    1|       |use libobs_source_macro::obs_object_impl;
    2|       |#[cfg(feature = "window-list")]
    3|       |use libobs_window_helper::{get_all_windows, WindowInfo, WindowSearchMode};
    4|       |use libobs_wrapper::{
    5|       |    data::{ObsObjectBuilder, ObsObjectUpdater},
    6|       |    scenes::ObsSceneRef,
    7|       |    sources::{ObsSourceBuilder, ObsSourceRef},
    8|       |    unsafe_send::Sendable,
    9|       |    utils::ObsError,
   10|       |};
   11|       |use num_traits::ToPrimitive;
   12|       |
   13|       |use crate::macro_helper::define_object_manager;
   14|       |
   15|       |use super::{ObsWindowCaptureMethod, ObsWindowPriority};
   16|       |
   17|       |define_object_manager!(
   18|       |    /// Provides a easy to use builder for the window capture source.
   19|       |    #[derive(Debug)]
   20|       |    struct WindowCaptureSource("window_capture") for ObsSourceRef {
   21|       |
   22|       |    /// Sets the priority of the window capture source.
   23|       |    /// Used to determine in which order windows are searched for.
   24|       |    ///
   25|       |    /// # Arguments
   26|       |    ///
   27|       |    /// * `priority` - The priority of the window capture source.
   28|       |    ///
   29|       |    /// # Returns
   30|       |    ///
   31|       |    /// The updated `WindowCaptureSourceBuilder` instance.
   32|       |    #[obs_property(type_t = "enum")]
   33|       |    priority: ObsWindowPriority,
   34|       |
   35|       |    /// Sets the window to capture.
   36|       |    ///
   37|       |    /// # Arguments
   38|       |    ///
   39|       |    /// * `window` - The window to capture, represented as `ObsString`. Must be in the format of an obs window id
   40|       |    ///
   41|       |    /// # Returns
   42|       |    ///
   43|       |    /// The updated `WindowCaptureSourceBuilder` instance.
   44|       |    #[obs_property(type_t = "string", settings_key = "window")]
   45|       |    window_raw: String,
   46|       |
   47|       |    #[obs_property(type_t = "bool")]
   48|       |    /// Sets whether the cursor should be captured
   49|       |    cursor: bool,
   50|       |
   51|       |    #[obs_property(type_t = "bool")]
   52|       |    /// Whether to capture audio from window source (BETA) <br>
   53|       |    /// When enabled, creates an "Application Audio Capture" source that automatically updates to the currently captured window/application. <br>
   54|       |    /// Note that if Desktop Audio is configured, this could result in doubled audio.
   55|       |    capture_audio: bool,
   56|       |
   57|       |    #[obs_property(type_t = "bool")]
   58|       |    /// Whether to force SDR color space for the window capture source.
   59|       |    force_sdr: bool,
   60|       |
   61|       |    #[obs_property(type_t = "bool")]
   62|       |    /// Whether to capture the window's client area only (without borders, title bar and the main menu bar).
   63|       |    client_area: bool,
   64|       |
   65|       |    #[obs_property(type_t = "bool")]
   66|       |    compatibility: bool,
   67|       |
   68|       |    capture_method: Option<ObsWindowCaptureMethod>,
   69|       |});
   70|       |
   71|       |#[obs_object_impl]
   72|       |#[cfg(feature = "window-list")]
   73|       |impl WindowCaptureSource {
   74|       |    /// Gets a list of windows that can be captured by this source.
   75|      4|    pub fn get_windows(mode: WindowSearchMode) -> anyhow::Result<Vec<Sendable<WindowInfo>>> {
   76|      4|        Ok(get_all_windows(mode)?.into_iter().map(Sendable).collect())
                                              ^0
   77|      4|    }
   78|       |
   79|       |    /// Sets the window to capture.
   80|       |    ///
   81|       |    /// # Arguments
   82|       |    ///
   83|       |    /// * `window` - The window to capture. A list of available windows can be retrieved using `WindowCaptureSourceBuilder::get_windows`
   84|       |    ///
   85|       |    /// # Returns
   86|       |    ///
   87|       |    /// The updated `WindowCaptureSourceBuilder` instance.
   88|      4|    pub fn set_window(self, window: &Sendable<WindowInfo>) -> Self {
   89|      4|        self.set_window_raw(window.0.obs_id.as_str())
   90|      4|    }
   91|       |}
   92|       |
   93|       |impl<'a> WindowCaptureSourceUpdater<'a> {
   94|      3|    pub fn set_capture_method(mut self, method: ObsWindowCaptureMethod) -> Self {
   95|      3|        self.get_settings_updater()
   96|      3|            .set_int_ref("method", method.to_i32().unwrap() as i64);
   97|       |
   98|      3|        self
   99|      3|    }
  100|       |}
  101|       |
  102|       |impl WindowCaptureSourceBuilder {
  103|       |    /// Sets the capture method for the window capture source.
  104|      3|    pub fn set_capture_method(mut self, method: ObsWindowCaptureMethod) -> Self {
  105|      3|        self.capture_method = Some(method);
  106|      3|        self
  107|      3|    }
  108|       |}
  109|       |
  110|       |impl ObsSourceBuilder for WindowCaptureSourceBuilder {
  111|      3|    fn add_to_scene(mut self, scene: &mut ObsSceneRef) -> Result<ObsSourceRef, ObsError>
  112|      3|    where
  113|      3|        Self: Sized,
  114|       |    {
  115|       |        // Because of a black screen bug, we need to set the method to WGC first and then update (I've copied this code from the DisplayCapture source, they should have the same issue)
  116|      3|        self.get_settings_updater().set_int_ref(
  117|       |            "method",
  118|      3|            ObsWindowCaptureMethod::MethodAuto.to_i32().unwrap() as i64,
  119|       |        );
  120|       |
  121|      3|        let method_to_set = self.capture_method;
  122|      3|        let runtime = self.runtime.clone();
  123|       |
  124|      3|        let b = self.build()?;
                                          ^0
  125|      3|        let mut res = scene.add_source(b)?;
                                                       ^0
  126|       |
  127|      3|        if let Some(method) = method_to_set {
  128|      3|            WindowCaptureSourceUpdater::create_update(runtime, &mut res)?
                                                                                      ^0
  129|      3|                .set_capture_method(method)
  130|      3|                .update()?;
                                       ^0
  131|      0|        }
  132|       |
  133|      3|        Ok(res)
  134|      3|    }
  135|       |}

E:\Rust\libobs-rs\libobs-window-helper\src\game.rs:
    1|       |/// List is taken from <https://github.com/obsproject/obs-studio/blob/ce6f9a4742b40b04e68ef759e0698bd5eac4360e/plugins/win-capture/game-capture.c#L1040>
    2|       |const BLACKLISTED_EXE: &[&str] = &[
    3|       |    "explorer",
    4|       |    "steam",
    5|       |    "battle.net",
    6|       |    "galaxyclient",
    7|       |    "skype",
    8|       |    "uplay",
    9|       |    "origin",
   10|       |    "devenv",
   11|       |    "taskmgr",
   12|       |    "chrome",
   13|       |    "discord",
   14|       |    "firefox",
   15|       |    "systemsettings",
   16|       |    "applicationframehost",
   17|       |    "cmd",
   18|       |    "shellexperiencehost",
   19|       |    "winstore.app",
   20|       |    "searchui",
   21|       |    "lockapp",
   22|       |    "windowsinternal.composableshell.experiences.textinput.inputapp",
   23|       |];
   24|       |
   25|    133|pub fn is_blacklisted_window(exe: &str) -> bool {
   26|    133|    let exe_lowercase = exe.to_lowercase();
   27|    133|    let exe_lowercase = exe_lowercase.trim_end_matches(".exe");
   28|       |
   29|    133|    BLACKLISTED_EXE.contains(&exe_lowercase)
   30|    133|}

E:\Rust\libobs-rs\libobs-window-helper\src\lib.rs:
    1|       |//! # OBS Window Helper
    2|       |//! This crate provides necessary information about windows that could be used
    3|       |//! so they can be captured with the `window_capture` or `game_capture` source in OBS.
    4|       |//! <br> The function you probably want to use is `get_all_windows` which returns a list of `WindowInfo` structs.
    5|       |
    6|       |#[cfg(not(windows))]
    7|       |compile_error!("This library only supports windows!");
    8|       |
    9|       |#[cfg(not(target_pointer_width = "64"))]
   10|       |compile_error!("compilation is only allowed for 64-bit targets");
   11|       |
   12|       |mod game;
   13|       |mod monitor;
   14|       |mod util;
   15|       |mod window;
   16|       |
   17|       |pub use util::*;
   18|       |#[cfg(test)]
   19|       |mod test;
   20|       |
   21|       |pub use game::*;
   22|       |pub use helper::*;
   23|       |use win_iterator::{first_window, next_window};
   24|       |use windows::Win32::{Foundation::HWND, System::Console::GetConsoleWindow};
   25|       |
   26|       |/// Retrieves information about all windows based on the specified search mode and game check flag.
   27|       |///
   28|       |/// # Arguments
   29|       |///
   30|       |/// * `mode` - The search mode to use for window enumeration.
   31|       |/// * `check_game` - A flag indicating wether a `game_capture` or a `window_capture` is used
   32|       |///
   33|       |/// # Returns
   34|       |///
   35|       |/// A `Result` containing a vector of `WindowInfo` structs representing the retrieved window information, or an `anyhow::Error` if an error occurs.
   36|      6|pub fn get_all_windows(mode: WindowSearchMode) -> anyhow::Result<Vec<WindowInfo>> {
   37|      6|    let mut use_find_window_ex = false;
   38|       |
   39|      6|    let mut parent = None as Option<HWND>;
   40|      6|    let window = unsafe { first_window(mode, &mut parent, &mut use_find_window_ex)? };
                                                                                                ^0
   41|      6|    let mut window = Some(window);
   42|       |
   43|      6|    let curr = unsafe { GetConsoleWindow() };
   44|       |
   45|      6|    let mut out = Vec::new();
   46|    139|    while window.is_some_and(|e| !e.is_invalid()) {
                                                ^133^133
   47|    133|        let w = window.unwrap();
   48|    133|        if curr != w {
   49|    133|            let res = get_window_info(w);
   50|    133|            if let Ok(info) = res {
   51|    133|                out.push(info);
   52|    133|            } else {
   53|      0|                //eprintln!("Error: {:?}", res.err().unwrap());
   54|      0|            }
   55|      0|        }
   56|       |
   57|       |        unsafe {
   58|    133|            window = next_window(window, mode, &mut parent, use_find_window_ex)?;
                                                                                             ^0
   59|       |        }
   60|       |    }
   61|       |
   62|      6|    Ok(out)
   63|      6|}
   64|       |
   65|       |const OBS_PIPE_NAME: &str = "CaptureHook_Pipe";
   66|      0|pub fn is_window_in_use_by_other_instance(window_pid: u32) -> std::io::Result<bool> {
   67|       |    #[cfg(not(windows))]
   68|       |    return false;
   69|       |
   70|      0|    let pipe_name = format!("{}{}", OBS_PIPE_NAME, window_pid);
   71|      0|    let paths = std::fs::read_dir(r"\\.\pipe\")?;
   72|       |
   73|      0|    for path in paths {
   74|      0|        let path = path?;
   75|      0|        let name = path.file_name();
   76|      0|        let name = name.to_string_lossy();
   77|       |
   78|      0|        if name == pipe_name {
   79|      0|            return Ok(true);
   80|      0|        }
   81|       |    }
   82|       |
   83|      0|    Ok(false)
   84|      0|}

E:\Rust\libobs-rs\libobs-window-helper\src\monitor.rs:
    1|       |use anyhow::Result;
    2|       |use windows::Win32::Graphics::Gdi::{GetMonitorInfoW, HMONITOR, MONITORINFOEXW};
    3|       |
    4|       |use crate::string_conv::ToUtf8String;
    5|       |
    6|    133|pub fn get_monitor_id(monitor: HMONITOR) -> Result<String> {
    7|    133|    let mut monitor_info = MONITORINFOEXW::default();
    8|    133|    monitor_info.monitorInfo.cbSize = std::mem::size_of::<MONITORINFOEXW>() as u32;
    9|       |
   10|       |    unsafe {
   11|    133|        GetMonitorInfoW(monitor, &mut monitor_info as *mut _ as _).ok()?;
                                                                                     ^0
   12|       |    }
   13|       |
   14|    133|    Ok(monitor_info.szDevice.to_utf8())
   15|    133|}

E:\Rust\libobs-rs\libobs-window-helper\src\test.rs:
    1|       |use crate::{get_all_windows, validators::WindowSearchMode, WindowInfo};
    2|       |
    3|       |#[test]
    4|      1|pub fn test_iteration() {
    5|      1|    let res1 = get_all_windows(WindowSearchMode::ExcludeMinimized).unwrap();
    6|      1|    let res2 = get_all_windows(WindowSearchMode::IncludeMinimized).unwrap();
    7|       |
    8|      1|    log_res(res1);
    9|      1|    log_res(res2);
   10|      1|}
   11|       |
   12|      2|fn log_res(info: Vec<WindowInfo>) {
   13|       |    #[cfg(feature = "serde")]
   14|       |    {
   15|       |        let json = serde_json::to_string_pretty(&info).unwrap();
   16|       |        println!("{}", json)
   17|       |    }
   18|       |    #[cfg(not(feature = "serde"))]
   19|      2|    println!("{:?}", info);
   20|      2|}

E:\Rust\libobs-rs\libobs-window-helper\src\util\helper.rs:
    1|       |use anyhow::{anyhow, Result as AnyResult};
    2|       |use windows::{
    3|       |    core::{Error, Result as WinResult},
    4|       |    Win32::{Foundation::HWND, UI::WindowsAndMessaging::GetWindowThreadProcessId},
    5|       |};
    6|       |
    7|       |use crate::{
    8|       |    is_blacklisted_window,
    9|       |    monitor::get_monitor_id,
   10|       |    validators::is_microsoft_internal_exe,
   11|       |    window::{
   12|       |        get_command_line_args, get_exe, get_product_name, get_title, get_window_class,
   13|       |        hwnd_to_monitor, intersects_with_multiple_monitors,
   14|       |    },
   15|       |};
   16|       |
   17|       |#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
   18|       |#[cfg_attr(feature = "specta", derive(specta::Type))]
   19|       |#[derive(Debug, Clone)]
   20|       |/// Represents information about a window.
   21|       |pub struct WindowInfo {
   22|       |    /// The full path to the executable associated with the window.
   23|       |    pub full_exe: String,
   24|       |    /// The unique identifier of the window in OBS.
   25|       |    pub obs_id: String,
   26|       |    #[cfg(not(feature = "serde"))]
   27|       |    /// The handle to the window (only enabled when feature `serde` is disabled).
   28|       |    pub handle: HWND,
   29|       |    /// The process ID of the window.
   30|       |    pub pid: u32,
   31|       |    /// The title of the window.
   32|       |    pub title: Option<String>,
   33|       |    /// The class name of the window.
   34|       |    pub class: Option<String>,
   35|       |    /// The product name of the window.
   36|       |    pub product_name: Option<String>,
   37|       |    /// The monitor on which the window is located.
   38|       |    pub monitor: Option<String>,
   39|       |    /// Indicates whether the window is between multiple monitors.
   40|       |    pub intersects: Option<bool>,
   41|       |    /// The command line used to launch the process.
   42|       |    pub cmd_line: Option<String>,
   43|       |    /// If this window can be recorded using a game capture source.
   44|       |    pub is_game: bool,
   45|       |}
   46|       |
   47|    399|fn encode_string(s: &str) -> String {
   48|    399|    s.replace("#", "#22").replace(":", "#3A")
   49|    399|}
   50|       |
   51|       |/// Retrieves the OBS window information associated with the given window handle.
   52|       |///
   53|       |/// # Arguments
   54|       |///
   55|       |/// * `handle` - The handle to the window.
   56|       |/// * `is_game` - If this flag is true, only game windows (that can be captured by the game source) are considered. Otherwise `window_capture` source info is returned.
   57|       |///
   58|       |/// # Returns
   59|       |///
   60|       |/// Returns the OBS window information as struct
   61|       |///
   62|       |/// # Errors
   63|       |///
   64|       |/// Returns an error if there was a problem retrieving the OBS ID.
   65|    133|pub fn get_window_info(wnd: HWND) -> AnyResult<WindowInfo> {
   66|    133|    let (proc_id, full_exe) = get_exe(wnd)?;
                                                        ^0
   67|    133|    let exe = full_exe
   68|    133|        .file_name()
   69|    133|        .ok_or(anyhow!("Failed to get file name"))?;
                                                                ^0
   70|    133|    let exe = exe.to_str().ok_or(anyhow!("Failed to convert to str"))?;
                                                                                   ^0
   71|    133|    let exe = exe.to_string();
   72|       |
   73|    133|    if is_microsoft_internal_exe(&exe) {
   74|      0|        return Err(anyhow!("Handle is a Microsoft internal exe"));
   75|    133|    }
   76|       |
   77|    133|    if exe == "obs64.exe" {
   78|      0|        return Err(anyhow!("Handle is obs64.exe"));
   79|    133|    }
   80|       |
   81|    133|    let is_game = !is_blacklisted_window(&exe);
   82|       |
   83|    133|    let title = get_title(wnd).ok();
   84|    133|    let class = get_window_class(wnd).ok();
   85|       |
   86|    133|    let product_name = get_product_name(&full_exe).ok();
   87|    133|    let monitor = Some(hwnd_to_monitor(wnd)?);
                                                         ^0
   88|    133|    let intersects = intersects_with_multiple_monitors(wnd).ok();
   89|    133|    let cmd_line = get_command_line_args(wnd).ok();
   90|    133|    let monitor_id = monitor.and_then(|e| get_monitor_id(e).ok());
   91|       |
   92|    133|    let title_o = title.as_ref().map_or("", |v| v);
   93|    133|    let class_o = class.as_ref().map_or("", |v| v);
   94|       |
   95|    133|    let obs_id: Vec<String> = vec![title_o, class_o, &exe]
   96|    133|        .into_iter()
   97|    133|        .map(encode_string)
   98|    133|        .collect();
   99|       |
  100|    133|    let obs_id = obs_id.join(":");
  101|    133|    Ok(WindowInfo {
  102|    133|        full_exe: full_exe.to_string_lossy().to_string(),
  103|    133|        obs_id,
  104|    133|        #[cfg(not(feature = "serde"))]
  105|    133|        handle: wnd,
  106|    133|        pid: proc_id,
  107|    133|        title,
  108|    133|        class,
  109|    133|        product_name,
  110|    133|        monitor: monitor_id,
  111|    133|        intersects,
  112|    133|        cmd_line,
  113|    133|        is_game,
  114|    133|    })
  115|    133|}
  116|       |
  117|       |pub struct ProcessInfo {
  118|       |    pub process_id: u32,
  119|       |    pub thread_id: u32,
  120|       |}
  121|       |
  122|    476|pub fn get_thread_proc_id(wnd: HWND) -> WinResult<ProcessInfo> {
  123|    476|    let mut proc_id = 0u32;
  124|       |
  125|    476|    let thread_id = unsafe { GetWindowThreadProcessId(wnd, Some(&mut proc_id)) };
  126|    476|    if thread_id == 0 {
  127|      0|        return Err(Error::from_win32());
  128|    476|    }
  129|       |
  130|    476|    Ok(ProcessInfo {
  131|    476|        process_id: proc_id,
  132|    476|        thread_id,
  133|    476|    })
  134|    476|}

E:\Rust\libobs-rs\libobs-window-helper\src\util\string_conv.rs:
    1|       |pub trait ToUtf8String {
    2|       |    fn to_utf8(&self) -> String;
    3|       |}
    4|       |
    5|       |pub trait StrLen<T> {
    6|       |    fn strlen(&self) -> usize;
    7|       |    fn strslice(&self) -> &[T];
    8|       |}
    9|       |
   10|       |impl<T: Default + PartialEq> StrLen<T> for [T] {
   11|    761|    fn strlen(&self) -> usize {
   12|    761|        let zero = &Default::default();
   13|  30.2k|        match self.iter().position(|x| x == zero) {
                            ^761        ^761
   14|      0|            None => self.len(),
   15|    761|            Some(x) => x,
   16|       |        }
   17|    761|    }
   18|       |
   19|    761|    fn strslice(&self) -> &[T] {
   20|    761|        &self[0..self.strlen()]
   21|    761|    }
   22|       |}
   23|       |
   24|       |impl<T: AsRef<[u16]>> ToUtf8String for T {
   25|    761|    fn to_utf8(&self) -> String {
   26|    761|        String::from_utf16_lossy(self.as_ref().strslice())
   27|    761|            .trim_end_matches("\0")
   28|    761|            .to_string()
   29|    761|    }
   30|       |}

E:\Rust\libobs-rs\libobs-window-helper\src\util\validators.rs:
    1|       |use std::os::raw::c_void;
    2|       |use windows::Win32::UI::WindowsAndMessaging::{
    3|       |    GetClientRect, GetWindowLongPtrW, IsIconic, IsWindowVisible, GWL_EXSTYLE, GWL_STYLE, WS_CHILD,
    4|       |    WS_EX_TOOLWINDOW,
    5|       |};
    6|       |use windows::{
    7|       |    core::Result,
    8|       |    Win32::{
    9|       |        Foundation::{HWND, RECT},
   10|       |        Graphics::Dwm::{DwmGetWindowAttribute, DWMWA_CLOAKED},
   11|       |    },
   12|       |};
   13|       |
   14|       |const INTERNAL_MICROSOFT_EXES_EXACT: &[&str] = &[
   15|       |    "startmenuexperiencehost.exe",
   16|       |    "applicationframehost.exe",
   17|       |    "peopleexperiencehost.exe",
   18|       |    "shellexperiencehost.exe",
   19|       |    "microsoft.notes.exe",
   20|       |    "systemsettings.exe",
   21|       |    "textinputhost.exe",
   22|       |    "searchapp.exe",
   23|       |    "video.ui.exe",
   24|       |    "searchui.exe",
   25|       |    "lockapp.exe",
   26|       |    "cortana.exe",
   27|       |    "gamebar.exe",
   28|       |    "tabtip.exe",
   29|       |    "time.exe",
   30|       |];
   31|       |
   32|       |const INTERNAL_MICROSOFT_EXES_PARTIAL: &[&str] = &["windowsinternal"];
   33|       |
   34|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   35|       |pub enum WindowSearchMode {
   36|       |    ExcludeMinimized,
   37|       |    IncludeMinimized,
   38|       |}
   39|       |
   40|       |#[allow(clippy::upper_case_acronyms)]
   41|       |type DWORD = u32;
   42|       |
   43|    202|pub(crate) fn is_window_cloaked(handle: HWND) -> bool {
   44|    202|    let cloaked: DWORD = 0;
   45|    202|    let res = unsafe {
   46|    202|        DwmGetWindowAttribute(
   47|    202|            handle,
   48|       |            DWMWA_CLOAKED,
   49|    202|            cloaked as *mut c_void,
   50|    202|            size_of::<DWORD>() as u32,
   51|       |        )
   52|       |    };
   53|       |
   54|    202|    res.is_ok() && cloaked != 0
                                 ^0
   55|    202|}
   56|       |
   57|  3.05k|pub fn is_window_valid(handle: HWND, mode: WindowSearchMode) -> Result<bool> {
   58|  3.05k|    let is_visible = unsafe { IsWindowVisible(handle) };
   59|  3.05k|    if !is_visible.as_bool() {
   60|  2.81k|        return Ok(false);
   61|    242|    }
   62|       |
   63|    242|    if mode == WindowSearchMode::ExcludeMinimized {
   64|    202|        let is_minimized = unsafe { IsIconic(handle).as_bool() } || is_window_cloaked(handle);
   65|    202|        if is_minimized {
   66|      0|            return Ok(false);
   67|    202|        }
   68|     40|    }
   69|       |
   70|    242|    let mut rect = RECT::default();
   71|       |    let styles;
   72|       |    let ex_styles;
   73|       |
   74|       |    unsafe {
   75|    242|        GetClientRect(handle, &mut rect)?;
                                                      ^0
   76|       |
   77|       |        // Use the W function because obs can only be compiled for 64-bit
   78|    242|        styles = GetWindowLongPtrW(handle, GWL_STYLE) as DWORD;
   79|    242|        ex_styles = GetWindowLongPtrW(handle, GWL_EXSTYLE) as DWORD;
   80|       |    }
   81|       |
   82|    242|    if ex_styles & WS_EX_TOOLWINDOW.0 > 0 {
   83|    104|        return Ok(false);
   84|    138|    }
   85|    138|    if styles & WS_CHILD.0 > 0 {
   86|      0|        return Ok(false);
   87|    138|    }
   88|       |
   89|    138|    if mode == WindowSearchMode::ExcludeMinimized && (rect.bottom == 0 || rect.right == 0) {
                                                                    ^115                ^110
   90|      5|        return Ok(false);
   91|    133|    }
   92|       |
   93|    133|    Ok(true)
   94|  3.05k|}
   95|       |
   96|    133|pub fn is_microsoft_internal_exe(exe: &str) -> bool {
   97|    133|    let exact = INTERNAL_MICROSOFT_EXES_EXACT.contains(&exe);
   98|    133|    let partial = INTERNAL_MICROSOFT_EXES_PARTIAL
   99|    133|        .iter()
  100|    133|        .any(|e| exe.contains(e));
  101|       |
  102|    133|    exact || partial
  103|    133|}

E:\Rust\libobs-rs\libobs-window-helper\src\util\win_iterator.rs:
    1|       |use anyhow::Result;
    2|       |use windows::{
    3|       |    core::PWSTR,
    4|       |    Win32::{
    5|       |        Foundation::HWND,
    6|       |        UI::WindowsAndMessaging::{
    7|       |            FindWindowExW, GetDesktopWindow, GetWindow, GW_CHILD, GW_HWNDNEXT,
    8|       |        },
    9|       |    },
   10|       |};
   11|       |
   12|       |use crate::{
   13|       |    get_thread_proc_id,
   14|       |    validators::{is_window_valid, WindowSearchMode},
   15|       |    window::get_window_class,
   16|       |    ProcessInfo,
   17|       |};
   18|       |
   19|    145|pub unsafe fn is_uwp_window(hwnd: HWND) -> Result<bool> {
   20|    145|    if hwnd.is_invalid() {
   21|      6|        return Ok(false);
   22|    139|    }
   23|       |
   24|    139|    let class = get_window_class(hwnd)?;
                                                    ^0
   25|    139|    Ok(class == "ApplicationFrameWindow")
   26|    145|}
   27|       |
   28|     54|pub unsafe fn get_uwp_actual_window(parent: HWND) -> Result<Option<HWND>> {
   29|       |    let ProcessInfo {
   30|     54|        process_id: parent_id,
   31|       |        ..
   32|     54|    } = get_thread_proc_id(parent)?;
                                                ^0
   33|       |
   34|     54|    let mut child = FindWindowExW(Some(parent), None, PWSTR::null(), PWSTR::null())?;
                                                                                                 ^0
   35|       |
   36|    204|    while !child.is_invalid() {
   37|       |        let ProcessInfo {
   38|    156|            process_id: child_id,
   39|       |            ..
   40|    156|        } = get_thread_proc_id(child)?;
                                                   ^0
   41|       |
   42|    156|        if child_id != parent_id {
   43|      6|            return Ok(Some(child));
   44|    150|        }
   45|       |
   46|    150|        child = FindWindowExW(Some(parent), Some(child), PWSTR::null(), PWSTR::null())
   47|    150|            .unwrap_or(HWND::default());
   48|       |    }
   49|       |
   50|     48|    Ok(None)
   51|     54|}
   52|       |
   53|    139|pub unsafe fn next_window(
   54|    139|    window: Option<HWND>,
   55|    139|    mode: WindowSearchMode,
   56|    139|    parent: &mut Option<HWND>,
   57|    139|    use_find_window_ex: bool,
   58|    139|) -> anyhow::Result<Option<HWND>> {
   59|    139|    let mut window = window.unwrap_or_default();
   60|       |
   61|    139|    let parent_valid = parent.is_some_and(|e| !e.is_invalid());
                                                             ^6^6
   62|    139|    if parent_valid {
   63|      6|        window = parent.unwrap_or_default();
   64|      6|        *parent = None;
   65|    133|    }
   66|       |
   67|       |    loop {
   68|  3.04k|        window = if use_find_window_ex {
   69|  3.04k|            FindWindowExW(
   70|  3.04k|                Some(GetDesktopWindow()),
   71|  3.04k|                Some(window),
   72|  3.04k|                PWSTR::null(),
   73|  3.04k|                PWSTR::null(),
   74|       |            )
   75|       |        } else {
   76|      0|            GetWindow(window, GW_HWNDNEXT)
   77|       |        }
   78|  3.04k|        .unwrap_or(HWND::default());
   79|       |
   80|  3.04k|        let valid = is_window_valid(window, mode).ok().unwrap_or(false);
   81|  3.04k|        if window.is_invalid() || valid {
                                                ^3.04k
   82|    139|            break;
   83|  2.90k|        }
   84|       |    }
   85|       |
   86|    139|    let window_opt = if window.is_invalid() {
   87|      6|        None
   88|       |    } else {
   89|    133|        Some(window)
   90|       |    };
   91|       |
   92|    139|    if is_uwp_window(window)? {
                                          ^0
   93|     48|        if format!("{:?}", window.0).ends_with("041098") {
   94|      0|            println!("UWP Window: {:?}", window);
   95|     48|        }
   96|     48|        let actual = get_uwp_actual_window(window)?;
                                                                ^0
   97|     48|        if let Some(child) = actual {
                                  ^6
   98|      6|            *parent = window_opt;
   99|       |
  100|      6|            return Ok(Some(child));
  101|     42|        }
  102|     91|    }
  103|       |
  104|    133|    Ok(window_opt)
  105|    139|}
  106|       |
  107|      6|pub unsafe fn first_window(
  108|      6|    mode: WindowSearchMode,
  109|      6|    parent: &mut Option<HWND>,
  110|      6|    use_find_window_ex: &mut bool,
  111|      6|) -> anyhow::Result<HWND> {
  112|      6|    let mut window =
  113|      6|        FindWindowExW(Some(GetDesktopWindow()), None, PWSTR::null(), PWSTR::null()).ok();
  114|       |
  115|      6|    if window.is_none() {
  116|      0|        *use_find_window_ex = false;
  117|      0|        window = GetWindow(GetDesktopWindow(), GW_CHILD).ok();
  118|      6|    } else {
  119|      6|        *use_find_window_ex = true;
  120|      6|    }
  121|       |
  122|      6|    *parent = None;
  123|       |
  124|      6|    let is_valid = window.is_some_and(|e| is_window_valid(e, mode).unwrap_or(false));
  125|       |
  126|      6|    if !is_valid {
  127|      6|        window = next_window(window, mode, parent, *use_find_window_ex)?;
                                                                                     ^0
  128|       |
  129|      6|        if window.is_none() && *use_find_window_ex {
                                             ^0
  130|      0|            *use_find_window_ex = false;
  131|       |
  132|      0|            window = GetWindow(GetDesktopWindow(), GW_CHILD).ok();
  133|      0|            let valid = window.is_some_and(|e| is_window_valid(e, mode).unwrap_or(false));
  134|       |
  135|      0|            if !valid {
  136|      0|                window = next_window(window, mode, parent, *use_find_window_ex)?;
  137|      0|            }
  138|      6|        }
  139|      0|    }
  140|       |
  141|      6|    if window.is_none() {
  142|      0|        return Err(anyhow::anyhow!("No window found"));
  143|      6|    }
  144|       |
  145|      6|    let window = window.unwrap();
  146|      6|    if is_uwp_window(window)? {
                                          ^0
  147|      6|        let child = get_uwp_actual_window(window)?;
                                                               ^0
  148|      6|        if let Some(c) = child {
                                  ^0
  149|      0|            *parent = Some(window);
  150|      0|            return Ok(c);
  151|      6|        }
  152|      0|    }
  153|       |
  154|      6|    Ok(window)
  155|      6|}

E:\Rust\libobs-rs\libobs-window-helper\src\window.rs:
    1|       |use std::{
    2|       |    ffi::OsString,
    3|       |    os::windows::ffi::OsStrExt,
    4|       |    path::{Path, PathBuf},
    5|       |    str::FromStr,
    6|       |};
    7|       |
    8|       |use crate::{get_thread_proc_id, string_conv::ToUtf8String, ProcessInfo};
    9|       |use anyhow::{anyhow, Result as AnyResult};
   10|       |use windows::core::Error;
   11|       |use windows::{
   12|       |    core::HSTRING,
   13|       |    Wdk::System::Threading::{NtQueryInformationProcess, ProcessBasicInformation},
   14|       |    Win32::{
   15|       |        Foundation::{CloseHandle, HANDLE, HWND, MAX_PATH, UNICODE_STRING},
   16|       |        Globalization::GetSystemDefaultLangID,
   17|       |        Graphics::Gdi::{
   18|       |            MonitorFromWindow, HMONITOR, MONITOR_DEFAULTTONEAREST, MONITOR_DEFAULTTONULL,
   19|       |        },
   20|       |        Storage::FileSystem::{
   21|       |            GetFileVersionInfoExW, GetFileVersionInfoSizeExW, VerQueryValueW, FILE_VER_GET_NEUTRAL,
   22|       |        },
   23|       |        System::{
   24|       |            Diagnostics::Debug::ReadProcessMemory,
   25|       |            ProcessStatus::GetModuleFileNameExW,
   26|       |            Threading::{
   27|       |                OpenProcess, PROCESS_BASIC_INFORMATION, PROCESS_QUERY_INFORMATION,
   28|       |                PROCESS_TERMINATE, PROCESS_VM_READ,
   29|       |            },
   30|       |        },
   31|       |        UI::WindowsAndMessaging::{GetClassNameW, GetWindowTextLengthW, GetWindowTextW},
   32|       |    },
   33|       |};
   34|       |
   35|       |const SZ_STRING_FILE_INFO: &str = "StringFileInfo";
   36|       |const SZ_PRODUCT_NAME: &str = "ProductName";
   37|       |const SZ_HEX_CODE_PAGE_ID_UNICODE: &str = "04B0";
   38|       |
   39|       |/// Retrieves the executable path and process ID associated with the given window handle.
   40|       |///
   41|       |/// # Arguments
   42|       |///
   43|       |/// * `handle` - The handle to the window.
   44|       |///
   45|       |/// # Returns
   46|       |///
   47|       |/// Returns a tuple containing the process ID and the path to the executable.
   48|       |///
   49|       |/// # Errors
   50|       |///
   51|       |/// Returns an error if there was a problem retrieving the executable path or process ID.
   52|    133|pub fn get_exe(handle: HWND) -> AnyResult<(u32, PathBuf)> {
   53|       |    let ProcessInfo {
   54|    133|        process_id: proc_id,
   55|       |        ..
   56|    133|    } = get_thread_proc_id(handle)?;
                                                ^0
   57|    133|    let h_proc = unsafe {
   58|    133|        OpenProcess(
   59|    133|            PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_TERMINATE,
   60|       |            false,
   61|    133|            proc_id,
   62|      0|        )?
   63|       |    };
   64|       |
   65|    133|    let exe = unsafe {
   66|    133|        let mut path = [0_u16; MAX_PATH as usize];
   67|       |        // HMODULE should be null, not default
   68|    133|        let res = GetModuleFileNameExW(Some(h_proc), None, &mut path);
   69|    133|        if res > 0 {
   70|    133|            Ok::<String, anyhow::Error>(path.as_ref().to_utf8())
   71|       |        } else {
   72|      0|            Err(Error::from_win32().into())
   73|       |        }
   74|      0|    }?;
   75|       |
   76|       |    unsafe {
   77|    133|        CloseHandle(h_proc)?;
                                         ^0
   78|       |    }
   79|       |
   80|    133|    Ok((proc_id, PathBuf::from_str(&exe)?))
                                                      ^0
   81|    133|}
   82|       |
   83|    133|pub fn get_title(handle: HWND) -> AnyResult<String> {
   84|    133|    let len = unsafe { GetWindowTextLengthW(handle) };
   85|    133|    if len == 0 {
   86|     43|        return Err(Error::from_win32().into());
   87|     90|    }
   88|       |
   89|     90|    let len = TryInto::<usize>::try_into(len)?;
                                                           ^0
   90|       |
   91|     90|    let mut title = vec![0_u16; len + 1];
   92|     90|    let get_title_res = unsafe { GetWindowTextW(handle, &mut title) };
   93|     90|    if get_title_res == 0 {
   94|      0|        return Err(Error::from_win32().into());
   95|     90|    }
   96|       |
   97|     90|    Ok(title.to_utf8())
   98|    133|}
   99|       |
  100|    272|pub fn get_window_class(handle: HWND) -> AnyResult<String> {
  101|    272|    let mut class = [0_u16; MAX_PATH as usize + 1];
  102|       |
  103|    272|    let len = unsafe { GetClassNameW(handle, &mut class) };
  104|    272|    if len == 0 {
  105|      0|        return Err(Error::from_win32().into());
  106|    272|    }
  107|       |
  108|    272|    Ok(class.as_ref().to_utf8())
  109|    272|}
  110|       |
  111|    133|pub fn get_product_name(full_exe: &Path) -> AnyResult<String> {
  112|    133|    let exe_wide = HSTRING::from(full_exe.as_os_str());
  113|       |
  114|    133|    let mut dummy = 0;
  115|    133|    let required_buffer_size =
  116|    133|        unsafe { GetFileVersionInfoSizeExW(FILE_VER_GET_NEUTRAL, &exe_wide, &mut dummy) };
  117|    133|    if required_buffer_size == 0 {
  118|      6|        return Err(Error::from_win32().into());
  119|    127|    }
  120|       |
  121|    127|    let mut buffer: Vec<u16> = vec![0; required_buffer_size as usize];
  122|       |    unsafe {
  123|    127|        GetFileVersionInfoExW(
  124|       |            FILE_VER_GET_NEUTRAL,
  125|    127|            &exe_wide,
  126|    127|            None,
  127|    127|            required_buffer_size,
  128|    127|            buffer.as_mut_ptr() as *mut _,
  129|      0|        )?;
  130|       |    }
  131|       |
  132|    127|    let lang_id = unsafe { GetSystemDefaultLangID() };
  133|    127|    let query_key: Vec<u16> = OsString::from(format!(
  134|    127|        "\\{}\\{}{}\\{}",
  135|    127|        SZ_STRING_FILE_INFO, lang_id, SZ_HEX_CODE_PAGE_ID_UNICODE, SZ_PRODUCT_NAME
  136|    127|    ))
  137|    127|    .encode_wide()
  138|    127|    .collect();
  139|    127|    let query_key = HSTRING::from_wide(&query_key);
  140|       |
  141|    127|    let mut pages_ptr: *mut u16 = std::ptr::null_mut();
  142|    127|    let mut pages_length = 0;
  143|       |
  144|       |    unsafe {
  145|    127|        VerQueryValueW(
  146|    127|            buffer.as_mut_ptr() as _,
  147|    127|            &query_key,
  148|    127|            &mut pages_ptr as *mut _ as _,
  149|    127|            &mut pages_length,
  150|       |        )
  151|    127|        .ok()?
  152|       |    };
  153|       |
  154|      0|    let chars_in_buf = required_buffer_size / (std::mem::size_of::<u16>() as u32);
  155|      0|    if pages_ptr.is_null() || chars_in_buf < pages_length {
  156|      0|        return Err(anyhow!("Invalid state"));
  157|      0|    }
  158|       |
  159|      0|    let product_name = unsafe { std::slice::from_raw_parts(pages_ptr, pages_length as usize - 1) };
  160|      0|    let product_name = String::from_utf16_lossy(product_name);
  161|       |
  162|      0|    Ok(product_name)
  163|    133|}
  164|       |
  165|    133|pub fn hwnd_to_monitor(handle: HWND) -> AnyResult<HMONITOR> {
  166|       |    unsafe {
  167|    133|        let res = MonitorFromWindow(handle, MONITOR_DEFAULTTONEAREST);
  168|    133|        if res.is_invalid() {
  169|      0|            return Err(Error::from_win32().into());
  170|    133|        }
  171|       |
  172|    133|        Ok(res)
  173|       |    }
  174|    133|}
  175|       |
  176|    133|pub fn intersects_with_multiple_monitors(handle: HWND) -> AnyResult<bool> {
  177|       |    unsafe {
  178|    133|        let res = MonitorFromWindow(handle, MONITOR_DEFAULTTONULL);
  179|       |
  180|    133|        Ok(!res.is_invalid())
  181|       |    }
  182|    133|}
  183|       |
  184|    133|pub fn get_command_line_args(wnd: HWND) -> AnyResult<String> {
  185|       |    let ProcessInfo {
  186|    133|        process_id: proc_id,
  187|       |        ..
  188|    133|    } = get_thread_proc_id(wnd)?;
                                             ^0
  189|       |
  190|    133|    let handle = unsafe {
  191|    133|        OpenProcess(
  192|    133|            PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, //
  193|       |            false,                                       //
  194|    133|            proc_id,                                     //
  195|      0|        )?
  196|       |    };
  197|       |
  198|    133|    if handle.is_invalid() {
  199|      0|        return Err(Error::from_win32().into());
  200|    133|    }
  201|       |
  202|    133|    let res = unsafe { get_command_line_args_priv(handle) };
  203|       |    unsafe {
  204|    133|        CloseHandle(handle)?;
                                         ^0
  205|       |    }
  206|       |
  207|    133|    res
  208|    133|}
  209|       |
  210|    133|unsafe fn get_command_line_args_priv(handle: HANDLE) -> AnyResult<String> {
  211|    133|    let mut pbi = PROCESS_BASIC_INFORMATION::default();
  212|       |    // get process information
  213|    133|    NtQueryInformationProcess(
  214|    133|        handle,
  215|       |        ProcessBasicInformation,
  216|    133|        &mut pbi as *mut _ as _,
  217|    133|        size_of_val(&pbi) as u32,
  218|    133|        std::ptr::null_mut(),
  219|       |    )
  220|    133|    .ok()?;
                       ^0
  221|       |
  222|       |    // use WinDbg "dt ntdll!_PEB" command and search for ProcessParameters offset to find the truth out
  223|    133|    let process_parameter_offset = 0x20;
  224|    133|    let command_line_offset = 0x70;
  225|       |
  226|       |    // read basic info to get ProcessParameters address, we only need the beginning of PEB
  227|    133|    let peb_size = process_parameter_offset + 8;
  228|    133|    let mut peb = vec![0u8; peb_size];
  229|       |
  230|       |    // read basic info to get CommandLine address, we only need the beginning of ProcessParameters
  231|    133|    let pp_size = command_line_offset + 16;
  232|    133|    let mut pp = vec![0u8; pp_size];
  233|       |
  234|       |    // read PEB
  235|    133|    ReadProcessMemory(
  236|    133|        handle,
  237|    133|        pbi.PebBaseAddress as _,
  238|    133|        peb.as_mut_ptr() as _,
  239|    133|        peb_size,
  240|    133|        None,
  241|      0|    )?;
  242|       |
  243|       |    // read ProcessParameters
  244|    133|    let parameters = *(peb.as_ptr().add(process_parameter_offset) as *const *const u8); // address in remote process adress space
  245|       |
  246|    133|    ReadProcessMemory(
  247|    133|        handle,               //
  248|    133|        parameters as _,      //
  249|    133|        pp.as_mut_ptr() as _, //
  250|    133|        pp_size,              //
  251|    133|        None,                 //
  252|      0|    )?;
  253|       |
  254|    133|    let ptr_cmd_line = pp
  255|    133|        .as_ptr() //
  256|    133|        .add(command_line_offset) as *const UNICODE_STRING;
  257|       |
  258|    133|    let maximum_len = (*ptr_cmd_line).MaximumLength as usize;
  259|    133|    let mut cmd_line = vec![0u16; maximum_len];
  260|       |
  261|    133|    ReadProcessMemory(
  262|    133|        handle,
  263|    133|        (*ptr_cmd_line).Buffer.as_ptr() as _,
  264|    133|        cmd_line.as_mut_ptr() as _,
  265|    133|        maximum_len,
  266|    133|        None,
  267|      0|    )?;
  268|       |
  269|    133|    Ok(cmd_line.to_utf8())
  270|    133|}

E:\Rust\libobs-rs\libobs-wrapper\src\context.rs:
    1|       |//! OBS Context Management
    2|       |//!
    3|       |//! This module provides the core functionality for interacting with libobs.
    4|       |//! The primary type is [`ObsContext`], which serves as the main entry point for
    5|       |//! all OBS operations.
    6|       |//!
    7|       |//! # Overview
    8|       |//!
    9|       |//! The `ObsContext` represents an initialized OBS environment and provides methods to:
   10|       |//! - Initialize the OBS runtime
   11|       |//! - Create and manage scenes
   12|       |//! - Create and manage outputs (recording, streaming)
   13|       |//! - Access and configure video/audio settings
   14|       |//! - Download and bootstrap OBS binaries at runtime
   15|       |//!
   16|       |//! # Thread Safety
   17|       |//!
   18|       |//! OBS operations must be performed on a single thread. The `ObsContext` handles
   19|       |//! this requirement by creating a dedicated thread for OBS operations and providing
   20|       |//! a thread-safe interface to interact with it.
   21|       |//!
   22|       |//! # Examples
   23|       |//!
   24|       |//! Creating a basic OBS context:
   25|       |//!
   26|       |//! ```no_run
   27|       |//! # fn example() -> Result<(), Box<dyn std::error::Error>> {
   28|       |//! use libobs_wrapper::context::ObsContext;
   29|       |//!
   30|       |//! let context = ObsContext::builder().start()?;
   31|       |//! # Ok(())
   32|       |//! # }
   33|       |//! ```
   34|       |//!
   35|       |//! For more examples refer to the [examples](https://github.com/joshprk/libobs-rs/tree/main/examples) directory in the repository.
   36|       |
   37|       |use std::{
   38|       |    collections::HashMap,
   39|       |    ffi::CStr,
   40|       |    pin::Pin,
   41|       |    sync::{Arc, Mutex, RwLock},
   42|       |    thread::ThreadId,
   43|       |};
   44|       |
   45|       |use crate::{
   46|       |    data::{output::ObsOutputRef, video::ObsVideoInfo, ObsData},
   47|       |    display::{ObsDisplayCreationData, ObsDisplayRef},
   48|       |    enums::{ObsLogLevel, ObsResetVideoStatus},
   49|       |    logger::LOGGER,
   50|       |    run_with_obs,
   51|       |    runtime::ObsRuntime,
   52|       |    scenes::ObsSceneRef,
   53|       |    sources::{ObsFilterRef, ObsSourceBuilder},
   54|       |    unsafe_send::Sendable,
   55|       |    utils::{FilterInfo, ObsError, ObsModules, ObsString, OutputInfo, StartupInfo},
   56|       |};
   57|       |use getters0::Getters;
   58|       |use libobs::{audio_output, obs_scene_t, video_output};
   59|       |
   60|       |lazy_static::lazy_static! {
   61|       |    pub(crate) static ref OBS_THREAD_ID: Mutex<Option<ThreadId>> = Mutex::new(None);
   62|       |}
   63|       |
   64|       |// Note to developers of this library:
   65|       |// I've updated everything in the ObsContext to use Rc and RefCell.
   66|       |// Then the obs context shutdown hook is given to each children of for example scenes and displays.
   67|       |// That way, obs is not shut down as long as there are still displays or scenes alive.
   68|       |// This is a bit of a hack, but it works would be glad to hear your thoughts on this.
   69|       |
   70|       |// Factor complex display map type out to satisfy clippy::type_complexity
   71|       |pub(crate) type DisplayMap = HashMap<usize, Arc<Pin<Box<ObsDisplayRef>>>>;
   72|       |
   73|       |/// Interface to the OBS context. Only one context
   74|       |/// can exist across all threads and any attempt to
   75|       |/// create a new context while there is an existing
   76|       |/// one will error.
   77|       |///
   78|       |/// Note that the order of the struct values is
   79|       |/// important! OBS is super specific about how it
   80|       |/// does everything. Things are freed early to
   81|       |/// latest from top to bottom.
   82|       |#[derive(Debug, Getters, Clone)]
   83|       |#[skip_new]
   84|       |pub struct ObsContext {
   85|       |    /// Stores startup info for safe-keeping. This
   86|       |    /// prevents any use-after-free as these do not
   87|       |    /// get copied in libobs.
   88|       |    startup_info: Arc<RwLock<StartupInfo>>,
   89|       |    #[get_mut]
   90|       |    // Key is display id, value is the display fixed in heap
   91|       |    displays: Arc<RwLock<DisplayMap>>,
   92|       |
   93|       |    /// Outputs must be stored in order to prevent
   94|       |    /// early freeing.
   95|       |    #[allow(dead_code)]
   96|       |    #[get_mut]
   97|       |    pub(crate) outputs: Arc<RwLock<Vec<ObsOutputRef>>>,
   98|       |
   99|       |    #[get_mut]
  100|       |    pub(crate) scenes: Arc<RwLock<Vec<ObsSceneRef>>>,
  101|       |
  102|       |    // Filters are on the level of the context because they are not scene specific
  103|       |    #[get_mut]
  104|       |    pub(crate) filters: Arc<RwLock<Vec<ObsFilterRef>>>,
  105|       |
  106|       |    #[skip_getter]
  107|       |    pub(crate) active_scene: Arc<RwLock<Option<Sendable<*mut obs_scene_t>>>>,
  108|       |
  109|       |    #[skip_getter]
  110|       |    pub(crate) _obs_modules: Arc<ObsModules>,
  111|       |
  112|       |    /// This struct must be the last element which makes sure
  113|       |    /// that everything else has been freed already before the runtime
  114|       |    /// shuts down
  115|       |    pub(crate) runtime: ObsRuntime,
  116|       |}
  117|       |
  118|       |impl ObsContext {
  119|      1|    pub fn builder() -> StartupInfo {
  120|      1|        StartupInfo::new()
  121|      1|    }
  122|       |
  123|       |    /// Initializes libobs on the current thread.
  124|       |    ///
  125|       |    /// Note that there can be only one ObsContext
  126|       |    /// initialized at a time. This is because
  127|       |    /// libobs is not completely thread-safe.
  128|       |    ///
  129|       |    /// Also note that this might leak a very tiny
  130|       |    /// amount of memory. As a result, it is
  131|       |    /// probably a good idea not to restart the
  132|       |    /// OBS context repeatedly over a very long
  133|       |    /// period of time. Unfortunately the memory
  134|       |    /// leak is caused by a bug in libobs itself.
  135|       |    ///
  136|       |    /// If the `bootstrapper` feature is enabled, and ObsContextReturn::Restart is returned,
  137|       |    /// the application must be restarted to apply the updates and initialization can not continue.
  138|      9|    pub fn new(info: StartupInfo) -> Result<ObsContext, ObsError> {
  139|       |        // Spawning runtime, I'll keep this as function for now
  140|      9|        let (runtime, obs_modules, info) = ObsRuntime::startup(info)?;
                                                                                  ^0
  141|       |
  142|      9|        Ok(Self {
  143|      9|            _obs_modules: Arc::new(obs_modules),
  144|      9|            active_scene: Default::default(),
  145|      9|            displays: Default::default(),
  146|      9|            outputs: Default::default(),
  147|      9|            scenes: Default::default(),
  148|      9|            filters: Default::default(),
  149|      9|            runtime,
  150|      9|            startup_info: Arc::new(RwLock::new(info)),
  151|      9|        })
  152|      9|    }
  153|       |
  154|      0|    pub fn get_version(&self) -> Result<String, ObsError> {
  155|      0|        let res = run_with_obs!(self.runtime, || unsafe {
  156|      0|            let version = libobs::obs_get_version_string();
  157|      0|            let version_cstr = CStr::from_ptr(version);
  158|       |
  159|      0|            version_cstr.to_string_lossy().into_owned()
  160|      0|        })?;
  161|       |
  162|      0|        Ok(res)
  163|      0|    }
  164|       |
  165|      0|    pub fn log(&self, level: ObsLogLevel, msg: &str) {
  166|      0|        let mut log = LOGGER.lock().unwrap();
  167|      0|        log.log(level, msg.to_string());
  168|      0|    }
  169|       |
  170|       |    /// Resets the OBS video context. This is often called
  171|       |    /// when one wants to change a setting related to the
  172|       |    /// OBS video info sent on startup.
  173|       |    ///
  174|       |    /// It is important to register your video encoders to
  175|       |    /// a video handle after you reset the video context
  176|       |    /// if you are using a video handle other than the
  177|       |    /// main video handle. For convenience, this function
  178|       |    /// sets all video encoder back to the main video handler
  179|       |    /// by default.
  180|       |    ///
  181|       |    /// Note that you cannot reset the graphics module
  182|       |    /// without destroying the entire OBS context. Trying
  183|       |    /// so will result in an error.
  184|      6|    pub fn reset_video(&mut self, ovi: ObsVideoInfo) -> Result<(), ObsError> {
  185|       |        // You cannot change the graphics module without
  186|       |        // completely destroying the entire OBS context.
  187|      6|        if self
  188|      6|            .startup_info
  189|      6|            .read()
  190|      6|            .map_err(|_| {
                                       ^0
  191|      0|                ObsError::LockError("Failed to acquire read lock on startup info".to_string())
  192|      0|            })?
  193|       |            .obs_video_info
  194|      6|            .graphics_module()
  195|      6|            != ovi.graphics_module()
  196|       |        {
  197|      0|            return Err(ObsError::ResetVideoFailureGraphicsModule);
  198|      6|        }
  199|       |
  200|      6|        let has_active_outputs = {
  201|      6|            self.outputs
  202|      6|                .read()
  203|      6|                .map_err(|_| {
                                           ^0
  204|      0|                    ObsError::LockError("Failed to acquire read lock on outputs".to_string())
  205|      0|                })?
  206|      6|                .iter()
  207|      6|                .any(|output| output.is_active().unwrap_or_default())
  208|       |        };
  209|       |
  210|      6|        if has_active_outputs {
  211|      0|            return Err(ObsError::ResetVideoFailureOutputActive);
  212|      6|        }
  213|       |
  214|       |        // Resets the video context. Note that this
  215|       |        // is similar to Self::reset_video, but it
  216|       |        // does not call that function because the
  217|       |        // ObsContext struct is not created yet,
  218|       |        // and also because there is no need to free
  219|       |        // anything tied to the OBS context.
  220|      6|        let vid_ptr = Sendable(ovi.as_ptr());
  221|      6|        let reset_video_status = run_with_obs!(self.runtime, (vid_ptr), move || unsafe {
  222|      6|            libobs::obs_reset_video(vid_ptr)
  223|      6|        })?;
                        ^0
  224|       |
  225|      6|        let reset_video_status = num_traits::FromPrimitive::from_i32(reset_video_status);
  226|       |
  227|      6|        let reset_video_status = match reset_video_status {
  228|      6|            Some(x) => x,
  229|      0|            None => ObsResetVideoStatus::Failure,
  230|       |        };
  231|       |
  232|      6|        if reset_video_status == ObsResetVideoStatus::Success {
  233|      6|            self.startup_info
  234|      6|                .write()
  235|      6|                .map_err(|_| {
                                           ^0
  236|      0|                    ObsError::LockError("Failed to acquire write lock on startup info".to_string())
  237|      0|                })?
  238|      6|                .obs_video_info = ovi;
  239|       |
  240|      6|            Ok(())
  241|       |        } else {
  242|      0|            Err(ObsError::ResetVideoFailure(reset_video_status))
  243|       |        }
  244|      6|    }
  245|       |
  246|       |    /// Returns a pointer to the video output.
  247|       |    ///
  248|       |    /// # Safety
  249|       |    /// This function is unsafe because it returns a raw pointer that must be handled carefully. Only use this pointer if you REALLY know what you are doing.
  250|      0|    pub unsafe fn get_video_ptr(&self) -> Result<Sendable<*mut video_output>, ObsError> {
  251|       |        // Removed safeguards here because ptr are not sendable and this OBS context should never be used across threads
  252|      0|        run_with_obs!(self.runtime, || unsafe {
  253|      0|            Sendable(libobs::obs_get_video())
  254|      0|        })
  255|      0|    }
  256|       |
  257|       |    /// Returns a pointer to the audio output.
  258|       |    ///
  259|       |    /// # Safety
  260|       |    /// This function is unsafe because it returns a raw pointer that must be handled carefully. Only use this pointer if you REALLY know what you are doing.
  261|      0|    pub unsafe fn get_audio_ptr(&self) -> Result<Sendable<*mut audio_output>, ObsError> {
  262|       |        // Removed safeguards here because ptr are not sendable and this OBS context should never be used across threads
  263|      0|        run_with_obs!(self.runtime, || unsafe {
  264|      0|            Sendable(libobs::obs_get_audio())
  265|      0|        })
  266|      0|    }
  267|       |
  268|     33|    pub fn data(&self) -> Result<ObsData, ObsError> {
  269|     33|        ObsData::new(self.runtime.clone())
  270|     33|    }
  271|       |
  272|      8|    pub fn output(&mut self, info: OutputInfo) -> Result<ObsOutputRef, ObsError> {
  273|      8|        let output = ObsOutputRef::new(info, self.runtime.clone());
  274|       |
  275|      8|        match output {
  276|      8|            Ok(x) => {
  277|      8|                let tmp = x.clone();
  278|      8|                self.outputs
  279|      8|                    .write()
  280|      8|                    .map_err(|_| {
                                               ^0
  281|      0|                        ObsError::LockError("Failed to acquire write lock on outputs".to_string())
  282|      0|                    })?
  283|      8|                    .push(x);
  284|      8|                Ok(tmp)
  285|       |            }
  286|       |
  287|      0|            Err(x) => Err(x),
  288|       |        }
  289|      8|    }
  290|       |
  291|      0|    pub fn obs_filter(&mut self, info: FilterInfo) -> Result<ObsFilterRef, ObsError> {
  292|      0|        let filter = ObsFilterRef::new(
  293|      0|            info.id,
  294|      0|            info.name,
  295|      0|            info.settings,
  296|      0|            info.hotkey_data,
  297|      0|            self.runtime.clone(),
  298|       |        );
  299|       |
  300|      0|        match filter {
  301|      0|            Ok(x) => {
  302|      0|                let tmp = x.clone();
  303|      0|                self.filters
  304|      0|                    .write()
  305|      0|                    .map_err(|_| {
  306|      0|                        ObsError::LockError("Failed to acquire write lock on filters".to_string())
  307|      0|                    })?
  308|      0|                    .push(x);
  309|      0|                Ok(tmp)
  310|       |            }
  311|       |
  312|      0|            Err(x) => Err(x),
  313|       |        }
  314|      0|    }
  315|       |
  316|       |    /// Creates a new display and returns its ID.
  317|      0|    pub fn display(
  318|      0|        &mut self,
  319|      0|        data: ObsDisplayCreationData,
  320|      0|    ) -> Result<Pin<Box<ObsDisplayRef>>, ObsError> {
  321|      0|        let display = ObsDisplayRef::new(data, self.runtime.clone())
  322|      0|            .map_err(|e| ObsError::DisplayCreationError(e.to_string()))?;
  323|       |
  324|      0|        let display_clone = display.clone();
  325|       |
  326|      0|        let id = display.id();
  327|      0|        self.displays
  328|      0|            .write()
  329|      0|            .map_err(|_| {
  330|      0|                ObsError::LockError("Failed to acquire write lock on displays".to_string())
  331|      0|            })?
  332|      0|            .insert(id, Arc::new(display));
  333|      0|        Ok(display_clone)
  334|      0|    }
  335|       |
  336|      0|    pub fn remove_display(&mut self, display: &ObsDisplayRef) -> Result<(), ObsError> {
  337|      0|        self.remove_display_by_id(display.id())
  338|      0|    }
  339|       |
  340|      0|    pub fn remove_display_by_id(&mut self, id: usize) -> Result<(), ObsError> {
  341|      0|        self.displays
  342|      0|            .write()
  343|      0|            .map_err(|_| {
  344|      0|                ObsError::LockError("Failed to acquire write lock on displays".to_string())
  345|      0|            })?
  346|      0|            .remove(&id);
  347|       |
  348|      0|        Ok(())
  349|      0|    }
  350|       |
  351|      0|    pub fn get_display_by_id(
  352|      0|        &self,
  353|      0|        id: usize,
  354|      0|    ) -> Result<Option<Arc<Pin<Box<ObsDisplayRef>>>>, ObsError> {
  355|      0|        let d = self
  356|      0|            .displays
  357|      0|            .read()
  358|      0|            .map_err(|_| {
  359|      0|                ObsError::LockError("Failed to acquire read lock on displays".to_string())
  360|      0|            })?
  361|      0|            .get(&id)
  362|      0|            .cloned();
  363|       |
  364|      0|        Ok(d)
  365|      0|    }
  366|       |
  367|      0|    pub fn get_output(&mut self, name: &str) -> Result<Option<ObsOutputRef>, ObsError> {
  368|      0|        let o = self
  369|      0|            .outputs
  370|      0|            .read()
  371|      0|            .map_err(|_| ObsError::LockError("Failed to acquire read lock on outputs".to_string()))?
  372|      0|            .iter()
  373|      0|            .find(|x| x.name().to_string().as_str() == name)
  374|      0|            .cloned();
  375|       |
  376|      0|        Ok(o)
  377|      0|    }
  378|       |
  379|      0|    pub fn update_output(&mut self, name: &str, settings: ObsData) -> Result<(), ObsError> {
  380|      0|        match self
  381|      0|            .outputs
  382|      0|            .write()
  383|      0|            .map_err(|_| {
  384|      0|                ObsError::LockError("Failed to acquire write lock on outputs".to_string())
  385|      0|            })?
  386|      0|            .iter_mut()
  387|      0|            .find(|x| x.name().to_string().as_str() == name)
  388|       |        {
  389|      0|            Some(output) => output.update_settings(settings),
  390|      0|            None => Err(ObsError::OutputNotFound),
  391|       |        }
  392|      0|    }
  393|       |
  394|      0|    pub fn get_filter(&mut self, name: &str) -> Result<Option<ObsFilterRef>, ObsError> {
  395|      0|        let f = self
  396|      0|            .filters
  397|      0|            .read()
  398|      0|            .map_err(|_| ObsError::LockError("Failed to acquire read lock on filters".to_string()))?
  399|      0|            .iter()
  400|      0|            .find(|x| x.name().to_string().as_str() == name)
  401|      0|            .cloned();
  402|       |
  403|      0|        Ok(f)
  404|      0|    }
  405|       |
  406|      6|    pub fn scene<T: Into<ObsString> + Send + Sync>(
  407|      6|        &mut self,
  408|      6|        name: T,
  409|      6|    ) -> Result<ObsSceneRef, ObsError> {
  410|      6|        let scene = ObsSceneRef::new(name.into(), self.active_scene.clone(), self.runtime.clone())?;
                                                                                                                ^0
  411|       |
  412|      6|        let tmp = scene.clone();
  413|      6|        self.scenes
  414|      6|            .write()
  415|      6|            .map_err(|_| ObsError::LockError("Failed to acquire write lock on scenes".to_string()))?
                                                           ^0                                       ^0           ^0
  416|      6|            .push(scene);
  417|       |
  418|      6|        Ok(tmp)
  419|      6|    }
  420|       |
  421|      0|    pub fn get_scene(&mut self, name: &str) -> Result<Option<ObsSceneRef>, ObsError> {
  422|      0|        let r = self
  423|      0|            .scenes
  424|      0|            .read()
  425|      0|            .map_err(|_| ObsError::LockError("Failed to acquire read lock on scenes".to_string()))?
  426|      0|            .iter()
  427|      0|            .find(|x| x.name().to_string().as_str() == name)
  428|      0|            .cloned();
  429|      0|        Ok(r)
  430|      0|    }
  431|       |
  432|      5|    pub fn source_builder<T: ObsSourceBuilder, K: Into<ObsString> + Send + Sync>(
  433|      5|        &self,
  434|      5|        name: K,
  435|      5|    ) -> Result<T, ObsError> {
  436|      5|        T::new(name.into(), self.runtime.clone())
  437|      5|    }
  438|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\crash_handler\dialog.rs:
    1|       |use arboard::Clipboard;
    2|       |use dialog::{Choice, DialogBox};
    3|       |
    4|       |use super::ObsCrashHandler;
    5|       |
    6|       |pub struct DialogCrashHandler {
    7|       |    _private: (),
    8|       |}
    9|       |
   10|       |impl Default for DialogCrashHandler {
   11|      0|    fn default() -> Self {
   12|      0|        Self::new()
   13|      0|    }
   14|       |}
   15|       |
   16|       |impl DialogCrashHandler {
   17|      0|    pub fn new() -> Self {
   18|      0|        Self { _private: () }
   19|      0|    }
   20|       |}
   21|       |
   22|       |impl ObsCrashHandler for DialogCrashHandler {
   23|      0|    fn handle_crash(&self, message: String) {
   24|      0|        eprintln!("OBS crashed: {}", message);
   25|      0|        let res =
   26|      0|            dialog::Question::new("OBS has crashed. Do you want to copy the error to clipboard?")
   27|      0|                .title("OBS Crash Handler")
   28|      0|                .show();
   29|       |
   30|      0|        if let Err(e) = res {
   31|      0|            eprintln!("Failed to show crash handler dialog: {e:?}");
   32|      0|            return;
   33|      0|        }
   34|       |
   35|      0|        let res = res.unwrap();
   36|      0|        if res == Choice::No {
   37|      0|            return;
   38|      0|        }
   39|       |
   40|      0|        let clipboard = Clipboard::new();
   41|      0|        if let Err(e) = clipboard {
   42|      0|            eprintln!("Failed to create clipboard: {e:?}");
   43|      0|            return;
   44|      0|        }
   45|       |
   46|      0|        let mut clipboard = clipboard.unwrap();
   47|      0|        if let Err(e) = clipboard.set_text(message.clone()) {
   48|      0|            eprintln!("Failed to copy crash message to clipboard: {e:?}");
   49|      0|        }
   50|      0|    }
   51|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\crash_handler\mod.rs:
    1|       |use std::{ffi::c_void, sync::Mutex};
    2|       |
    3|       |use lazy_static::lazy_static;
    4|       |
    5|       |#[cfg(feature = "dialog_crash_handler")]
    6|       |pub mod dialog;
    7|       |
    8|       |pub trait ObsCrashHandler: Send {
    9|       |    fn handle_crash(&self, message: String);
   10|       |}
   11|       |
   12|       |pub struct ConsoleCrashHandler {
   13|       |    _private: (),
   14|       |}
   15|       |
   16|       |impl Default for ConsoleCrashHandler {
   17|      0|    fn default() -> Self {
   18|      0|        Self::new()
   19|      0|    }
   20|       |}
   21|       |
   22|       |impl ConsoleCrashHandler {
   23|      0|    pub fn new() -> Self {
   24|      0|        Self { _private: () }
   25|      0|    }
   26|       |}
   27|       |impl ObsCrashHandler for ConsoleCrashHandler {
   28|      0|    fn handle_crash(&self, message: String) {
   29|      0|        eprintln!("OBS crashed: {}", message);
   30|      0|    }
   31|       |}
   32|       |
   33|       |lazy_static! {
   34|       |    /// We are using this as global variable because there can only be one obs context
   35|       |    pub static ref CRASH_HANDLER: Mutex<Box<dyn ObsCrashHandler>> = {
   36|       |        #[cfg(feature="dialog_crash_handler")]
   37|       |        {
   38|       |            Mutex::new(Box::new(dialog::DialogCrashHandler::new()))
   39|       |        }
   40|       |        #[cfg(not(feature="dialog_crash_handler"))]
   41|       |        {
   42|       |            Mutex::new(Box::new(ConsoleCrashHandler {}))
   43|       |        }
   44|       |    };
   45|       |}
   46|       |
   47|      0|pub(crate) unsafe extern "C" fn main_crash_handler(
   48|      0|    format: *const i8,
   49|      0|    args: *mut i8,
   50|      0|    _params: *mut c_void,
   51|      0|) {
   52|      0|    let res = vsprintf::vsprintf(format, args);
   53|      0|    if res.is_err() {
   54|      0|        eprintln!("Failed to format crash handler message");
   55|      0|        return;
   56|      0|    }
   57|       |
   58|      0|    let res = res.unwrap();
   59|      0|    CRASH_HANDLER.lock().unwrap().handle_crash(res);
   60|      0|}

E:\Rust\libobs-rs\libobs-wrapper\src\data\audio.rs:
    1|       |use libobs::obs_audio_info2;
    2|       |
    3|       |use crate::{
    4|       |    enums::{ObsSamplesPerSecond, ObsSpeakerLayout},
    5|       |    unsafe_send::Sendable,
    6|       |};
    7|       |
    8|       |/// Information passed to libobs when attempting to
    9|       |/// reset the audio context using `obs_reset_audio2`.
   10|       |#[repr(C)]
   11|       |#[derive(Clone, Debug, PartialEq, Eq)]
   12|       |pub struct ObsAudioInfo {
   13|       |    samples_per_sec: ObsSamplesPerSecond,
   14|       |    speakers: ObsSpeakerLayout,
   15|       |    max_buffering_ms: u32,
   16|       |    fixed_buffering: bool,
   17|       |}
   18|       |
   19|       |impl ObsAudioInfo {
   20|      0|    pub fn new(
   21|      0|        samples_per_second: ObsSamplesPerSecond,
   22|      0|        speakers: ObsSpeakerLayout,
   23|      0|        max_buffering_ms: u32,
   24|      0|        fixed_buffering: bool,
   25|      0|    ) -> Self {
   26|      0|        Self {
   27|      0|            samples_per_sec: samples_per_second,
   28|      0|            speakers,
   29|      0|            max_buffering_ms,
   30|      0|            fixed_buffering,
   31|      0|        }
   32|      0|    }
   33|       |
   34|      0|    pub fn new_low_latency(
   35|      0|        samples_per_second: ObsSamplesPerSecond,
   36|      0|        speakers: ObsSpeakerLayout,
   37|      0|    ) -> Self {
   38|      0|        Self::new(samples_per_second, speakers, 20, true)
   39|      0|    }
   40|       |
   41|      9|    pub fn as_ptr(&self) -> Sendable<*const obs_audio_info2> {
   42|      9|        Sendable(self as *const Self as *const obs_audio_info2)
   43|      9|    }
   44|       |}
   45|       |
   46|       |impl Default for ObsAudioInfo {
   47|      9|    fn default() -> Self {
   48|      9|        Self {
   49|      9|            samples_per_sec: ObsSamplesPerSecond::F44100,
   50|      9|            speakers: ObsSpeakerLayout::Stereo,
   51|      9|            max_buffering_ms: 0,
   52|      9|            fixed_buffering: false,
   53|      9|        }
   54|      9|    }
   55|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\immutable.rs:
    1|       |use std::{ffi::CStr, sync::Arc};
    2|       |
    3|       |use libobs::obs_data_t;
    4|       |
    5|       |use crate::{
    6|       |    impl_obs_drop, run_with_obs, runtime::ObsRuntime, unsafe_send::Sendable, utils::ObsError,
    7|       |};
    8|       |
    9|       |use super::{ObsData, _ObsDataDropGuard};
   10|       |
   11|       |#[derive(Clone, Debug)]
   12|       |/// Immutable wrapper around obs_data_t to be prevent modification and to be used in creation of other objects.
   13|       |/// This should not be updated directly using the pointer, but instead through the corresponding update methods on the holder of this data.
   14|       |pub struct ImmutableObsData {
   15|       |    ptr: Sendable<*mut obs_data_t>,
   16|       |    runtime: ObsRuntime,
   17|       |    _drop_guard: Arc<_ObsDataDropGuard>,
   18|       |}
   19|       |
   20|       |impl ImmutableObsData {
   21|      0|    pub fn new(runtime: &ObsRuntime) -> Result<Self, ObsError> {
   22|      0|        let ptr = run_with_obs!(runtime, move || unsafe {
   23|      0|            Sendable(libobs::obs_data_create())
   24|      0|        })?;
   25|       |
   26|      0|        Ok(ImmutableObsData {
   27|      0|            ptr: ptr.clone(),
   28|      0|            runtime: runtime.clone(),
   29|      0|            _drop_guard: Arc::new(_ObsDataDropGuard {
   30|      0|                obs_data: ptr,
   31|      0|                runtime: runtime.clone(),
   32|      0|            }),
   33|      0|        })
   34|      0|    }
   35|       |
   36|      0|    pub fn from_raw(data: Sendable<*mut obs_data_t>, runtime: ObsRuntime) -> Self {
   37|      0|        ImmutableObsData {
   38|      0|            ptr: data.clone(),
   39|      0|            runtime: runtime.clone(),
   40|      0|            _drop_guard: Arc::new(_ObsDataDropGuard {
   41|      0|                obs_data: data.clone(),
   42|      0|                runtime,
   43|      0|            }),
   44|      0|        }
   45|      0|    }
   46|       |
   47|      0|    pub fn to_mutable(&self) -> Result<ObsData, ObsError> {
   48|      0|        let ptr = self.ptr.clone();
   49|      0|        let json = run_with_obs!(self.runtime, (ptr), move || unsafe {
   50|      0|            Sendable(libobs::obs_data_get_json(ptr))
   51|      0|        })?;
   52|       |
   53|      0|        let json = unsafe { CStr::from_ptr(json.0) }
   54|      0|            .to_str()
   55|      0|            .map_err(|_| ObsError::JsonParseError)?
   56|      0|            .to_string();
   57|       |
   58|      0|        ObsData::from_json(json.as_ref(), self.runtime.clone())
   59|      0|    }
   60|       |
   61|     10|    pub fn as_ptr(&self) -> Sendable<*mut obs_data_t> {
   62|     10|        self.ptr.clone()
   63|     10|    }
   64|       |}
   65|       |
   66|       |impl From<ObsData> for ImmutableObsData {
   67|     10|    fn from(mut data: ObsData) -> Self {
   68|       |        // Set to null pointer to prevent double free
   69|     10|        let ptr = data.obs_data.0;
   70|       |
   71|     10|        data.obs_data.0 = std::ptr::null_mut();
   72|     10|        ImmutableObsData {
   73|     10|            ptr: Sendable(ptr),
   74|     10|            runtime: data.runtime.clone(),
   75|     10|            _drop_guard: data._drop_guard,
   76|     10|        }
   77|     10|    }
   78|       |}
   79|       |
   80|       |impl_obs_drop!(ImmutableObsData, (ptr), move || unsafe {
   81|     10|    libobs::obs_data_release(ptr)
   82|     10|});

E:\Rust\libobs-rs\libobs-wrapper\src\data\mod.rs:
    1|       |use std::{
    2|       |    ffi::{CStr, CString},
    3|       |    sync::Arc,
    4|       |};
    5|       |
    6|       |use crate::{
    7|       |    impl_obs_drop, run_with_obs,
    8|       |    runtime::ObsRuntime,
    9|       |    unsafe_send::Sendable,
   10|       |    utils::{ObsError, ObsString},
   11|       |};
   12|       |use libobs::obs_data;
   13|       |
   14|       |pub mod audio;
   15|       |pub mod immutable;
   16|       |mod lib_support;
   17|       |pub mod output;
   18|       |pub mod properties;
   19|       |pub mod video;
   20|       |pub use lib_support::*;
   21|       |mod updater;
   22|       |pub use updater::*;
   23|       |
   24|       |#[derive(Debug)]
   25|       |pub(crate) struct _ObsDataDropGuard {
   26|       |    obs_data: Sendable<*mut obs_data>,
   27|       |    pub(crate) runtime: ObsRuntime,
   28|       |}
   29|       |
   30|       |/// Contains `obs_data` and its related strings. Note that
   31|       |/// this struct prevents string pointers from being freed
   32|       |/// by keeping them owned.
   33|       |/// Cloning `ObsData` is blocking and will create a new `ObsData` instance. Recommended is to use `ObsData::full_clone()` instead.
   34|       |/// ## Panics
   35|       |/// If the underlying JSON representation can not be parsed.
   36|       |//NOTE: Update: The strings are actually copied by obs itself, we don't need to store them
   37|       |#[derive(Debug)]
   38|       |pub struct ObsData {
   39|       |    obs_data: Sendable<*mut obs_data>,
   40|       |    pub(crate) runtime: ObsRuntime,
   41|       |    pub(crate) _drop_guard: Arc<_ObsDataDropGuard>,
   42|       |}
   43|       |
   44|       |impl ObsData {
   45|       |    /// Creates a new empty `ObsData` wrapper for the
   46|       |    /// libobs `obs_data` data structure.
   47|       |    ///
   48|       |    /// `ObsData` can then be populated using the set
   49|       |    /// functions, which take ownership of the
   50|       |    /// `ObsString` types to prevent them from being
   51|       |    /// dropped prematurely. This makes it safer than
   52|       |    /// using `obs_data` directly from libobs.
   53|     47|    pub fn new(runtime: ObsRuntime) -> Result<Self, ObsError> {
   54|     47|        let obs_data = run_with_obs!(runtime, move || unsafe {
   55|     47|            Sendable(libobs::obs_data_create())
   56|     47|        })?;
                        ^0
   57|       |
   58|     47|        Ok(ObsData {
   59|     47|            obs_data: obs_data.clone(),
   60|     47|            runtime: runtime.clone(),
   61|     47|            _drop_guard: Arc::new(_ObsDataDropGuard { obs_data, runtime }),
   62|     47|        })
   63|     47|    }
   64|       |
   65|     20|    pub fn bulk_update(&mut self) -> ObsDataUpdater {
   66|     20|        ObsDataUpdater {
   67|     20|            changes: Vec::new(),
   68|     20|            obs_data: self.obs_data.clone(),
   69|     20|            _drop_guard: self._drop_guard.clone(),
   70|     20|        }
   71|     20|    }
   72|       |
   73|       |    /// Returns a pointer to the raw `obs_data`
   74|       |    /// represented by `ObsData`.
   75|     33|    pub fn as_ptr(&self) -> Sendable<*mut obs_data> {
   76|     33|        self.obs_data.clone()
   77|     33|    }
   78|       |
   79|       |    /// Sets a string in `obs_data` and stores it so
   80|       |    /// it in `ObsData` does not get freed.
   81|     34|    pub fn set_string<T: Into<ObsString> + Send + Sync, K: Into<ObsString> + Send + Sync>(
   82|     34|        &mut self,
   83|     34|        key: T,
   84|     34|        value: K,
   85|     34|    ) -> Result<&mut Self, ObsError> {
   86|     34|        let key = key.into();
   87|     34|        let value = value.into();
   88|       |
   89|     34|        let key_ptr = key.as_ptr();
   90|     34|        let value_ptr = value.as_ptr();
   91|     34|        let data_ptr = self.obs_data.clone();
   92|       |
   93|     34|        run_with_obs!(
   94|     34|            self.runtime,
   95|       |            (data_ptr, key_ptr, value_ptr),
   96|     34|            move || unsafe { libobs::obs_data_set_string(data_ptr, key_ptr, value_ptr) }
   97|      0|        )?;
   98|       |
   99|     34|        Ok(self)
  100|     34|    }
  101|       |
  102|       |    /// Sets an int in `obs_data` and stores the key
  103|       |    /// in `ObsData` so it does not get freed.
  104|     19|    pub fn set_int<T: Into<ObsString> + Sync + Send>(
  105|     19|        &mut self,
  106|     19|        key: T,
  107|     19|        value: i64,
  108|     19|    ) -> Result<&mut Self, ObsError> {
  109|     19|        let key = key.into();
  110|       |
  111|     19|        let key_ptr = key.as_ptr();
  112|     19|        let data_ptr = self.obs_data.clone();
  113|       |
  114|     19|        run_with_obs!(self.runtime, (key_ptr, data_ptr), move || unsafe {
  115|     19|            libobs::obs_data_set_int(data_ptr, key_ptr, value);
  116|     19|        })?;
                        ^0
  117|       |
  118|     19|        Ok(self)
  119|     19|    }
  120|       |
  121|       |    /// Sets a bool in `obs_data` and stores the key
  122|       |    /// in `ObsData` so it does not get freed.
  123|     12|    pub fn set_bool<T: Into<ObsString> + Sync + Send>(
  124|     12|        &mut self,
  125|     12|        key: T,
  126|     12|        value: bool,
  127|     12|    ) -> Result<&mut Self, ObsError> {
  128|     12|        let key = key.into();
  129|       |
  130|     12|        let key_ptr = key.as_ptr();
  131|     12|        let data_ptr = self.obs_data.clone();
  132|     12|        run_with_obs!(self.runtime, (key_ptr, data_ptr), move || unsafe {
  133|     12|            libobs::obs_data_set_bool(data_ptr, key_ptr, value);
  134|     12|        })?;
                        ^0
  135|       |
  136|     12|        Ok(self)
  137|     12|    }
  138|       |
  139|       |    /// Sets a double in `obs_data` and stores the key
  140|       |    /// in `ObsData` so it does not get freed.
  141|      0|    pub fn set_double<T: Into<ObsString> + Sync + Send>(
  142|      0|        &mut self,
  143|      0|        key: T,
  144|      0|        value: f64,
  145|      0|    ) -> Result<&mut Self, ObsError> {
  146|      0|        let key = key.into();
  147|       |
  148|      0|        let key_ptr = key.as_ptr();
  149|      0|        let data_ptr = self.obs_data.clone();
  150|       |
  151|      0|        run_with_obs!(self.runtime, (key_ptr, data_ptr), move || unsafe {
  152|      0|            libobs::obs_data_set_double(data_ptr, key_ptr, value);
  153|      0|        })?;
  154|       |
  155|      0|        Ok(self)
  156|      0|    }
  157|       |
  158|      2|    pub fn from_json(json: &str, runtime: ObsRuntime) -> Result<Self, ObsError> {
  159|      2|        let cstr = CString::new(json).map_err(|_| ObsError::JsonParseError)?;
                                                                                         ^0
  160|       |
  161|      2|        let cstr_ptr = Sendable(cstr.as_ptr());
  162|      2|        let result = run_with_obs!(runtime, (cstr_ptr), move || unsafe {
  163|      2|            Sendable(libobs::obs_data_create_from_json(cstr_ptr))
  164|      2|        })?;
                        ^0
  165|       |
  166|      2|        if result.0.is_null() {
  167|      0|            return Err(ObsError::JsonParseError);
  168|      2|        }
  169|       |
  170|      2|        Ok(ObsData {
  171|      2|            obs_data: result.clone(),
  172|      2|            runtime: runtime.clone(),
  173|      2|            _drop_guard: Arc::new(_ObsDataDropGuard {
  174|      2|                obs_data: result,
  175|      2|                runtime,
  176|      2|            }),
  177|      2|        })
  178|      2|    }
  179|       |
  180|      2|    pub fn get_json(&self) -> Result<String, ObsError> {
  181|      2|        let data_ptr = self.obs_data.clone();
  182|      2|        let ptr = run_with_obs!(self.runtime, (data_ptr), move || unsafe {
  183|      2|            Sendable(libobs::obs_data_get_json(data_ptr))
  184|      2|        })?;
                        ^0
  185|       |
  186|      2|        if ptr.0.is_null() {
  187|      0|            return Err(ObsError::NullPointer);
  188|      2|        }
  189|       |
  190|      2|        let ptr = unsafe { CStr::from_ptr(ptr.0) };
  191|      2|        let ptr = ptr.to_str().map_err(|_| ObsError::JsonParseError)?;
                                                                                  ^0
  192|       |
  193|      2|        Ok(ptr.to_string())
  194|      2|    }
  195|       |}
  196|       |
  197|       |impl_obs_drop!(_ObsDataDropGuard, (obs_data), move || unsafe {
  198|     49|    libobs::obs_data_release(obs_data)
  199|     49|});
  200|       |
  201|       |impl Clone for ObsData {
  202|      2|    fn clone(&self) -> Self {
  203|      2|        let json = self.get_json().unwrap();
  204|      2|        Self::from_json(json.as_str(), self.runtime.clone()).unwrap()
  205|      2|    }
  206|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\output\mod.rs:
    1|       |use std::sync::{Arc, RwLock};
    2|       |use std::{ffi::CStr, ptr};
    3|       |
    4|       |use anyhow::bail;
    5|       |use getters0::Getters;
    6|       |use libobs::obs_output;
    7|       |
    8|       |use crate::enums::ObsOutputStopSignal;
    9|       |use crate::runtime::ObsRuntime;
   10|       |use crate::unsafe_send::Sendable;
   11|       |use crate::utils::{AudioEncoderInfo, OutputInfo, VideoEncoderInfo};
   12|       |use crate::{impl_obs_drop, impl_signal_manager, run_with_obs};
   13|       |
   14|       |use crate::{
   15|       |    encoders::{audio::ObsAudioEncoder, video::ObsVideoEncoder},
   16|       |    utils::{ObsError, ObsString},
   17|       |};
   18|       |
   19|       |use super::ObsData;
   20|       |
   21|       |mod replay_buffer;
   22|       |pub use replay_buffer::*;
   23|       |
   24|       |#[derive(Debug)]
   25|       |struct _ObsDropGuard {
   26|       |    output: Sendable<*mut obs_output>,
   27|       |    runtime: ObsRuntime,
   28|       |}
   29|       |
   30|       |impl_obs_drop!(_ObsDropGuard, (output), move || unsafe {
   31|      8|    libobs::obs_output_release(output);
   32|      8|});
   33|       |
   34|       |#[derive(Debug, Getters, Clone)]
   35|       |#[skip_new]
   36|       |/// A reference to an OBS output.
   37|       |///
   38|       |/// This struct represents an output in OBS, which is responsible for
   39|       |/// outputting encoded audio and video data to a destination such as:
   40|       |/// - A file (recording)
   41|       |/// - A streaming service (RTMP, etc.)
   42|       |/// - A replay buffer
   43|       |///
   44|       |/// The output is associated with video and audio encoders that convert
   45|       |/// raw media to the required format before sending/storing.
   46|       |pub struct ObsOutputRef {
   47|       |    /// Settings for the output
   48|       |    pub(crate) settings: Arc<RwLock<Option<ObsData>>>,
   49|       |
   50|       |    /// Hotkey configuration data for the output
   51|       |    pub(crate) hotkey_data: Arc<RwLock<Option<ObsData>>>,
   52|       |
   53|       |    /// Video encoders attached to this output
   54|       |    #[get_mut]
   55|       |    pub(crate) curr_video_encoder: Arc<RwLock<Option<Arc<ObsVideoEncoder>>>>,
   56|       |
   57|       |    /// Audio encoders attached to this output
   58|       |    #[get_mut]
   59|       |    pub(crate) audio_encoders: Arc<RwLock<Option<Arc<ObsAudioEncoder>>>>,
   60|       |
   61|       |    /// Pointer to the underlying OBS output
   62|       |    #[skip_getter]
   63|       |    pub(crate) output: Sendable<*mut obs_output>,
   64|       |
   65|       |    /// The type identifier of this output
   66|       |    pub(crate) id: ObsString,
   67|       |
   68|       |    /// The unique name of this output
   69|       |    pub(crate) name: ObsString,
   70|       |
   71|       |    /// RAII guard that ensures proper cleanup when the output is dropped
   72|       |    #[skip_getter]
   73|       |    _drop_guard: Arc<_ObsDropGuard>,
   74|       |
   75|       |    #[skip_getter]
   76|       |    pub(crate) runtime: ObsRuntime,
   77|       |
   78|       |    pub(crate) signal_manager: Arc<ObsOutputSignals>,
   79|       |}
   80|       |
   81|       |impl ObsOutputRef {
   82|       |    /// Creates a new output reference from the given output info and runtime.
   83|       |    ///
   84|       |    /// # Arguments
   85|       |    /// * `output` - The output information containing ID, name, and optional settings
   86|       |    /// * `runtime` - The OBS runtime instance
   87|       |    ///
   88|       |    /// # Returns
   89|       |    /// A Result containing the new ObsOutputRef or an error
   90|      8|    pub(crate) fn new(output: OutputInfo, runtime: ObsRuntime) -> Result<Self, ObsError> {
   91|      8|        let (output, id, name, settings, hotkey_data) = runtime
   92|      8|            .run_with_obs_result(|| {
   93|       |                let OutputInfo {
   94|      8|                    id,
   95|      8|                    name,
   96|      8|                    settings,
   97|      8|                    hotkey_data,
   98|       |                } = output;
   99|       |
  100|      8|                let settings_ptr = match settings.as_ref() {
  101|      8|                    Some(x) => x.as_ptr(),
  102|      0|                    None => Sendable(ptr::null_mut()),
  103|       |                };
  104|       |
  105|      8|                let hotkey_data_ptr = match hotkey_data.as_ref() {
  106|      0|                    Some(x) => x.as_ptr(),
  107|      8|                    None => Sendable(ptr::null_mut()),
  108|       |                };
  109|       |
  110|      8|                let output = unsafe {
  111|      8|                    libobs::obs_output_create(
  112|      8|                        id.as_ptr().0,
  113|      8|                        name.as_ptr().0,
  114|      8|                        settings_ptr.0,
  115|      8|                        hotkey_data_ptr.0,
  116|       |                    )
  117|       |                };
  118|       |
  119|      8|                if output.is_null() {
  120|      0|                    bail!("Null pointer returned from obs_output_create");
  121|      8|                }
  122|       |
  123|      8|                Ok((Sendable(output), id, name, settings, hotkey_data))
  124|      8|            })
  125|      8|            .map_err(|e| ObsError::InvocationError(e.to_string()))?
                                                                 ^0^0           ^0
  126|      8|            .map_err(|_| ObsError::NullPointer)?;
                                                             ^0
  127|       |
  128|      8|        let signal_manager = ObsOutputSignals::new(&output, runtime.clone())?;
                                                                                          ^0
  129|      8|        Ok(Self {
  130|      8|            settings: Arc::new(RwLock::new(settings)),
  131|      8|            hotkey_data: Arc::new(RwLock::new(hotkey_data)),
  132|      8|
  133|      8|            curr_video_encoder: Arc::new(RwLock::new(None)),
  134|      8|            audio_encoders: Arc::new(RwLock::new(None)),
  135|      8|
  136|      8|            output: output.clone(),
  137|      8|            id,
  138|      8|            name,
  139|      8|
  140|      8|            _drop_guard: Arc::new(_ObsDropGuard {
  141|      8|                output,
  142|      8|                runtime: runtime.clone(),
  143|      8|            }),
  144|      8|
  145|      8|            runtime,
  146|      8|            signal_manager: Arc::new(signal_manager),
  147|      8|        })
  148|      8|    }
  149|       |
  150|       |    /// Returns the current video encoder attached to this output, if any.
  151|      0|    pub fn get_current_video_encoder(&self) -> Result<Option<Arc<ObsVideoEncoder>>, ObsError> {
  152|      0|        let curr = self
  153|      0|            .curr_video_encoder
  154|      0|            .read()
  155|      0|            .map_err(|e| ObsError::LockError(e.to_string()))?;
  156|       |
  157|      0|        Ok(curr.clone())
  158|      0|    }
  159|       |
  160|       |    /// Creates and attaches a new audio encoder to this output.
  161|       |    ///
  162|       |    /// This method creates a new audio encoder using the provided information
  163|       |    ///  and attaches it to this output at the specified mixer index.
  164|       |    ///
  165|       |    /// # Arguments
  166|       |    /// * `info` - Information for creating the audio encoder
  167|       |    /// * `mixer_idx` - The mixer index to use (typically 0 for primary audio)
  168|       |    ///
  169|       |    /// # Returns
  170|       |    /// A Result containing an Arc-wrapped ObsAudioEncoder or an error
  171|      6|    pub fn create_and_set_video_encoder(
  172|      6|        &mut self,
  173|      6|        info: VideoEncoderInfo,
  174|      6|    ) -> Result<Arc<ObsVideoEncoder>, ObsError> {
  175|       |        // Fail early before creating the encoder if the output is active
  176|      6|        if self.is_active()? {
                                         ^0
  177|      0|            return Err(ObsError::OutputAlreadyActive);
  178|      6|        }
  179|       |
  180|      6|        let video_enc = ObsVideoEncoder::new_from_info(info, self.runtime.clone())?;
                                                                                                ^0
  181|       |
  182|      6|        self.set_video_encoder(video_enc.clone())?;
                                                               ^0
  183|      6|        Ok(video_enc)
  184|      6|    }
  185|       |
  186|       |    /// Attaches an existing video encoder to this output.
  187|       |    ///
  188|       |    /// # Arguments
  189|       |    /// * `encoder` - The video encoder to attach
  190|       |    ///
  191|       |    /// # Returns
  192|       |    /// A Result indicating success or an error
  193|     12|    pub fn set_video_encoder(&mut self, encoder: Arc<ObsVideoEncoder>) -> Result<(), ObsError> {
  194|     12|        if encoder.encoder.0.is_null() {
  195|      0|            return Err(ObsError::NullPointer);
  196|     12|        }
  197|       |
  198|     12|        if self.is_active()? {
                                         ^0
  199|      0|            return Err(ObsError::OutputAlreadyActive);
  200|     12|        }
  201|       |
  202|     12|        let output = self.output.clone();
  203|     12|        let encoder_ptr = encoder.as_ptr();
  204|       |
  205|     12|        run_with_obs!(self.runtime, (output, encoder_ptr), move || unsafe {
  206|     12|            libobs::obs_output_set_video_encoder(output, encoder_ptr);
  207|     12|        })?;
                        ^0
  208|       |
  209|     12|        self.curr_video_encoder
  210|     12|            .write()
  211|     12|            .map_err(|e| ObsError::LockError(e.to_string()))?
                                                           ^0^0           ^0
  212|     12|            .replace(encoder);
  213|       |
  214|     12|        Ok(())
  215|     12|    }
  216|       |
  217|       |    /// Updates the settings of this output.
  218|       |    ///
  219|       |    /// Note: This can only be done when the output is not active.
  220|       |    ///
  221|       |    /// # Arguments
  222|       |    /// * `settings` - The new settings to apply
  223|       |    ///
  224|       |    /// # Returns
  225|       |    /// A Result indicating success or an error
  226|      6|    pub fn update_settings(&mut self, settings: ObsData) -> Result<(), ObsError> {
  227|      6|        if self.is_active()? {
                                         ^0
  228|      0|            return Err(ObsError::OutputAlreadyActive);
  229|      6|        }
  230|       |
  231|      6|        let settings_ptr = settings.as_ptr();
  232|      6|        let output = self.output.clone();
  233|       |
  234|      6|        run_with_obs!(self.runtime, (output, settings_ptr), move || unsafe {
  235|      6|            libobs::obs_output_update(output, settings_ptr)
  236|      6|        })?;
                        ^0
  237|       |
  238|      6|        self.settings
  239|      6|            .write()
  240|      6|            .map_err(|e| ObsError::LockError(e.to_string()))?
                                                           ^0^0           ^0
  241|      6|            .replace(settings);
  242|      6|        Ok(())
  243|      6|    }
  244|       |
  245|       |    /// Creates and attaches a new audio encoder to this output.
  246|       |    ///
  247|       |    /// This method creates a new audio encoder using the provided information,
  248|       |    /// sets up the audio handler, and attaches it to this output at the specified mixer index.
  249|       |    ///
  250|       |    /// # Arguments
  251|       |    /// * `info` - Information for creating the audio encoder
  252|       |    /// * `mixer_idx` - The mixer index to use (typically 0 for primary audio)
  253|       |    /// * `handler` - The audio output handler
  254|       |    ///
  255|       |    /// # Returns
  256|       |    /// A Result containing an Arc-wrapped ObsAudioEncoder or an error
  257|      6|    pub fn create_and_set_audio_encoder(
  258|      6|        &mut self,
  259|      6|        info: AudioEncoderInfo,
  260|      6|        mixer_idx: usize,
  261|      6|    ) -> Result<Arc<ObsAudioEncoder>, ObsError> {
  262|       |        // Fail early before creating the encoder if the output is active
  263|      6|        if self.is_active()? {
                                         ^0
  264|      0|            return Err(ObsError::OutputAlreadyActive);
  265|      6|        }
  266|       |
  267|      6|        let audio_enc = ObsAudioEncoder::new_from_info(info, mixer_idx, self.runtime.clone())?;
                                                                                                           ^0
  268|      6|        self.set_audio_encoder(audio_enc.clone(), mixer_idx)?;
                                                                          ^0
  269|      6|        Ok(audio_enc)
  270|      6|    }
  271|       |
  272|       |    /// Attaches an existing audio encoder to this output at the specified mixer index.
  273|       |    ///
  274|       |    /// # Arguments
  275|       |    /// * `encoder` - The audio encoder to attach
  276|       |    /// * `mixer_idx` - The mixer index to use (typically 0 for primary audio)
  277|       |    ///
  278|       |    /// # Returns
  279|       |    /// A Result indicating success or an error
  280|     12|    pub fn set_audio_encoder(
  281|     12|        &mut self,
  282|     12|        encoder: Arc<ObsAudioEncoder>,
  283|     12|        mixer_idx: usize,
  284|     12|    ) -> Result<(), ObsError> {
  285|     12|        if encoder.encoder.0.is_null() {
  286|      0|            return Err(ObsError::NullPointer);
  287|     12|        }
  288|       |
  289|     12|        if self.is_active()? {
                                         ^0
  290|      0|            return Err(ObsError::OutputAlreadyActive);
  291|     12|        }
  292|       |
  293|     12|        let encoder_ptr = encoder.encoder.clone();
  294|     12|        let output_ptr = self.output.clone();
  295|     12|        run_with_obs!(self.runtime, (output_ptr, encoder_ptr), move || unsafe {
  296|     12|            libobs::obs_output_set_audio_encoder(output_ptr, encoder_ptr, mixer_idx)
  297|     12|        })?;
                        ^0
  298|       |
  299|     12|        self.audio_encoders
  300|     12|            .write()
  301|     12|            .map_err(|e| ObsError::LockError(e.to_string()))?
                                                           ^0^0           ^0
  302|     12|            .replace(encoder);
  303|       |
  304|     12|        Ok(())
  305|     12|    }
  306|       |
  307|       |    /// Starts the output.
  308|       |    ///
  309|       |    /// This begins the encoding and streaming/recording process.
  310|       |    ///
  311|       |    /// # Returns
  312|       |    /// A Result indicating success or an error (e.g., if the output is already active)
  313|      9|    pub fn start(&self) -> Result<(), ObsError> {
  314|      9|        if self.is_active()? {
                                         ^0
  315|      0|            return Err(ObsError::OutputAlreadyActive);
  316|      9|        }
  317|       |
  318|       |        // Set the video and audio encoders before starting (similar to https://github.com/obsproject/obs-studio/blob/0b1229632063a13dfd26cf1cd9dd43431d8c68f6/frontend/utility/SimpleOutput.cpp#L552)
  319|      9|        let vid_encoder_ptr = self
  320|      9|            .curr_video_encoder
  321|      9|            .read()
  322|      9|            .map_err(|e| ObsError::LockError(e.to_string()))?
                                                           ^0^0           ^0
  323|      9|            .as_ref()
  324|      9|            .map(|enc| enc.as_ptr())
  325|      9|            .unwrap_or(Sendable(ptr::null_mut()));
  326|       |
  327|      9|        let audio_encoder_ptr = self
  328|      9|            .audio_encoders
  329|      9|            .read()
  330|      9|            .map_err(|e| ObsError::LockError(e.to_string()))?
                                                           ^0^0           ^0
  331|      9|            .as_ref()
  332|      9|            .map(|enc| enc.encoder.clone())
  333|      9|            .unwrap_or(Sendable(ptr::null_mut()));
  334|       |
  335|      9|        let output_ptr = self.output.clone();
  336|      9|        let res = run_with_obs!(
  337|      9|            self.runtime,
  338|       |            (output_ptr, vid_encoder_ptr, audio_encoder_ptr),
  339|       |            move || unsafe {
  340|      9|                libobs::obs_encoder_set_video(vid_encoder_ptr, libobs::obs_get_video());
  341|      9|                libobs::obs_encoder_set_audio(audio_encoder_ptr, libobs::obs_get_audio());
  342|      9|                libobs::obs_output_start(output_ptr)
  343|      9|            }
  344|      0|        )?;
  345|       |
  346|      9|        if res {
  347|      9|            return Ok(());
  348|      0|        }
  349|       |
  350|      0|        let err = run_with_obs!(self.runtime, (output_ptr), move || unsafe {
  351|      0|            Sendable(libobs::obs_output_get_last_error(output_ptr))
  352|      0|        })?;
  353|       |
  354|      0|        let c_str = unsafe { CStr::from_ptr(err.0) };
  355|      0|        let err_str = c_str.to_str().ok().map(|x| x.to_string());
  356|       |
  357|      0|        Err(ObsError::OutputStartFailure(err_str))
  358|      9|    }
  359|       |
  360|       |    /// This pauses or resumes the given output, and waits until the output is fully paused.
  361|       |    ///
  362|       |    /// # Arguments
  363|       |    ///
  364|       |    /// * `pause` - `true` to pause the output, `false` to resume the output.
  365|       |    ///
  366|       |    /// # Returns
  367|       |    ///
  368|       |    /// * `Ok(())` - The output was paused or resumed successfully.
  369|       |    /// * `Err(ObsError::OutputPauseFailure(Some(String)))` - The output failed to pause or resume.
  370|      0|    pub fn pause(&self, pause: bool) -> Result<(), ObsError> {
  371|      0|        if !self.is_active()? {
  372|      0|            return Err(ObsError::OutputPauseFailure(Some(
  373|      0|                "Output is not active.".to_string(),
  374|      0|            )));
  375|      0|        }
  376|       |
  377|      0|        let output_ptr = self.output.clone();
  378|       |
  379|      0|        let mut rx = if pause {
  380|      0|            self.signal_manager.on_pause()?
  381|       |        } else {
  382|      0|            self.signal_manager.on_unpause()?
  383|       |        };
  384|       |
  385|      0|        let res = run_with_obs!(self.runtime, (output_ptr), move || unsafe {
  386|      0|            libobs::obs_output_pause(output_ptr, pause)
  387|      0|        })?;
  388|       |
  389|      0|        if res {
  390|      0|            rx.blocking_recv().map_err(|_| ObsError::NoSenderError)?;
  391|       |
  392|      0|            Ok(())
  393|       |        } else {
  394|      0|            let err = run_with_obs!(self.runtime, (output_ptr), move || unsafe {
  395|      0|                Sendable(libobs::obs_output_get_last_error(output_ptr))
  396|      0|            })?;
  397|       |
  398|      0|            let c_str = unsafe { CStr::from_ptr(err.0) };
  399|      0|            let err_str = c_str.to_str().ok().map(|x| x.to_string());
  400|       |
  401|      0|            Err(ObsError::OutputPauseFailure(err_str))
  402|       |        }
  403|      0|    }
  404|       |
  405|       |    /// Stops the output.
  406|       |    ///
  407|       |    /// This ends the encoding and streaming/recording process.
  408|       |    /// The method waits for a stop signal and returns the result.
  409|       |    ///
  410|       |    /// # Returns
  411|       |    /// A Result indicating success or an error with details about why stopping failed
  412|       |    //TODO There should be some kind of "wait" for other methods to finish, generally we don't want to have multiple different methods calling methods
  413|      9|    pub fn stop(&mut self) -> Result<(), ObsError> {
  414|      9|        let output_ptr = self.output.clone();
  415|      9|        let output_active = run_with_obs!(self.runtime, (output_ptr), move || unsafe {
  416|      9|            libobs::obs_output_active(output_ptr)
  417|      9|        })?;
                        ^0
  418|       |
  419|      9|        if !output_active {
  420|      0|            return Err(ObsError::OutputStopFailure(Some(
  421|      0|                "Output is not active.".to_string(),
  422|      0|            )));
  423|      9|        }
  424|       |
  425|      9|        let mut rx = self.signal_manager.on_stop()?;
                                                                ^0
  426|      9|        let mut rx_deactivate = self.signal_manager.on_deactivate()?;
                                                                                 ^0
  427|       |
  428|      9|        run_with_obs!(self.runtime, (output_ptr), move || unsafe {
  429|      9|            libobs::obs_output_stop(output_ptr)
  430|      9|        })?;
                        ^0
  431|       |
  432|      9|        let signal = rx.blocking_recv().map_err(|_| ObsError::NoSenderError)?;
                                                                                          ^0
  433|       |
  434|      9|        log::trace!("Received stop signal: {:?}", signal);
                                  ^0
  435|      9|        if signal != ObsOutputStopSignal::Success {
  436|      0|            return Err(ObsError::OutputStopFailure(Some(signal.to_string())));
  437|      9|        }
  438|       |
  439|      9|        rx_deactivate
  440|      9|            .blocking_recv()
  441|      9|            .map_err(|_| ObsError::NoSenderError)?;
                                                               ^0
  442|       |
  443|      9|        Ok(())
  444|      9|    }
  445|       |
  446|     57|    pub fn is_active(&self) -> Result<bool, ObsError> {
  447|     57|        let output_ptr = self.output.clone();
  448|     57|        let output_active = run_with_obs!(self.runtime, (output_ptr), move || unsafe {
  449|     57|            libobs::obs_output_active(output_ptr)
  450|     57|        })?;
                        ^0
  451|       |
  452|     57|        Ok(output_active)
  453|     57|    }
  454|       |
  455|      0|    pub fn as_ptr(&self) -> Sendable<*mut obs_output> {
  456|      0|        self.output.clone()
  457|      0|    }
  458|       |}
  459|       |
  460|     16|impl_signal_manager!(|ptr| unsafe { libobs::obs_output_get_signal_handler(ptr) }, ObsOutputSignals for ObsOutputRef<*mut libobs::obs_output>, [
  461|       |    "start": {},
  462|       |    "stop": {code: crate::enums::ObsOutputStopSignal},
  463|       |    "pause": {},
  464|       |    "unpause": {},
  465|       |    "starting": {},
  466|       |    "stopping": {},
  467|       |    "activate": {},
  468|       |    "deactivate": {},
  469|       |    "reconnect": {},
  470|       |    "reconnect_success": {},
  471|       |]);

E:\Rust\libobs-rs\libobs-wrapper\src\data\output\replay_buffer.rs:
    1|       |//! Provides functionality for working with OBS replay buffers.
    2|       |//!
    3|       |//! This module extends the ObsOutputRef to provide replay buffer capabilities.
    4|       |//! A replay buffer is a special type of output that continuously records
    5|       |//! the last N seconds of content, allowing the user to save this buffer on demand. This must be configured. More documentation soon.
    6|       |use std::{
    7|       |    ffi::c_char,
    8|       |    mem::MaybeUninit,
    9|       |    path::{Path, PathBuf},
   10|       |};
   11|       |
   12|       |use libobs::calldata_t;
   13|       |
   14|       |use crate::{
   15|       |    run_with_obs,
   16|       |    utils::{ObsError, ObsString},
   17|       |};
   18|       |
   19|       |use super::ObsOutputRef;
   20|       |
   21|       |/// Defines functionality specific to replay buffer outputs.
   22|       |///
   23|       |/// This trait provides methods for working with replay buffers in OBS,
   24|       |/// which are special outputs that continuously record content and allow
   25|       |/// on-demand saving of recent footage.
   26|       |pub trait ReplayBufferOutput {
   27|       |    /// Saves the current replay buffer content to disk.
   28|       |    ///
   29|       |    /// This method triggers the replay buffer to save its content to a file
   30|       |    /// and returns the path to the saved file.
   31|       |    ///
   32|       |    /// # Returns
   33|       |    /// * `Result<Box<Path>, ObsError>` - On success, returns the path to the saved
   34|       |    ///   replay file. On failure, returns an error describing what went wrong.
   35|       |    fn save_buffer(&self) -> Result<Box<Path>, ObsError>;
   36|       |}
   37|       |
   38|       |/// Implementation of the ReplayBufferOutput trait for ObsOutputRef.
   39|       |///
   40|       |/// This implementation allows any ObsOutputRef configured as a replay buffer
   41|       |/// to save its content to disk via a simple API call.
   42|       |impl ReplayBufferOutput for ObsOutputRef {
   43|       |    /// Saves the current replay buffer content to disk.
   44|       |    ///
   45|       |    /// # Implementation Details
   46|       |    /// This method:
   47|       |    /// 1. Accesses the OBS procedure handler for the output
   48|       |    /// 2. Calls the "save" procedure to trigger saving the replay
   49|       |    /// 3. Calls the "get_last_replay" procedure to retrieve the saved file path
   50|       |    /// 4. Extracts the path string from the calldata and returns it
   51|       |    ///
   52|       |    /// # Returns
   53|       |    /// * `Ok(Box<Path>)` - The path to the saved replay file
   54|       |    /// * `Err(ObsError)` - Various errors that might occur during the saving process:
   55|       |    ///   - Failure to get procedure handler
   56|       |    ///   - Failure to call "save" procedure
   57|       |    ///   - Failure to call "get_last_replay" procedure
   58|       |    ///   - Failure to extract the path from calldata
   59|      0|    fn save_buffer(&self) -> Result<Box<Path>, ObsError> {
   60|      0|        let output_ptr = self.output.clone();
   61|       |
   62|      0|        let path = run_with_obs!(self.runtime, (output_ptr), move || {
   63|      0|            let ph = unsafe { libobs::obs_output_get_proc_handler(output_ptr) };
   64|      0|            if ph.is_null() {
   65|      0|                return Err(ObsError::OutputSaveBufferFailure(
   66|      0|                    "Failed to get proc handler.".to_string(),
   67|      0|                ));
   68|      0|            }
   69|       |
   70|      0|            let name = ObsString::new("save");
   71|      0|            let call_success = unsafe {
   72|      0|                let mut calldata = MaybeUninit::<calldata_t>::zeroed();
   73|      0|                libobs::proc_handler_call(ph, name.as_ptr().0, calldata.as_mut_ptr())
   74|       |            };
   75|       |
   76|      0|            if !call_success {
   77|      0|                return Err(ObsError::OutputSaveBufferFailure(
   78|      0|                    "Failed to call proc handler.".to_string(),
   79|      0|                ));
   80|      0|            }
   81|       |
   82|      0|            let func_get = ObsString::new("get_last_replay");
   83|      0|            let last_replay = unsafe {
   84|      0|                let mut calldata = MaybeUninit::<calldata_t>::zeroed();
   85|      0|                let success =
   86|      0|                    libobs::proc_handler_call(ph, func_get.as_ptr().0, calldata.as_mut_ptr());
   87|       |
   88|      0|                if !success {
   89|      0|                    return Err(ObsError::OutputSaveBufferFailure(
   90|      0|                        "Failed to call get_last_replay.".to_string(),
   91|      0|                    ));
   92|      0|                }
   93|       |
   94|      0|                calldata.assume_init()
   95|       |            };
   96|       |
   97|      0|            let path_get = ObsString::new("path");
   98|       |
   99|      0|            let mut s = MaybeUninit::<*const c_char>::uninit();
  100|       |
  101|      0|            let res = unsafe {
  102|      0|                libobs::calldata_get_string(&last_replay, path_get.as_ptr().0, s.as_mut_ptr())
  103|       |            };
  104|      0|            if !res {
  105|      0|                return Err(ObsError::OutputSaveBufferFailure(
  106|      0|                    "Failed to get path from last replay.".to_string(),
  107|      0|                ));
  108|      0|            }
  109|       |
  110|      0|            let s: *const c_char = unsafe { s.assume_init() };
  111|      0|            let path = unsafe { std::ffi::CStr::from_ptr(s) }.to_str().unwrap();
  112|       |
  113|      0|            Ok(PathBuf::from(path))
  114|      0|        })??;
  115|       |
  116|      0|        Ok(path.into_boxed_path())
  117|      0|    }
  118|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\macros.rs:
    1|       |macro_rules! assert_type {
    2|       |    ($prop_type: ident, $name: ident) => {{
    3|       |        use crate::data::properties::ObsPropertyType;
    4|       |        use num_traits::FromPrimitive;
    5|       |
    6|       |        let p_type = unsafe { libobs::obs_property_get_type($name) };
    7|       |        let p_type = ObsPropertyType::from_i32(p_type);
    8|      0|        if p_type.is_none_or(|e| !matches!(e, ObsPropertyType::$prop_type)) {
    9|       |            panic!(
   10|       |                "Invalid property type: expected {:?}, got {:?}",
   11|       |                ObsPropertyType::$prop_type,
   12|       |                p_type
   13|       |            );
   14|       |        }
   15|       |    }};
   16|       |}
   17|       |
   18|       |macro_rules! impl_general_property {
   19|       |    ($type: ident) => {
   20|       |        paste::paste! {
   21|       |            #[derive(Debug, getters0::Getters, Clone)]
   22|       |            #[skip_new]
   23|       |            pub struct [<Obs $type Property>] {
   24|       |                name: String,
   25|       |                description: Option<String>
   26|       |            }
   27|       |            impl From<crate::data::properties::PropertyCreationInfo> for [<Obs $type Property>] {
   28|      0|                fn from(
   29|      0|                    crate::data::properties::PropertyCreationInfo {
   30|      0|                        name,
   31|      0|                        description,
   32|      0|                        pointer,
   33|      0|                    }: crate::data::properties::PropertyCreationInfo,
   34|      0|                ) -> Self {
   35|      0|                    crate::data::properties::assert_type!($type, pointer);
   36|      0|                    Self { name, description }
   37|      0|                }
   38|       |            }
   39|       |        }
   40|       |    };
   41|       |}
   42|       |
   43|       |macro_rules! get_enum {
   44|       |    ($pointer_name: ident, $name: ident, $enum_name: ident) => {
   45|       |        paste::paste! {
   46|       |            {
   47|       |                use num_traits::FromPrimitive;
   48|       |                let v = unsafe { libobs::[<obs_property_ $name>]($pointer_name) };
   49|       |                let v = $enum_name::from_i32(v);
   50|       |
   51|       |                if v.is_none() {
   52|       |                    panic!("Invalid {} type got none", stringify!($name));
   53|       |                }
   54|       |
   55|       |                v.unwrap()
   56|       |            }
   57|       |        }
   58|       |    };
   59|       |}
   60|       |
   61|       |macro_rules! get_opt_str {
   62|       |    ($pointer_name: ident, $name: ident) => {{
   63|       |        paste::paste! {
   64|       |            let v = unsafe { libobs::[<obs_property_ $name>]($pointer_name) };
   65|       |        }
   66|       |        if v.is_null() {
   67|       |            None
   68|       |        } else {
   69|       |            let v = unsafe { std::ffi::CStr::from_ptr(v as _) };
   70|       |            let v = v.to_str().expect("OBS returned invalid string").to_string();
   71|       |            if v.is_empty() {
   72|       |                None
   73|       |            } else {
   74|       |                Some(v)
   75|       |            }
   76|       |        }
   77|       |    }};
   78|       |}
   79|       |
   80|       |pub(super) use assert_type;
   81|       |pub(super) use get_enum;
   82|       |pub(super) use get_opt_str;
   83|       |pub(super) use impl_general_property;

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\mod.rs:
    1|       |mod enums;
    2|       |mod macros;
    3|       |pub mod prop_impl;
    4|       |pub mod types;
    5|       |
    6|       |use std::{collections::HashMap, ffi::CStr};
    7|       |
    8|       |use libobs::obs_properties;
    9|       |use macros::*;
   10|       |
   11|       |pub use enums::*;
   12|       |use num_traits::FromPrimitive;
   13|       |use types::*;
   14|       |
   15|       |use crate::{
   16|       |    run_with_obs,
   17|       |    runtime::ObsRuntime,
   18|       |    unsafe_send::Sendable,
   19|       |    utils::{ObsError, ObsString},
   20|       |};
   21|       |
   22|       |#[derive(Debug, Clone)]
   23|       |pub enum ObsProperty {
   24|       |    /// A property that is not valid
   25|       |    Invalid,
   26|       |    /// A boolean property
   27|       |    Bool,
   28|       |    /// An integer property
   29|       |    Int(ObsNumberProperty<i32>),
   30|       |    /// A float property
   31|       |    Float(ObsNumberProperty<f64>),
   32|       |    /// A text property
   33|       |    Text(ObsTextProperty),
   34|       |    /// A path property
   35|       |    Path(ObsPathProperty),
   36|       |    /// A list property
   37|       |    List(ObsListProperty),
   38|       |    /// A color property
   39|       |    Color(ObsColorProperty),
   40|       |    /// A button property
   41|       |    Button(ObsButtonProperty),
   42|       |    /// A font property
   43|       |    Font(ObsFontProperty),
   44|       |    /// An editable list property
   45|       |    EditableList(ObsEditableListProperty),
   46|       |    /// A frame rate property
   47|       |    FrameRate(ObsFrameRateProperty),
   48|       |    /// A group property
   49|       |    Group(ObsGroupProperty),
   50|       |    /// A color alpha property
   51|       |    ColorAlpha(ObsColorAlphaProperty),
   52|       |}
   53|       |
   54|       |pub trait ObsPropertyObjectPrivate {
   55|       |    fn get_properties_raw(&self) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError>;
   56|       |    fn get_properties_by_id_raw<T: Into<ObsString> + Sync + Send>(
   57|       |        id: T,
   58|       |        runtime: ObsRuntime,
   59|       |    ) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError>;
   60|       |}
   61|       |
   62|      0|pub(crate) fn get_properties_inner(
   63|      0|    properties_raw: Sendable<*mut obs_properties>,
   64|      0|    runtime: ObsRuntime,
   65|      0|) -> Result<HashMap<String, ObsProperty>, ObsError> {
   66|      0|    let properties_raw = properties_raw.clone();
   67|      0|    if properties_raw.0.is_null() {
   68|      0|        let ptr_clone = properties_raw.clone();
   69|      0|        run_with_obs!(runtime, (ptr_clone), move || {
   70|      0|            unsafe { libobs::obs_properties_destroy(ptr_clone) };
   71|      0|        })?;
   72|       |
   73|      0|        return Ok(HashMap::new());
   74|      0|    }
   75|       |
   76|      0|    run_with_obs!(runtime, (properties_raw), move || {
   77|      0|        let mut result = HashMap::new();
   78|      0|        let mut property = unsafe { libobs::obs_properties_first(properties_raw) };
   79|      0|        while !property.is_null() {
   80|      0|            let name = unsafe { libobs::obs_property_name(property) };
   81|      0|            let name = unsafe { CStr::from_ptr(name as _) };
   82|      0|            let name = name.to_string_lossy().to_string();
   83|       |
   84|      0|            let p_type = unsafe { libobs::obs_property_get_type(property) };
   85|      0|            let p_type = ObsPropertyType::from_i32(p_type);
   86|       |
   87|      0|            println!("Property: {:?}", name);
   88|      0|            match p_type {
   89|      0|                Some(p_type) => {
   90|      0|                    result.insert(name, unsafe { p_type.to_property_struct(property) });
   91|      0|                }
   92|      0|                None => {
   93|      0|                    result.insert(name, ObsProperty::Invalid);
   94|      0|                }
   95|       |            }
   96|       |
   97|       |            // Move to the next property
   98|      0|            unsafe { libobs::obs_property_next(&mut property) };
   99|       |        }
  100|       |
  101|      0|        unsafe { libobs::obs_properties_destroy(properties_raw) };
  102|      0|        result
  103|      0|    })
  104|      0|}
  105|       |
  106|       |/// This trait is implemented for all obs objects that can have properties
  107|       |pub trait ObsPropertyObject: ObsPropertyObjectPrivate {
  108|       |    /// Returns the properties of the object
  109|       |    fn get_properties(&self) -> Result<HashMap<String, ObsProperty>, ObsError>;
  110|      0|    fn get_properties_by_id<T: Into<ObsString> + Sync + Send>(
  111|      0|        id: T,
  112|      0|        runtime: &ObsRuntime,
  113|      0|    ) -> Result<HashMap<String, ObsProperty>, ObsError> {
  114|      0|        let properties_raw = Self::get_properties_by_id_raw(id, runtime.clone())?;
  115|      0|        get_properties_inner(properties_raw, runtime.clone())
  116|      0|    }
  117|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\prop_impl.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |use crate::{
    4|       |    data::output::ObsOutputRef,
    5|       |    runtime::ObsRuntime,
    6|       |    sources::ObsSourceRef,
    7|       |    unsafe_send::Sendable,
    8|       |    utils::{ObsError, ObsString},
    9|       |};
   10|       |
   11|       |use super::{get_properties_inner, ObsProperty, ObsPropertyObject, ObsPropertyObjectPrivate};
   12|       |
   13|       |impl ObsPropertyObject for ObsSourceRef {
   14|      0|    fn get_properties(&self) -> Result<HashMap<String, ObsProperty>, ObsError> {
   15|      0|        let properties_raw = self.get_properties_raw()?;
   16|      0|        get_properties_inner(properties_raw, self.runtime.clone())
   17|      0|    }
   18|       |}
   19|       |
   20|       |impl ObsPropertyObjectPrivate for ObsSourceRef {
   21|      0|    fn get_properties_raw(&self) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError> {
   22|      0|        let source_ptr = self.source.clone();
   23|      0|        self.runtime
   24|      0|            .run_with_obs_result(move || unsafe {
   25|      0|                let source_ptr = source_ptr;
   26|       |
   27|      0|                Sendable(libobs::obs_source_properties(source_ptr.0))
   28|      0|            })
   29|      0|            .map_err(|e| ObsError::InvocationError(e.to_string()))
   30|      0|    }
   31|       |
   32|      0|    fn get_properties_by_id_raw<T: Into<ObsString> + Sync + Send>(
   33|      0|        id: T,
   34|      0|        runtime: ObsRuntime,
   35|      0|    ) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError> {
   36|      0|        let id: ObsString = id.into();
   37|      0|        let id_ptr = id.as_ptr();
   38|      0|        runtime
   39|      0|            .run_with_obs_result(move || unsafe {
   40|      0|                let id_ptr = id_ptr;
   41|      0|                Sendable(libobs::obs_get_source_properties(id_ptr.0))
   42|      0|            })
   43|      0|            .map_err(|e| ObsError::InvocationError(e.to_string()))
   44|      0|    }
   45|       |}
   46|       |
   47|       |impl ObsPropertyObject for ObsOutputRef {
   48|      0|    fn get_properties(&self) -> Result<HashMap<String, ObsProperty>, ObsError> {
   49|      0|        let properties_raw = self.get_properties_raw()?;
   50|      0|        get_properties_inner(properties_raw, self.runtime.clone())
   51|      0|    }
   52|       |}
   53|       |
   54|       |impl ObsPropertyObjectPrivate for ObsOutputRef {
   55|      0|    fn get_properties_raw(&self) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError> {
   56|      0|        let output_ptr = self.output.clone();
   57|      0|        self.runtime
   58|      0|            .run_with_obs_result(move || unsafe {
   59|      0|                let output_ptr = output_ptr;
   60|       |
   61|      0|                Sendable(libobs::obs_output_properties(output_ptr.0))
   62|      0|            })
   63|      0|            .map_err(|e| ObsError::InvocationError(e.to_string()))
   64|      0|    }
   65|       |
   66|      0|    fn get_properties_by_id_raw<T: Into<ObsString> + Sync + Send>(
   67|      0|        id: T,
   68|      0|        runtime: ObsRuntime,
   69|      0|    ) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError> {
   70|      0|        let id: ObsString = id.into();
   71|      0|        let id_ptr = id.as_ptr();
   72|      0|        runtime
   73|      0|            .run_with_obs_result(move || unsafe {
   74|      0|                let id_ptr = id_ptr;
   75|       |
   76|      0|                Sendable(libobs::obs_get_output_properties(id_ptr.0))
   77|      0|            })
   78|      0|            .map_err(|e| ObsError::InvocationError(e.to_string()))
   79|      0|    }
   80|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\types\button.rs:
    1|       |use getters0::Getters;
    2|       |
    3|       |use crate::data::properties::{get_enum, get_opt_str, macros::assert_type, ObsButtonType};
    4|       |
    5|       |use super::PropertyCreationInfo;
    6|       |
    7|       |#[derive(Debug, Getters, Clone)]
    8|       |#[skip_new]
    9|       |pub struct ObsButtonProperty {
   10|       |    name: String,
   11|       |    description: Option<String>,
   12|       |    button_type: ObsButtonType,
   13|       |    url: Option<String>,
   14|       |}
   15|       |
   16|       |impl From<PropertyCreationInfo> for ObsButtonProperty {
   17|      0|    fn from(
   18|      0|        PropertyCreationInfo {
   19|      0|            name,
   20|      0|            description,
   21|      0|            pointer,
   22|      0|        }: PropertyCreationInfo,
   23|      0|    ) -> Self {
   24|      0|        assert_type!(Button, pointer);
   25|       |
   26|      0|        let url = get_opt_str!(pointer, button_url);
   27|      0|        let button_type = get_enum!(pointer, button_type, ObsButtonType);
   28|       |
   29|      0|        Self {
   30|      0|            name,
   31|      0|            description,
   32|      0|            button_type,
   33|      0|            url,
   34|      0|        }
   35|      0|    }
   36|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\types\editable_list.rs:
    1|       |use getters0::Getters;
    2|       |
    3|       |use crate::data::properties::{assert_type, get_enum, get_opt_str, ObsEditableListType};
    4|       |
    5|       |use super::PropertyCreationInfo;
    6|       |
    7|       |#[derive(Debug, Getters, Clone)]
    8|       |#[skip_new]
    9|       |pub struct ObsEditableListProperty {
   10|       |    name: String,
   11|       |    description: Option<String>,
   12|       |    list_type: ObsEditableListType,
   13|       |    filter: String,
   14|       |    default_path: String,
   15|       |}
   16|       |
   17|       |impl From<PropertyCreationInfo> for ObsEditableListProperty {
   18|      0|    fn from(
   19|      0|        PropertyCreationInfo {
   20|      0|            name,
   21|      0|            description,
   22|      0|            pointer,
   23|      0|        }: PropertyCreationInfo,
   24|      0|    ) -> Self {
   25|      0|        assert_type!(EditableList, pointer);
   26|       |
   27|      0|        let list_type = get_enum!(pointer, list_type, ObsEditableListType);
   28|      0|        let filter = get_opt_str!(pointer, path_filter).unwrap_or_default();
   29|      0|        let default_path = get_opt_str!(pointer, path_default_path).unwrap_or_default();
   30|       |
   31|      0|        Self {
   32|      0|            name,
   33|      0|            description,
   34|      0|            list_type,
   35|      0|            filter,
   36|      0|            default_path,
   37|      0|        }
   38|      0|    }
   39|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\types\list.rs:
    1|       |use super::PropertyCreationInfo;
    2|       |use crate::data::properties::{assert_type, get_enum, ObsComboFormat, ObsComboType};
    3|       |use getters0::Getters;
    4|       |use std::ffi::CStr;
    5|       |
    6|       |#[derive(Debug, Getters, Clone)]
    7|       |#[skip_new]
    8|       |pub struct ObsListProperty {
    9|       |    name: String,
   10|       |    description: Option<String>,
   11|       |    list_type: ObsComboType,
   12|       |    format: ObsComboFormat,
   13|       |    items: Vec<ObsListItem>,
   14|       |}
   15|       |
   16|       |#[derive(Debug, Getters, Clone)]
   17|       |#[skip_new]
   18|       |pub struct ObsListItem {
   19|       |    name: String,
   20|       |    value: ObsListItemValue,
   21|       |    disabled: bool,
   22|       |}
   23|       |
   24|       |#[derive(Debug, Clone)]
   25|       |pub enum ObsListItemValue {
   26|       |    String(String),
   27|       |    Int(i64),
   28|       |    Float(f64),
   29|       |    Bool(bool),
   30|       |    Invalid,
   31|       |}
   32|       |
   33|       |impl ObsListItem {
   34|      0|    fn new(name: String, value: ObsListItemValue, disabled: bool) -> Self {
   35|      0|        Self {
   36|      0|            name,
   37|      0|            value,
   38|      0|            disabled,
   39|      0|        }
   40|      0|    }
   41|       |}
   42|       |
   43|       |impl From<PropertyCreationInfo> for ObsListProperty {
   44|      0|    fn from(
   45|      0|        PropertyCreationInfo {
   46|      0|            name,
   47|      0|            description,
   48|      0|            pointer,
   49|      0|        }: PropertyCreationInfo,
   50|      0|    ) -> Self {
   51|      0|        assert_type!(List, pointer);
   52|       |
   53|      0|        let list_type = get_enum!(pointer, list_type, ObsComboType);
   54|      0|        let format = get_enum!(pointer, list_format, ObsComboFormat);
   55|       |
   56|      0|        let count = unsafe { libobs::obs_property_list_item_count(pointer) };
   57|      0|        let mut items = Vec::with_capacity(count);
   58|       |
   59|      0|        for i in 0..count {
   60|      0|            let list_name = unsafe {
   61|      0|                CStr::from_ptr(libobs::obs_property_list_item_name(pointer, i))
   62|      0|                    .to_str()
   63|      0|                    .unwrap_or_default()
   64|      0|                    .to_string()
   65|       |            };
   66|      0|            let is_disabled = unsafe { libobs::obs_property_list_item_disabled(pointer, i) };
   67|      0|            let value = match format {
   68|      0|                ObsComboFormat::Invalid => ObsListItemValue::Invalid,
   69|       |                ObsComboFormat::Int => {
   70|      0|                    let int_val = unsafe { libobs::obs_property_list_item_int(pointer, i) };
   71|      0|                    ObsListItemValue::Int(int_val)
   72|       |                }
   73|       |                ObsComboFormat::Float => {
   74|      0|                    let float_val = unsafe { libobs::obs_property_list_item_float(pointer, i) };
   75|      0|                    ObsListItemValue::Float(float_val)
   76|       |                }
   77|       |                ObsComboFormat::String => {
   78|      0|                    let string_val = unsafe {
   79|      0|                        CStr::from_ptr(libobs::obs_property_list_item_string(pointer, i))
   80|      0|                            .to_str()
   81|      0|                            .unwrap_or_default()
   82|      0|                            .to_string()
   83|       |                    };
   84|      0|                    ObsListItemValue::String(string_val)
   85|       |                }
   86|       |                ObsComboFormat::Bool => {
   87|      0|                    let bool_val = unsafe { libobs::obs_property_list_item_bool(pointer, i) };
   88|      0|                    ObsListItemValue::Bool(bool_val)
   89|       |                }
   90|       |            };
   91|      0|            items.push(ObsListItem::new(list_name, value, is_disabled));
   92|       |        }
   93|       |
   94|      0|        Self {
   95|      0|            name,
   96|      0|            description,
   97|      0|            list_type,
   98|      0|            format,
   99|      0|            items,
  100|      0|        }
  101|      0|    }
  102|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\types\mod.rs:
    1|       |//! # Important Notice
    2|       |//! All structs in this module use direct obs calls to get the data from the obs_property_t struct. **ALWAYS MAKE SURE THIS IS RUNNING ON THE OBS THREAD**
    3|       |
    4|       |mod button;
    5|       |impl_general_property!(Color);
    6|       |mod editable_list;
    7|       |impl_general_property!(Font);
    8|       |impl_general_property!(FrameRate);
    9|       |impl_general_property!(Group);
   10|       |impl_general_property!(ColorAlpha);
   11|       |mod list;
   12|       |mod number;
   13|       |mod path;
   14|       |mod text;
   15|       |
   16|       |pub(crate) struct PropertyCreationInfo {
   17|       |    pub name: String,
   18|       |    pub description: Option<String>,
   19|       |    pub pointer: *mut libobs::obs_property,
   20|       |}
   21|       |
   22|       |use std::ffi::CStr;
   23|       |
   24|       |pub use button::*;
   25|       |pub use editable_list::*;
   26|       |use libobs::obs_property;
   27|       |pub use list::*;
   28|       |pub use number::*;
   29|       |pub use path::*;
   30|       |pub use text::*;
   31|       |
   32|       |use super::{macros::impl_general_property, ObsProperty, ObsPropertyType};
   33|       |
   34|       |impl ObsPropertyType {
   35|      0|    fn inner_to_property_struct(&self, pointer: *mut obs_property) -> ObsProperty {
   36|      0|        let name = unsafe { libobs::obs_property_name(pointer) };
   37|      0|        let name = unsafe { CStr::from_ptr(name) };
   38|      0|        let name = name.to_string_lossy().to_string();
   39|       |
   40|      0|        let description = unsafe { libobs::obs_property_description(pointer) };
   41|      0|        let description = if description.is_null() {
   42|      0|            None
   43|       |        } else {
   44|      0|            let description = unsafe { CStr::from_ptr(description) };
   45|      0|            Some(description.to_string_lossy().to_string())
   46|       |        };
   47|       |
   48|      0|        let info = PropertyCreationInfo {
   49|      0|            name,
   50|      0|            description,
   51|      0|            pointer,
   52|      0|        };
   53|       |
   54|      0|        match self {
   55|      0|            ObsPropertyType::Invalid => ObsProperty::Invalid,
   56|      0|            ObsPropertyType::Bool => ObsProperty::Bool,
   57|      0|            ObsPropertyType::Int => ObsProperty::Int(ObsNumberProperty::<i32>::from(info)),
   58|      0|            ObsPropertyType::Float => ObsProperty::Float(ObsNumberProperty::<f64>::from(info)),
   59|      0|            ObsPropertyType::Text => ObsProperty::Text(ObsTextProperty::from(info)),
   60|      0|            ObsPropertyType::Path => ObsProperty::Path(ObsPathProperty::from(info)),
   61|      0|            ObsPropertyType::List => ObsProperty::List(ObsListProperty::from(info)),
   62|      0|            ObsPropertyType::Color => ObsProperty::Color(ObsColorProperty::from(info)),
   63|      0|            ObsPropertyType::Button => ObsProperty::Button(ObsButtonProperty::from(info)),
   64|      0|            ObsPropertyType::Font => ObsProperty::Font(ObsFontProperty::from(info)),
   65|       |            ObsPropertyType::EditableList => {
   66|      0|                ObsProperty::EditableList(ObsEditableListProperty::from(info))
   67|       |            }
   68|      0|            ObsPropertyType::FrameRate => ObsProperty::FrameRate(ObsFrameRateProperty::from(info)),
   69|      0|            ObsPropertyType::Group => ObsProperty::Group(ObsGroupProperty::from(info)),
   70|       |            ObsPropertyType::ColorAlpha => {
   71|      0|                ObsProperty::ColorAlpha(ObsColorAlphaProperty::from(info))
   72|       |            }
   73|       |        }
   74|      0|    }
   75|       |
   76|       |    /// # Safety
   77|       |    ///
   78|       |    /// The caller must ensure that `pointer` is non-null and points to a valid
   79|       |    /// `libobs::obs_property` instance for the duration of this call. All access
   80|       |    /// to the underlying libobs property must be performed on the OBS thread,
   81|       |    /// as required by the module's top-level documentation.
   82|      0|    pub unsafe fn to_property_struct(&self, pointer: *mut obs_property) -> ObsProperty {
   83|      0|        self.inner_to_property_struct(pointer)
   84|      0|    }
   85|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\types\number.rs:
    1|       |use getters0::Getters;
    2|       |
    3|       |use crate::data::properties::ObsNumberType;
    4|       |
    5|       |#[derive(Debug, Getters, Clone)]
    6|       |#[skip_new]
    7|       |pub struct ObsNumberProperty<T>
    8|       |where
    9|       |    T: Clone + Copy + std::fmt::Debug,
   10|       |{
   11|       |    name: String,
   12|       |    description: Option<String>,
   13|       |    min: T,
   14|       |    max: T,
   15|       |    step: T,
   16|       |    suffix: String,
   17|       |    number_type: ObsNumberType,
   18|       |}
   19|       |
   20|       |macro_rules! impl_from_property {
   21|       |    ($n_type: ident, $obs_number_name: ident) => {
   22|       |        paste::paste! {
   23|       |            impl From<super::PropertyCreationInfo> for ObsNumberProperty<[<$n_type>]> {
   24|      0|                fn from(
   25|      0|                    super::PropertyCreationInfo {
   26|      0|                        name,
   27|      0|                        description,
   28|      0|                        pointer,
   29|      0|                    }: super::PropertyCreationInfo,
   30|      0|                ) -> Self {
   31|       |                    use crate::data::properties::ObsNumberType;
   32|       |                    use num_traits::FromPrimitive;
   33|       |
   34|      0|                    let min = unsafe { libobs::[<obs_property_ $obs_number_name _min>](pointer) };
   35|      0|                    let max = unsafe { libobs::[<obs_property_ $obs_number_name _max>](pointer) };
   36|      0|                    let step = unsafe { libobs::[<obs_property_ $obs_number_name _step>](pointer)};
   37|       |
   38|      0|                    let suffix = unsafe { libobs::[<obs_property_ $obs_number_name _suffix>](pointer) };
   39|      0|                    let suffix = if suffix.is_null() {
   40|      0|                        String::new()
   41|       |                    } else {
   42|      0|                        let suffix = unsafe { std::ffi::CStr::from_ptr(suffix) };
   43|      0|                        let suffix = suffix.to_str().unwrap_or_default();
   44|      0|                        suffix.to_string()
   45|       |                    };
   46|       |
   47|      0|                    let number_type = unsafe { libobs::[<obs_property_ $obs_number_name _type >](pointer) };
   48|      0|                    let number_type = ObsNumberType::from_i32(number_type);
   49|      0|                    if number_type.is_none() {
   50|      0|                        panic!("Invalid number type got none");
   51|      0|                    }
   52|       |
   53|      0|                    return ObsNumberProperty {
   54|      0|                        name,
   55|      0|                        description,
   56|      0|                        min,
   57|      0|                        max,
   58|      0|                        step,
   59|      0|                        suffix,
   60|      0|                        number_type: number_type.unwrap(),
   61|      0|                    };
   62|      0|                }
   63|       |            }
   64|       |        }
   65|       |    };
   66|       |}
   67|       |
   68|       |impl_from_property!(i32, int);
   69|       |impl_from_property!(f64, float);

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\types\path.rs:
    1|       |use getters0::Getters;
    2|       |
    3|       |use crate::data::properties::{get_enum, get_opt_str, macros::assert_type, ObsPathType};
    4|       |
    5|       |use super::PropertyCreationInfo;
    6|       |
    7|       |#[derive(Debug, Getters, Clone)]
    8|       |#[skip_new]
    9|       |pub struct ObsPathProperty {
   10|       |    name: String,
   11|       |    description: Option<String>,
   12|       |    path_type: ObsPathType,
   13|       |    filter: String,
   14|       |    default_path: String,
   15|       |}
   16|       |
   17|       |impl From<PropertyCreationInfo> for ObsPathProperty {
   18|      0|    fn from(
   19|      0|        PropertyCreationInfo {
   20|      0|            name,
   21|      0|            description,
   22|      0|            pointer,
   23|      0|        }: PropertyCreationInfo,
   24|      0|    ) -> Self {
   25|      0|        assert_type!(Path, pointer);
   26|       |
   27|      0|        let path_type = get_enum!(pointer, path_type, ObsPathType);
   28|      0|        let filter = get_opt_str!(pointer, path_filter).unwrap_or_default();
   29|      0|        let default_path = get_opt_str!(pointer, path_default_path).unwrap_or_default();
   30|      0|        Self {
   31|      0|            name,
   32|      0|            description,
   33|      0|            path_type,
   34|      0|            filter,
   35|      0|            default_path,
   36|      0|        }
   37|      0|    }
   38|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\properties\types\text.rs:
    1|       |use getters0::Getters;
    2|       |
    3|       |use crate::data::properties::{get_enum, macros::assert_type, ObsTextInfoType, ObsTextType};
    4|       |
    5|       |use super::PropertyCreationInfo;
    6|       |
    7|       |#[derive(Debug, Getters, Clone)]
    8|       |#[skip_new]
    9|       |pub struct ObsTextProperty {
   10|       |    name: String,
   11|       |    description: Option<String>,
   12|       |    monospace: bool,
   13|       |    text_type: ObsTextType,
   14|       |    info_type: ObsTextInfoType,
   15|       |    word_wrap: bool,
   16|       |}
   17|       |
   18|       |impl From<PropertyCreationInfo> for ObsTextProperty {
   19|      0|    fn from(
   20|      0|        PropertyCreationInfo {
   21|      0|            name,
   22|      0|            description,
   23|      0|            pointer,
   24|      0|        }: PropertyCreationInfo,
   25|      0|    ) -> Self {
   26|      0|        assert_type!(Text, pointer);
   27|       |
   28|      0|        let info_type = get_enum!(pointer, text_info_type, ObsTextInfoType);
   29|      0|        let text_type = get_enum!(pointer, text_type, ObsTextType);
   30|       |
   31|      0|        let monospace = unsafe { libobs::obs_property_text_monospace(pointer) };
   32|      0|        let word_wrap = unsafe { libobs::obs_property_text_info_word_wrap(pointer) };
   33|       |
   34|      0|        ObsTextProperty {
   35|      0|            name,
   36|      0|            description,
   37|      0|            monospace,
   38|      0|            text_type,
   39|      0|            info_type,
   40|      0|            word_wrap,
   41|      0|        }
   42|      0|    }
   43|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\updater.rs:
    1|       |use std::sync::Arc;
    2|       |
    3|       |use libobs::obs_data;
    4|       |
    5|       |use crate::{
    6|       |    run_with_obs,
    7|       |    unsafe_send::Sendable,
    8|       |    utils::{ObsError, ObsString},
    9|       |};
   10|       |
   11|       |use super::_ObsDataDropGuard;
   12|       |
   13|       |#[derive(Debug)]
   14|       |pub enum ObsDataChange {
   15|       |    String(ObsString, ObsString),
   16|       |    Int(ObsString, i64),
   17|       |    Bool(ObsString, bool),
   18|       |    Double(ObsString, f64),
   19|       |}
   20|       |
   21|       |#[derive(Debug)]
   22|       |/// Important: Make sure to call `update()` after setting the values.
   23|       |/// This will apply the changes to the `ObsData` object.
   24|       |#[must_use = "The `update()` method must be called to apply changes."]
   25|       |pub struct ObsDataUpdater {
   26|       |    pub(crate) changes: Vec<ObsDataChange>,
   27|       |    pub(crate) obs_data: Sendable<*mut obs_data>,
   28|       |    pub(crate) _drop_guard: Arc<_ObsDataDropGuard>,
   29|       |}
   30|       |
   31|       |impl ObsDataUpdater {
   32|     24|    pub fn set_string_ref(&mut self, key: impl Into<ObsString>, value: impl Into<ObsString>) {
   33|     24|        let key = key.into();
   34|     24|        let value = value.into();
   35|       |
   36|     24|        log::trace!("Setting string: {:?} = {:?}", key, value);
                                  ^0
   37|     24|        self.changes.push(ObsDataChange::String(key, value));
   38|     24|    }
   39|       |
   40|     18|    pub fn set_string(mut self, key: impl Into<ObsString>, value: impl Into<ObsString>) -> Self {
   41|     18|        self.set_string_ref(key, value);
   42|     18|        self
   43|     18|    }
   44|       |
   45|     20|    pub fn set_int_ref(&mut self, key: impl Into<ObsString>, value: i64) {
   46|     20|        let key = key.into();
   47|     20|        self.changes.push(ObsDataChange::Int(key, value));
   48|     20|    }
   49|       |
   50|     12|    pub fn set_int(mut self, key: impl Into<ObsString>, value: i64) -> Self {
   51|     12|        self.set_int_ref(key, value);
   52|     12|        self
   53|     12|    }
   54|       |
   55|     12|    pub fn set_bool_ref(&mut self, key: impl Into<ObsString>, value: bool) {
   56|     12|        let key = key.into();
   57|     12|        self.changes.push(ObsDataChange::Bool(key, value));
   58|     12|    }
   59|       |
   60|     12|    pub fn set_bool(mut self, key: impl Into<ObsString>, value: bool) -> Self {
   61|     12|        self.set_bool_ref(key, value);
   62|     12|        self
   63|     12|    }
   64|       |
   65|     20|    pub fn update(self) -> Result<(), ObsError> {
   66|       |        let ObsDataUpdater {
   67|     20|            changes,
   68|     20|            obs_data,
   69|     20|            _drop_guard,
   70|     20|        } = self;
   71|       |
   72|     20|        let obs_data = obs_data.clone();
   73|     20|        run_with_obs!(_drop_guard.runtime, (obs_data), move || unsafe {
   74|     76|            for change in changes {
                              ^56
   75|     56|                match change {
   76|     24|                    ObsDataChange::String(key, value) => {
   77|     24|                        libobs::obs_data_set_string(obs_data, key.as_ptr().0, value.as_ptr().0)
   78|       |                    }
   79|     20|                    ObsDataChange::Int(key, value) => {
   80|     20|                        libobs::obs_data_set_int(obs_data, key.as_ptr().0, value)
   81|       |                    }
   82|     12|                    ObsDataChange::Bool(key, value) => {
   83|     12|                        libobs::obs_data_set_bool(obs_data, key.as_ptr().0, value)
   84|       |                    }
   85|      0|                    ObsDataChange::Double(key, value) => {
   86|      0|                        libobs::obs_data_set_double(obs_data, key.as_ptr().0, value)
   87|       |                    }
   88|       |                };
   89|       |            }
   90|     20|        })
   91|     20|    }
   92|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\data\video.rs:
    1|       |use std::{boxed::Box, pin::Pin};
    2|       |
    3|       |use display_info::DisplayInfo;
    4|       |use libobs::obs_video_info;
    5|       |
    6|       |use crate::{
    7|       |    enums::{
    8|       |        ObsColorspace, ObsGraphicsModule, ObsScaleType, ObsVideoFormat, ObsVideoRange, OsEnumType,
    9|       |    },
   10|       |    unsafe_send::Sendable,
   11|       |    utils::ObsString,
   12|       |};
   13|       |
   14|       |/// A wrapper for `obs_video_info`, which is used
   15|       |/// to pass information to libobs for the new OBS
   16|       |/// video context after resetting the old OBS
   17|       |/// video context.
   18|       |/// A wrapper for `obs_video_info`, which is used
   19|       |/// to pass information to libobs for the new OBS
   20|       |/// video context after resetting the old OBS
   21|       |/// video context. The obs_video_info is pinned in memory
   22|       |/// to ensure its address never changes, as required by libobs.
   23|       |#[derive(Debug)]
   24|       |pub struct ObsVideoInfo {
   25|       |    ovi: Sendable<Pin<Box<obs_video_info>>>,
   26|       |    // False positive. This is necessary to ensure
   27|       |    // that the graphics module string in the
   28|       |    // `obs_video_info` struct does not free.
   29|       |    #[allow(dead_code)]
   30|       |    graphics_module: ObsString,
   31|       |}
   32|       |
   33|       |impl ObsVideoInfo {
   34|       |    /// Creates a new `ObsVideoInfo`.
   35|       |    ///
   36|       |    /// Note that this function is not meant to
   37|       |    /// be used externally. The recommended,
   38|       |    /// supported way to build new `ObsVideoInfo`
   39|       |    /// structs is through `ObsVideoInfoBuilder`.
   40|      0|    pub fn new(ovi: obs_video_info, graphics_module: ObsString) -> Self {
   41|      0|        Self {
   42|      0|            ovi: Sendable(Box::pin(ovi)),
   43|      0|            graphics_module,
   44|      0|        }
   45|      0|    }
   46|       |
   47|       |    /// Returns a pointer to the pinned `obs_video_info`.
   48|     15|    pub fn as_ptr(&self) -> *mut obs_video_info {
   49|       |        // Safe because ovi is pinned for the lifetime of this struct
   50|     15|        let ptr: *const obs_video_info = &*Pin::as_ref(&self.ovi.0);
   51|     15|        ptr as *mut obs_video_info
   52|     15|    }
   53|       |
   54|     12|    pub fn graphics_module(&self) -> &ObsString {
   55|     12|        &self.graphics_module
   56|     12|    }
   57|       |
   58|      0|    pub fn get_fps_num(&self) -> u32 {
   59|      0|        self.ovi.0.fps_num
   60|      0|    }
   61|       |
   62|      0|    pub fn get_fps_den(&self) -> u32 {
   63|      0|        self.ovi.0.fps_den
   64|      0|    }
   65|       |
   66|      0|    pub fn get_base_width(&self) -> u32 {
   67|      0|        self.ovi.0.base_width
   68|      0|    }
   69|       |
   70|      0|    pub fn get_base_height(&self) -> u32 {
   71|      0|        self.ovi.0.base_height
   72|      0|    }
   73|       |
   74|      0|    pub fn get_output_width(&self) -> u32 {
   75|      0|        self.ovi.0.output_width
   76|      0|    }
   77|       |
   78|      0|    pub fn get_output_height(&self) -> u32 {
   79|      0|        self.ovi.0.output_height
   80|      0|    }
   81|       |}
   82|       |
   83|       |impl Default for ObsVideoInfo {
   84|      9|    fn default() -> Self {
   85|      9|        ObsVideoInfoBuilder::new().build()
   86|      9|    }
   87|       |}
   88|       |
   89|       |/// A structure intended to help make
   90|       |/// creating new `ObsVideoInfo` structs
   91|       |/// easier for resetting the OBS video
   92|       |/// context.
   93|       |#[derive(Clone, Debug)]
   94|       |pub struct ObsVideoInfoBuilder {
   95|       |    adapter: u32,
   96|       |    graphics_module: ObsGraphicsModule,
   97|       |    fps_num: u32,
   98|       |    fps_den: u32,
   99|       |    base_width: u32,
  100|       |    base_height: u32,
  101|       |    output_width: u32,
  102|       |    output_height: u32,
  103|       |    output_format: ObsVideoFormat,
  104|       |    gpu_conversion: bool,
  105|       |    colorspace: ObsColorspace,
  106|       |    range: ObsVideoRange,
  107|       |    scale_type: ObsScaleType,
  108|       |}
  109|       |
  110|       |impl ObsVideoInfoBuilder {
  111|       |    /// Creates a new `ObsVideoInfoBuilder`
  112|       |    /// for creating new `ObsVideoInfo` to
  113|       |    /// pass to the video context reset
  114|       |    /// function.
  115|       |    ///
  116|       |    /// This function comes with
  117|       |    /// sensible default values and chooses
  118|       |    /// the backend depending on which
  119|       |    /// if the OS supports DX11 (Windows)
  120|       |    /// or not (OpenGL on MacOS and Unix).
  121|     16|    pub fn new() -> Self {
  122|     16|        let display_infos = DisplayInfo::all().unwrap();
  123|     16|        let (mut width, mut height) = (1920, 1080);
  124|     16|        for display_info in display_infos {
  125|     16|            if display_info.is_primary {
  126|     16|                width = display_info.width;
  127|     16|                height = display_info.height;
  128|     16|                break;
  129|      0|            }
  130|       |        }
  131|       |
  132|     16|        Self {
  133|     16|            adapter: 0,
  134|     16|            #[cfg(target_family = "unix")]
  135|     16|            graphics_module: ObsGraphicsModule::OpenGL,
  136|     16|            #[cfg(target_family = "windows")]
  137|     16|            graphics_module: ObsGraphicsModule::DirectX11,
  138|     16|            fps_num: 30,
  139|     16|            fps_den: 1,
  140|     16|            base_width: width,
  141|     16|            base_height: height,
  142|     16|            output_width: width,
  143|     16|            output_height: height,
  144|     16|            output_format: ObsVideoFormat::NV12,
  145|     16|            gpu_conversion: true,
  146|     16|            colorspace: ObsColorspace::CS709,
  147|     16|            range: ObsVideoRange::Default,
  148|     16|            scale_type: ObsScaleType::Lanczos,
  149|     16|        }
  150|     16|    }
  151|       |
  152|       |    /// Consumes the `ObsVideoInfoBuilder`
  153|       |    /// to create an `ObsVideoInfo`.
  154|     16|    pub fn build(self) -> ObsVideoInfo {
  155|     16|        let graphics_mod_str = match self.graphics_module {
  156|      0|            ObsGraphicsModule::OpenGL => ObsString::new("libobs-opengl"),
  157|     16|            ObsGraphicsModule::DirectX11 => ObsString::new("libobs-d3d11.dll"),
  158|       |        };
  159|       |
  160|     16|        let ovi = obs_video_info {
  161|     16|            adapter: self.adapter,
  162|     16|            graphics_module: graphics_mod_str.as_ptr().0,
  163|     16|            fps_num: self.fps_num,
  164|     16|            fps_den: self.fps_den,
  165|     16|            base_width: self.base_width,
  166|     16|            base_height: self.base_height,
  167|     16|            output_width: self.output_width,
  168|     16|            output_height: self.output_height,
  169|     16|            output_format: self.output_format as OsEnumType,
  170|     16|            gpu_conversion: self.gpu_conversion,
  171|     16|            colorspace: self.colorspace as OsEnumType,
  172|     16|            range: self.range as OsEnumType,
  173|     16|            scale_type: self.scale_type as OsEnumType,
  174|     16|        };
  175|       |
  176|     16|        ObsVideoInfo {
  177|     16|            ovi: Sendable(Box::pin(ovi)),
  178|     16|            graphics_module: graphics_mod_str,
  179|     16|        }
  180|     16|    }
  181|       |
  182|       |    /// Sets the GPU adapter device
  183|       |    /// that the video output is coming
  184|       |    /// from.
  185|      7|    pub fn adapter(mut self, value: u32) -> Self {
  186|      7|        self.adapter = value;
  187|      7|        self
  188|      7|    }
  189|       |
  190|       |    /// Sets the graphics backend
  191|       |    /// that libobs uses to record.
  192|      0|    pub fn graphics_module(mut self, value: ObsGraphicsModule) -> Self {
  193|      0|        self.graphics_module = value;
  194|      0|        self
  195|      0|    }
  196|       |
  197|       |    /// Sets the framerate of the
  198|       |    /// output video. Note that this
  199|       |    /// value may not reflect the
  200|       |    /// final framerate if `fps_den`
  201|       |    /// is not equal to 1.
  202|      7|    pub fn fps_num(mut self, value: u32) -> Self {
  203|      7|        self.fps_num = value;
  204|      7|        self
  205|      7|    }
  206|       |
  207|       |    /// Divides the FPS numerator to
  208|       |    /// allow for fractional FPS
  209|       |    /// counts on output.
  210|      7|    pub fn fps_den(mut self, value: u32) -> Self {
  211|      7|        self.fps_den = value;
  212|      7|        self
  213|      7|    }
  214|       |
  215|       |    /// Sets the width of the screen
  216|       |    /// being recorded.
  217|      7|    pub fn base_width(mut self, value: u32) -> Self {
  218|      7|        self.base_width = value;
  219|      7|        self
  220|      7|    }
  221|       |
  222|       |    /// Sets the height of the screen
  223|       |    /// being recorded.
  224|      7|    pub fn base_height(mut self, value: u32) -> Self {
  225|      7|        self.base_height = value;
  226|      7|        self
  227|      7|    }
  228|       |
  229|       |    /// Sets the width of the video
  230|       |    /// output.
  231|      7|    pub fn output_width(mut self, value: u32) -> Self {
  232|      7|        self.output_width = value;
  233|      7|        self
  234|      7|    }
  235|       |
  236|       |    /// Sets the height of the video
  237|       |    /// output.
  238|      7|    pub fn output_height(mut self, value: u32) -> Self {
  239|      7|        self.output_height = value;
  240|      7|        self
  241|      7|    }
  242|       |
  243|       |    /// Sets the format in which the
  244|       |    /// video will be output.
  245|      0|    pub fn output_format(mut self, value: ObsVideoFormat) -> Self {
  246|      0|        self.output_format = value;
  247|      0|        self
  248|      0|    }
  249|       |
  250|       |    /// Sets whether the GPU will handle
  251|       |    /// conversion in the video.
  252|      0|    pub fn gpu_conversion(mut self, value: bool) -> Self {
  253|      0|        self.gpu_conversion = value;
  254|      0|        self
  255|      0|    }
  256|       |
  257|       |    /// Sets the video colorspace.
  258|      0|    pub fn colorspace(mut self, value: ObsColorspace) -> Self {
  259|      0|        self.colorspace = value;
  260|      0|        self
  261|      0|    }
  262|       |
  263|       |    /// Sets the video range.
  264|      0|    pub fn range(mut self, value: ObsVideoRange) -> Self {
  265|      0|        self.range = value;
  266|      0|        self
  267|      0|    }
  268|       |
  269|       |    /// Sets the video scaling type.
  270|      7|    pub fn scale_type(mut self, value: ObsScaleType) -> Self {
  271|      7|        self.scale_type = value;
  272|      7|        self
  273|      7|    }
  274|       |}
  275|       |
  276|       |impl Default for ObsVideoInfoBuilder {
  277|      0|    fn default() -> Self {
  278|      0|        Self::new()
  279|      0|    }
  280|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\display\creation_data.rs:
    1|       |use libobs::{gs_init_data, gs_window};
    2|       |use num_traits::ToPrimitive;
    3|       |
    4|       |use crate::unsafe_send::Sendable;
    5|       |
    6|       |use super::{GsColorFormat, GsZstencilFormat};
    7|       |
    8|       |#[derive(Clone)]
    9|       |pub struct ObsDisplayCreationData {
   10|       |    #[cfg(target_family = "windows")]
   11|       |    pub(super) window_handle: Sendable<windows::Win32::Foundation::HWND>,
   12|       |    pub(super) create_child: bool,
   13|       |    pub(super) x: i32,
   14|       |    pub(super) y: i32,
   15|       |    pub(super) width: u32,
   16|       |    pub(super) height: u32,
   17|       |    pub(super) format: GsColorFormat,
   18|       |    pub(super) zsformat: GsZstencilFormat,
   19|       |    pub(super) adapter: u32,
   20|       |    pub(super) backbuffers: u32,
   21|       |    pub(super) background_color: u32,
   22|       |}
   23|       |
   24|       |impl ObsDisplayCreationData {
   25|       |    #[cfg(target_family = "windows")]
   26|      0|    pub fn new(window_handle: isize, x: i32, y: i32, width: u32, height: u32) -> Self {
   27|       |        use std::os::raw::c_void;
   28|       |        use windows::Win32::Foundation::HWND;
   29|       |
   30|      0|        Self {
   31|      0|            window_handle: Sendable(HWND(window_handle as *mut c_void)),
   32|      0|            create_child: true,
   33|      0|            format: GsColorFormat::BGRA,
   34|      0|            zsformat: GsZstencilFormat::ZSNone,
   35|      0|            x,
   36|      0|            y,
   37|      0|            width,
   38|      0|            height,
   39|      0|            adapter: 0,
   40|      0|            backbuffers: 0,
   41|      0|            background_color: 0,
   42|      0|        }
   43|      0|    }
   44|       |
   45|      0|    pub fn set_format(mut self, format: GsColorFormat) -> Self {
   46|      0|        self.format = format;
   47|      0|        self
   48|      0|    }
   49|       |
   50|      0|    pub fn set_zsformat(mut self, zsformat: GsZstencilFormat) -> Self {
   51|      0|        self.zsformat = zsformat;
   52|      0|        self
   53|      0|    }
   54|       |
   55|      0|    pub fn set_adapter(mut self, adapter: u32) -> Self {
   56|      0|        self.adapter = adapter;
   57|      0|        self
   58|      0|    }
   59|       |
   60|      0|    pub fn set_backbuffers(mut self, backbuffers: u32) -> Self {
   61|      0|        self.backbuffers = backbuffers;
   62|      0|        self
   63|      0|    }
   64|       |
   65|      0|    pub fn set_background_color(mut self, background_color: u32) -> Self {
   66|      0|        self.background_color = background_color;
   67|      0|        self
   68|      0|    }
   69|       |
   70|      0|    pub fn set_create_child(mut self, should_create: bool) -> Self {
   71|      0|        self.create_child = should_create;
   72|      0|        self
   73|      0|    }
   74|       |
   75|      0|    pub(super) fn build(self, window: gs_window) -> gs_init_data {
   76|      0|        gs_init_data {
   77|      0|            cx: self.width,
   78|      0|            cy: self.height,
   79|      0|            format: self.format.to_i32().unwrap(),
   80|      0|            zsformat: self.zsformat.to_i32().unwrap(),
   81|      0|            window,
   82|      0|            adapter: self.adapter,
   83|      0|            num_backbuffers: self.backbuffers,
   84|      0|        }
   85|      0|    }
   86|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\display\mod.rs:
    1|       |//! For this display method to work, another preview window has to be created in order to create a swapchain
    2|       |//! This is because the main window renderer is already handled by other processes
    3|       |
    4|       |mod creation_data;
    5|       |mod enums;
    6|       |mod window_manager;
    7|       |
    8|       |pub use creation_data::*;
    9|       |pub use enums::*;
   10|       |use libobs::obs_video_info;
   11|       |pub use window_manager::*;
   12|       |
   13|       |use std::{
   14|       |    ffi::c_void,
   15|       |    marker::PhantomPinned,
   16|       |    sync::{atomic::AtomicUsize, Arc, RwLock},
   17|       |};
   18|       |
   19|       |use crate::{run_with_obs, runtime::ObsRuntime, unsafe_send::Sendable, utils::ObsError};
   20|       |
   21|       |static ID_COUNTER: AtomicUsize = AtomicUsize::new(1);
   22|       |#[derive(Debug, Clone)]
   23|       |//TODO: This has to be checked again, I'm unsure with pinning and draw callbacks from OBS
   24|       |/// # NEVER STORE THIS REF DIRECTLY!!
   25|       |/// This is a wrapper around the obs_display struct and contains direct memory references.
   26|       |/// You should ALWAYS use the context to get to this struct, and as said NEVER store it.
   27|       |pub struct ObsDisplayRef {
   28|       |    display: Sendable<*mut libobs::obs_display_t>,
   29|       |    id: usize,
   30|       |
   31|       |    // The callbacks and obs display first
   32|       |    _guard: Arc<RwLock<_DisplayDropGuard>>,
   33|       |
   34|       |    // Keep for window, manager is accessed by render thread as well so Arc and RwLock
   35|       |    manager: Arc<RwLock<DisplayWindowManager>>,
   36|       |    /// This must not be moved in memory as the draw callback is a raw pointer to this struct
   37|       |    _fixed_in_heap: PhantomPinned,
   38|       |
   39|       |    /// Stored so the obs context is not dropped while this is alive
   40|       |    pub(crate) runtime: ObsRuntime,
   41|       |}
   42|       |
   43|      0|unsafe extern "C" fn render_display(data: *mut c_void, _cx: u32, _cy: u32) {
   44|      0|    let s = &*(data as *mut ObsDisplayRef);
   45|       |
   46|      0|    let r = s.get_size();
   47|      0|    if r.is_err() {
   48|      0|        log::error!("Failed to get display size: {:?}", r.err());
   49|      0|        return;
   50|      0|    }
   51|       |
   52|      0|    let (width, height) = r.unwrap();
   53|      0|    let mut ovi: obs_video_info = std::mem::zeroed();
   54|      0|    libobs::obs_get_video_info(&mut ovi);
   55|       |
   56|      0|    libobs::gs_viewport_push();
   57|      0|    libobs::gs_projection_push();
   58|       |
   59|      0|    libobs::gs_ortho(
   60|       |        0.0f32,
   61|      0|        ovi.base_width as f32,
   62|       |        0.0f32,
   63|      0|        ovi.base_height as f32,
   64|       |        -100.0f32,
   65|       |        100.0f32,
   66|       |    );
   67|      0|    libobs::gs_set_viewport(0, 0, width as i32, height as i32);
   68|       |    //draw_backdrop(&s.buffers, ovi.base_width as f32, ovi.base_height as f32);
   69|       |
   70|      0|    libobs::obs_render_main_texture();
   71|       |
   72|      0|    libobs::gs_projection_pop();
   73|      0|    libobs::gs_viewport_pop();
   74|      0|}
   75|       |
   76|       |impl ObsDisplayRef {
   77|       |    #[cfg(target_family = "windows")]
   78|       |    /// Call initialize to ObsDisplay#create the display
   79|       |    /// NOTE: This must be pinned to prevent the draw callbacks from having a invalid pointer. DO NOT UNPIN
   80|      0|    pub(crate) fn new(
   81|      0|        data: creation_data::ObsDisplayCreationData,
   82|      0|        runtime: ObsRuntime,
   83|      0|    ) -> anyhow::Result<std::pin::Pin<Box<Self>>> {
   84|       |        use std::sync::atomic::Ordering;
   85|       |
   86|       |        use anyhow::bail;
   87|       |        use creation_data::ObsDisplayCreationData;
   88|       |        use libobs::gs_window;
   89|       |        use window_manager::DisplayWindowManager;
   90|       |
   91|       |        use crate::run_with_obs;
   92|       |
   93|       |        let ObsDisplayCreationData {
   94|      0|            x,
   95|      0|            y,
   96|      0|            height,
   97|      0|            width,
   98|      0|            window_handle,
   99|      0|            background_color,
  100|      0|            create_child,
  101|       |            ..
  102|      0|        } = data.clone();
  103|       |
  104|      0|        let mut manager = if create_child {
  105|      0|            DisplayWindowManager::new_child(window_handle.clone(), x, y, width, height)?
  106|       |        } else {
  107|      0|            DisplayWindowManager::new(window_handle.clone(), x, y, width, height)
  108|       |        };
  109|       |
  110|      0|        let preview_window_handle = Sendable(manager.get_window_handle());
  111|      0|        let init_data = Sendable(data.build(gs_window {
  112|      0|            hwnd: preview_window_handle.0 .0,
  113|      0|        }));
  114|       |
  115|      0|        log::trace!("Creating obs display...");
  116|      0|        let display = run_with_obs!(runtime, (init_data), move || unsafe {
  117|      0|            Sendable(libobs::obs_display_create(&init_data, background_color))
  118|      0|        })?;
  119|       |
  120|      0|        if display.0.is_null() {
  121|      0|            bail!("OBS failed to create display");
  122|      0|        }
  123|       |
  124|      0|        manager.obs_display = Some(display.clone());
  125|      0|        let mut instance = Box::pin(Self {
  126|      0|            display: display.clone(),
  127|      0|            manager: Arc::new(RwLock::new(manager)),
  128|      0|            id: ID_COUNTER.fetch_add(1, Ordering::Relaxed),
  129|      0|            _guard: Arc::new(RwLock::new(_DisplayDropGuard {
  130|      0|                display,
  131|      0|                self_ptr: None,
  132|      0|                runtime: runtime.clone(),
  133|      0|            })),
  134|      0|            _fixed_in_heap: PhantomPinned,
  135|      0|            runtime: runtime.clone(),
  136|      0|        });
  137|       |
  138|      0|        let instance_ptr =
  139|      0|            Sendable(unsafe { instance.as_mut().get_unchecked_mut() as *mut _ as *mut c_void });
  140|       |
  141|      0|        instance
  142|      0|            ._guard
  143|      0|            .write()
  144|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?
  145|      0|            .self_ptr = Some(instance_ptr.clone());
  146|       |
  147|      0|        let pos = instance.get_pos();
  148|      0|        log::trace!(
  149|      0|            "Adding draw callback with display {:?} and draw callback params at {:?} (pos is {:?})...",
  150|      0|            instance.display,
  151|       |            instance_ptr,
  152|       |            pos
  153|       |        );
  154|      0|        let display_ptr = instance.display.clone();
  155|      0|        run_with_obs!(runtime, (display_ptr, instance_ptr), move || unsafe {
  156|      0|            libobs::obs_display_add_draw_callback(display_ptr, Some(render_display), instance_ptr);
  157|      0|        })?;
  158|       |
  159|      0|        Ok(instance)
  160|      0|    }
  161|       |
  162|      0|    pub fn id(&self) -> usize {
  163|      0|        self.id
  164|      0|    }
  165|       |}
  166|       |
  167|       |#[derive(Debug)]
  168|       |struct _DisplayDropGuard {
  169|       |    display: Sendable<*mut libobs::obs_display_t>,
  170|       |    self_ptr: Option<Sendable<*mut c_void>>,
  171|       |    runtime: ObsRuntime,
  172|       |}
  173|       |
  174|       |impl _DisplayDropGuard {
  175|      0|    pub fn inner_drop(
  176|      0|        r: ObsRuntime,
  177|      0|        display: Sendable<*mut libobs::obs_display_t>,
  178|      0|        self_ptr: Option<Sendable<*mut c_void>>,
  179|      0|    ) -> Result<(), ObsError> {
  180|      0|        run_with_obs!(r, (display), move || unsafe {
  181|      0|            if let Some(ptr) = &self_ptr {
  182|      0|                log::trace!("Destroying display with callback at {:?}...", ptr.0);
  183|      0|                libobs::obs_display_remove_draw_callback(display, Some(render_display), ptr.0);
  184|      0|            }
  185|       |
  186|      0|            libobs::obs_display_destroy(display);
  187|      0|        })
  188|      0|    }
  189|       |}
  190|       |
  191|       |impl Drop for _DisplayDropGuard {
  192|      0|    fn drop(&mut self) {
  193|      0|        log::trace!("Dropping ObsDisplayRef guard...");
  194|       |
  195|      0|        let display = self.display.clone();
  196|      0|        let self_ptr = self.self_ptr.clone();
  197|      0|        let r = self.runtime.clone();
  198|       |
  199|       |        #[cfg(not(feature = "no_blocking_drops"))]
  200|       |        {
  201|      0|            let r = _DisplayDropGuard::inner_drop(r, display, self_ptr);
  202|      0|            if std::thread::panicking() {
  203|      0|                return;
  204|      0|            }
  205|       |
  206|      0|            r.unwrap();
  207|       |        }
  208|       |
  209|       |        #[cfg(feature = "no_blocking_drops")]
  210|       |        {
  211|       |            tokio::task::spawn_blocking(move || {
  212|       |                _DisplayDropGuard::inner_drop(r, display, self_ptr).unwrap();
  213|       |            });
  214|       |        }
  215|      0|    }
  216|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\display\window_manager\misc.rs:
    1|       |use crate::{display::ObsDisplayRef, run_with_obs, utils::ObsError};
    2|       |
    3|       |pub trait MiscDisplayTrait {
    4|       |    fn update_color_space(&self) -> Result<(), ObsError>;
    5|       |
    6|       |    fn is_enabled(&self) -> Result<bool, ObsError>;
    7|       |
    8|       |    fn set_enabled(&self, enabled: bool) -> Result<(), ObsError>;
    9|       |
   10|       |    fn set_background_color(&self, r: u8, g: u8, b: u8) -> Result<(), ObsError>;
   11|       |}
   12|       |
   13|       |impl MiscDisplayTrait for ObsDisplayRef {
   14|      0|    fn update_color_space(&self) -> Result<(), ObsError> {
   15|      0|        let display_ptr = self.display.clone();
   16|      0|        run_with_obs!(self.runtime, (display_ptr), move || unsafe {
   17|      0|            libobs::obs_display_update_color_space(display_ptr)
   18|      0|        })
   19|      0|    }
   20|       |
   21|      0|    fn is_enabled(&self) -> Result<bool, ObsError> {
   22|      0|        let display_ptr = self.display.clone();
   23|      0|        run_with_obs!(self.runtime, (display_ptr), move || unsafe {
   24|      0|            libobs::obs_display_enabled(display_ptr)
   25|      0|        })
   26|      0|    }
   27|       |
   28|      0|    fn set_enabled(&self, enabled: bool) -> Result<(), ObsError> {
   29|      0|        let display_ptr = self.display.clone();
   30|       |
   31|      0|        run_with_obs!(self.runtime, (display_ptr), move || unsafe {
   32|      0|            libobs::obs_display_set_enabled(display_ptr, enabled)
   33|      0|        })
   34|      0|    }
   35|       |
   36|      0|    fn set_background_color(&self, r: u8, g: u8, b: u8) -> Result<(), ObsError> {
   37|      0|        let color: u32 = ((r as u32) << 16) | ((g as u32) << 8) | (b as u32);
   38|      0|        let display_ptr = self.display.clone();
   39|       |
   40|      0|        run_with_obs!(self.runtime, (display_ptr), move || unsafe {
   41|      0|            libobs::obs_display_set_background_color(display_ptr, color)
   42|      0|        })
   43|      0|    }
   44|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\display\window_manager\mod.rs:
    1|       |//! This
    2|       |
    3|       |use std::sync::{
    4|       |    atomic::{AtomicBool, Ordering},
    5|       |    Arc, Mutex,
    6|       |};
    7|       |
    8|       |use lazy_static::lazy_static;
    9|       |use libobs::obs_display_t;
   10|       |use windows::{
   11|       |    core::{w, HSTRING, PCWSTR},
   12|       |    Win32::{
   13|       |        Foundation::{COLORREF, HWND, LPARAM, LRESULT, WPARAM},
   14|       |        Graphics::Dwm::DwmIsCompositionEnabled,
   15|       |        System::{
   16|       |            LibraryLoader::{GetModuleHandleA, GetModuleHandleW},
   17|       |            SystemInformation::{GetVersionExW, OSVERSIONINFOW},
   18|       |        },
   19|       |        UI::WindowsAndMessaging::{
   20|       |            CreateWindowExW, DefWindowProcW, DispatchMessageW, GetMessageW, GetWindowLongPtrW,
   21|       |            LoadCursorW, PostMessageW, PostQuitMessage, RegisterClassExW,
   22|       |            SetLayeredWindowAttributes, SetParent, SetWindowLongPtrW, TranslateMessage, CS_HREDRAW,
   23|       |            CS_NOCLOSE, CS_OWNDC, CS_VREDRAW, GWL_EXSTYLE, GWL_STYLE, HTTRANSPARENT, IDC_ARROW,
   24|       |            LWA_ALPHA, MSG, WM_NCHITTEST, WNDCLASSEXW, WS_CHILD, WS_EX_COMPOSITED, WS_EX_LAYERED,
   25|       |            WS_EX_TRANSPARENT, WS_POPUP, WS_VISIBLE,
   26|       |        },
   27|       |    },
   28|       |};
   29|       |
   30|       |use crate::unsafe_send::Sendable;
   31|       |
   32|       |mod misc;
   33|       |mod position_trait;
   34|       |mod show_hide;
   35|       |pub use misc::*;
   36|       |pub use position_trait::WindowPositionTrait;
   37|       |pub use show_hide::ShowHideTrait;
   38|       |
   39|       |const WM_DESTROY_WINDOW: u32 = 0x8001; // Custom message
   40|      0|extern "system" fn wndproc(
   41|      0|    window: HWND,
   42|      0|    message: u32,
   43|      0|    w_param: WPARAM,
   44|      0|    l_param: LPARAM,
   45|      0|) -> LRESULT {
   46|       |    unsafe {
   47|      0|        match message {
   48|      0|            WM_NCHITTEST => LRESULT(HTTRANSPARENT as _),
   49|       |            WM_DESTROY_WINDOW => {
   50|      0|                PostQuitMessage(0);
   51|      0|                LRESULT(0)
   52|       |            }
   53|      0|            _ => DefWindowProcW(window, message, w_param, l_param),
   54|       |        }
   55|       |    }
   56|      0|}
   57|       |
   58|       |//TODO generated by AI, check later
   59|      0|fn is_windows8_or_greater() -> windows::core::Result<bool> {
   60|      0|    let mut os_info: OSVERSIONINFOW = unsafe { std::mem::zeroed() };
   61|      0|    os_info.dwOSVersionInfoSize = std::mem::size_of::<OSVERSIONINFOW>() as u32;
   62|       |
   63|       |    unsafe {
   64|      0|        GetVersionExW(&mut os_info)?;
   65|       |    }
   66|       |
   67|      0|    let r = (os_info.dwMajorVersion > 6)
   68|      0|        || (os_info.dwMajorVersion == 6 && os_info.dwMinorVersion >= 2);
   69|      0|    Ok(r)
   70|      0|}
   71|       |
   72|       |lazy_static! {
   73|       |    static ref REGISTERED_CLASS: AtomicBool = AtomicBool::new(false);
   74|       |}
   75|       |
   76|      0|fn try_register_class() -> windows::core::Result<()> {
   77|      0|    if REGISTERED_CLASS.load(Ordering::Relaxed) {
   78|      0|        return Ok(());
   79|      0|    }
   80|       |
   81|       |    unsafe {
   82|      0|        let instance = GetModuleHandleA(None)?;
   83|      0|        let cursor = LoadCursorW(None, IDC_ARROW)?;
   84|       |
   85|      0|        let mut style = CS_HREDRAW | CS_VREDRAW | CS_NOCLOSE;
   86|       |
   87|      0|        let enabled = DwmIsCompositionEnabled()?.as_bool();
   88|      0|        if is_windows8_or_greater()? || !enabled {
   89|      0|            style |= CS_OWNDC;
   90|      0|        }
   91|       |
   92|      0|        let window_class = w!("Win32DisplayClass");
   93|      0|        let wc = WNDCLASSEXW {
   94|      0|            cbSize: std::mem::size_of::<WNDCLASSEXW>() as u32,
   95|      0|            hCursor: cursor,
   96|      0|            hInstance: instance.into(),
   97|      0|            lpszClassName: window_class,
   98|      0|            style: CS_HREDRAW | CS_VREDRAW,
   99|      0|            lpfnWndProc: Some(wndproc),
  100|      0|            cbClsExtra: 0,
  101|      0|            cbWndExtra: 0,
  102|      0|            ..Default::default()
  103|      0|        };
  104|       |
  105|      0|        let atom = RegisterClassExW(&wc as *const _);
  106|      0|        if atom == 0 {
  107|      0|            return Err(std::io::Error::last_os_error().into());
  108|      0|        }
  109|       |    }
  110|       |
  111|      0|    REGISTERED_CLASS.store(true, Ordering::Relaxed);
  112|      0|    Ok(())
  113|      0|}
  114|       |
  115|       |#[derive(Debug)]
  116|       |pub struct DisplayWindowManager {
  117|       |    // Shouldn't really be needed
  118|       |    message_thread: Option<std::thread::JoinHandle<()>>,
  119|       |    should_exit: Arc<AtomicBool>,
  120|       |    hwnd: Sendable<HWND>,
  121|       |
  122|       |    x: i32,
  123|       |    y: i32,
  124|       |
  125|       |    width: u32,
  126|       |    height: u32,
  127|       |
  128|       |    scale: f32,
  129|       |
  130|       |    is_hidden: AtomicBool,
  131|       |
  132|       |    render_at_bottom: bool,
  133|       |
  134|       |    pub(super) obs_display: Option<Sendable<*mut obs_display_t>>,
  135|       |}
  136|       |
  137|       |impl DisplayWindowManager {
  138|      0|    pub fn new_child(
  139|      0|        parent: Sendable<HWND>,
  140|      0|        x: i32,
  141|      0|        y: i32,
  142|      0|        width: u32,
  143|      0|        height: u32,
  144|      0|    ) -> anyhow::Result<Self> {
  145|      0|        let (tx, rx) = oneshot::channel();
  146|       |
  147|      0|        let should_exit = Arc::new(AtomicBool::new(false));
  148|      0|        let tmp = should_exit.clone();
  149|       |
  150|      0|        let parent = Mutex::new(Sendable(parent));
  151|      0|        let message_thread = std::thread::spawn(move || {
  152|      0|            let parent = parent.lock().unwrap().0.clone();
  153|       |            // We have to have the whole window creation stuff here as well so the message loop functions
  154|      0|            let create = move || {
  155|      0|                log::trace!("Registering class...");
  156|      0|                try_register_class()?;
  157|      0|                let win8 = is_windows8_or_greater()?;
  158|      0|                let enabled = unsafe { DwmIsCompositionEnabled()?.as_bool() };
  159|       |
  160|      0|                let mut window_style = WS_EX_TRANSPARENT;
  161|      0|                if win8 && enabled {
  162|      0|                    window_style |= WS_EX_COMPOSITED;
  163|      0|                }
  164|       |
  165|      0|                let instance = unsafe { GetModuleHandleW(PCWSTR::null())? };
  166|       |
  167|      0|                let class_name = HSTRING::from("Win32DisplayClass");
  168|      0|                let window_name = HSTRING::from("LibObsChildWindowPreview");
  169|      0|                log::trace!("Creating window...");
  170|       |
  171|      0|                log::debug!(
  172|      0|                    "Creating window with x: {}, y: {}, width: {}, height: {}",
  173|       |                    x,
  174|       |                    y,
  175|       |                    width,
  176|       |                    height
  177|       |                );
  178|      0|                let window = unsafe {
  179|       |                    // More at https://github.com/stream-labs/obs-studio-node/blob/4e19d8a61a4dd7744e75ce77624c664e371cbfcf/obs-studio-server/source/nodeobs_display.cpp#L170
  180|      0|                    CreateWindowExW(
  181|       |                        WS_EX_LAYERED,
  182|      0|                        &class_name,
  183|      0|                        &window_name,
  184|      0|                        WS_POPUP | WS_VISIBLE,
  185|      0|                        x,
  186|      0|                        y,
  187|      0|                        width as i32,
  188|      0|                        height as i32,
  189|      0|                        None,
  190|      0|                        None,
  191|      0|                        Some(instance.into()),
  192|      0|                        None,
  193|      0|                    )?
  194|       |                };
  195|       |
  196|      0|                log::trace!("HWND is {:?}", window);
  197|      0|                if win8 || !enabled {
  198|      0|                    log::trace!("Setting attributes alpha...");
  199|       |                    unsafe {
  200|      0|                        SetLayeredWindowAttributes(window, COLORREF(0), 255, LWA_ALPHA)?;
  201|       |                    }
  202|      0|                }
  203|       |
  204|       |                unsafe {
  205|      0|                    log::trace!("Setting parent...");
  206|      0|                    SetParent(window, Some(parent.0))?;
  207|      0|                    log::trace!("Setting styles...");
  208|      0|                    let mut style = GetWindowLongPtrW(window, GWL_STYLE);
  209|       |                    //TODO Check casts here
  210|      0|                    style &= !(WS_POPUP.0 as isize);
  211|      0|                    style |= WS_CHILD.0 as isize;
  212|       |
  213|      0|                    SetWindowLongPtrW(window, GWL_STYLE, style);
  214|       |
  215|      0|                    let mut ex_style = GetWindowLongPtrW(window, GWL_EXSTYLE);
  216|      0|                    ex_style |= window_style.0 as isize;
  217|       |
  218|      0|                    SetWindowLongPtrW(window, GWL_EXSTYLE, ex_style);
  219|       |                }
  220|       |
  221|      0|                Result::<Sendable<HWND>, anyhow::Error>::Ok(Sendable(window))
  222|      0|            };
  223|       |
  224|      0|            let r = create();
  225|      0|            let window = r.as_ref().ok().map(|r| r.0);
  226|      0|            tx.send(r).unwrap();
  227|      0|            if window.is_none() {
  228|      0|                return;
  229|      0|            }
  230|      0|            let window = window.unwrap();
  231|       |
  232|      0|            log::trace!("Starting up message thread...");
  233|      0|            let mut msg = MSG::default();
  234|       |            unsafe {
  235|      0|                while !tmp.load(Ordering::Relaxed)
  236|      0|                    && GetMessageW(&mut msg, Some(window), 0, 0).as_bool()
  237|      0|                {
  238|      0|                    //TODO check if this can really be ignored
  239|      0|                    let _ = TranslateMessage(&msg);
  240|      0|                    DispatchMessageW(&msg);
  241|      0|                }
  242|       |            }
  243|       |
  244|      0|            log::trace!("Exiting message thread...");
  245|      0|        });
  246|       |
  247|      0|        let window = rx.recv();
  248|      0|        let window = window??;
  249|      0|        Ok(Self {
  250|      0|            x,
  251|      0|            y,
  252|      0|            width,
  253|      0|            height,
  254|      0|            scale: 1.0,
  255|      0|            hwnd: window,
  256|      0|            should_exit,
  257|      0|            message_thread: Some(message_thread),
  258|      0|            render_at_bottom: false,
  259|      0|            is_hidden: AtomicBool::new(false),
  260|      0|            obs_display: None,
  261|      0|        })
  262|      0|    }
  263|       |
  264|      0|    pub fn new(window_handle: Sendable<HWND>, x: i32, y: i32, width: u32, height: u32) -> Self {
  265|       |        // Should exit is not needed as the window is being managed by the sender
  266|      0|        Self {
  267|      0|            x,
  268|      0|            y,
  269|      0|            width,
  270|      0|            height,
  271|      0|            scale: 1.0,
  272|      0|            hwnd: window_handle,
  273|      0|            should_exit: Arc::new(AtomicBool::new(false)),
  274|      0|            message_thread: None,
  275|      0|            render_at_bottom: false,
  276|      0|            is_hidden: AtomicBool::new(false),
  277|      0|            obs_display: None,
  278|      0|        }
  279|      0|    }
  280|       |
  281|      0|    pub fn get_window_handle(&self) -> HWND {
  282|      0|        self.hwnd.0
  283|      0|    }
  284|       |}
  285|       |
  286|       |impl Drop for DisplayWindowManager {
  287|      0|    fn drop(&mut self) {
  288|      0|        log::trace!("Dropping DisplayWindowManager...");
  289|       |        unsafe {
  290|      0|            self.should_exit.store(true, Ordering::Relaxed);
  291|       |
  292|      0|            log::trace!("Destroying window...");
  293|      0|            let res = PostMessageW(Some(self.hwnd.0), WM_DESTROY_WINDOW, WPARAM(0), LPARAM(0));
  294|      0|            if let Err(err) = res {
  295|      0|                log::error!("Failed to post destroy window message: {:?}", err);
  296|      0|            }
  297|       |
  298|      0|            let thread = self.message_thread.take();
  299|      0|            if let Some(thread) = thread {
  300|      0|                log::trace!("Waiting for message thread to exit...");
  301|      0|                thread.join().unwrap();
  302|      0|            }
  303|       |        }
  304|      0|    }
  305|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\display\window_manager\position_trait.rs:
    1|       |use windows::Win32::{
    2|       |    Foundation::HWND,
    3|       |    Graphics::Gdi::{RedrawWindow, RDW_ERASE, RDW_INVALIDATE},
    4|       |    UI::WindowsAndMessaging::{
    5|       |        SetWindowPos, HWND_BOTTOM, SWP_NOACTIVATE, SWP_NOCOPYBITS, SWP_NOSIZE, SWP_NOZORDER,
    6|       |        SWP_SHOWWINDOW,
    7|       |    },
    8|       |};
    9|       |
   10|       |use crate::utils::ObsError;
   11|       |use crate::{display::ObsDisplayRef, run_with_obs};
   12|       |
   13|       |pub trait WindowPositionTrait {
   14|       |    fn set_render_at_bottom(&self, render_at_bottom: bool) -> Result<(), ObsError>;
   15|       |    fn get_render_at_bottom(&self) -> Result<bool, ObsError>;
   16|       |    fn set_pos(&self, x: i32, y: i32) -> Result<(), ObsError>;
   17|       |    fn set_size(&self, width: u32, height: u32) -> Result<(), ObsError>;
   18|       |    fn set_scale(&self, scale: f32) -> Result<(), ObsError>;
   19|       |
   20|       |    fn get_pos(&self) -> Result<(i32, i32), ObsError>;
   21|       |
   22|       |    fn get_size(&self) -> Result<(u32, u32), ObsError>;
   23|       |
   24|       |    fn get_scale(&self) -> Result<f32, ObsError>;
   25|       |}
   26|       |
   27|       |impl WindowPositionTrait for ObsDisplayRef {
   28|      0|    fn set_render_at_bottom(&self, render_at_bottom: bool) -> Result<(), ObsError> {
   29|      0|        log::trace!("Set render bottom");
   30|      0|        let mut m = self
   31|      0|            .manager
   32|      0|            .write()
   33|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   34|      0|        m.render_at_bottom = render_at_bottom;
   35|      0|        Ok(())
   36|      0|    }
   37|       |
   38|      0|    fn get_render_at_bottom(&self) -> Result<bool, ObsError> {
   39|      0|        let m = self
   40|      0|            .manager
   41|      0|            .read()
   42|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   43|      0|        Ok(m.render_at_bottom)
   44|      0|    }
   45|       |
   46|      0|    fn set_pos(&self, x: i32, y: i32) -> Result<(), ObsError> {
   47|      0|        log::trace!("Set pos {x} {y}");
   48|      0|        let mut m = self
   49|      0|            .manager
   50|      0|            .write()
   51|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   52|       |
   53|      0|        assert!(
   54|      0|            m.obs_display.is_some(),
   55|      0|            "Invalid state. The display should have been created and set, but it wasn't."
   56|       |        );
   57|       |
   58|      0|        let insert_after = if m.render_at_bottom {
   59|      0|            HWND_BOTTOM
   60|       |        } else {
   61|      0|            HWND::default()
   62|       |        };
   63|       |
   64|      0|        m.x = x;
   65|      0|        m.y = y;
   66|       |
   67|       |        unsafe {
   68|      0|            let flags = SWP_NOCOPYBITS | SWP_NOSIZE | SWP_NOACTIVATE;
   69|       |            // Just use dummy values as size is not changed
   70|      0|            SetWindowPos(m.hwnd.0, Some(insert_after), x, y, 1_i32, 1_i32, flags)
   71|      0|                .map_err(|e| ObsError::DisplayCreationError(format!("{:?}", e)))?;
   72|       |        }
   73|       |
   74|      0|        Ok(())
   75|      0|    }
   76|       |
   77|      0|    fn get_pos(&self) -> Result<(i32, i32), ObsError> {
   78|      0|        let m = self
   79|      0|            .manager
   80|      0|            .read()
   81|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   82|      0|        Ok((m.x, m.y))
   83|      0|    }
   84|       |
   85|      0|    fn get_size(&self) -> Result<(u32, u32), ObsError> {
   86|      0|        let m = self
   87|      0|            .manager
   88|      0|            .read()
   89|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   90|      0|        Ok((m.width, m.height))
   91|      0|    }
   92|       |
   93|      0|    fn set_size(&self, width: u32, height: u32) -> Result<(), ObsError> {
   94|      0|        log::trace!("Set size {width} {height}");
   95|      0|        let mut m = self
   96|      0|            .manager
   97|      0|            .write()
   98|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   99|      0|        assert!(
  100|      0|            m.obs_display.is_some(),
  101|      0|            "Invalid state. The display should have been created and set, but it wasn't."
  102|       |        );
  103|       |
  104|      0|        m.width = width;
  105|      0|        m.height = height;
  106|       |
  107|      0|        let pointer = m.obs_display.as_ref().unwrap().clone();
  108|       |        unsafe {
  109|      0|            SetWindowPos(
  110|      0|                m.hwnd.0,
  111|      0|                None,
  112|      0|                m.x,
  113|      0|                m.y,
  114|      0|                width as i32,
  115|      0|                height as i32,
  116|      0|                SWP_NOCOPYBITS | SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW,
  117|       |            )
  118|      0|            .map_err(|e| ObsError::DisplayCreationError(format!("{:?}", e)))?;
  119|       |
  120|      0|            let _ = RedrawWindow(Some(m.hwnd.0), None, None, RDW_ERASE | RDW_INVALIDATE);
  121|       |        }
  122|       |
  123|      0|        run_with_obs!(self.runtime, (pointer), move || unsafe {
  124|      0|            libobs::obs_display_resize(pointer, width, height);
  125|      0|        })
  126|      0|        .map_err(|e| ObsError::InvocationError(format!("{:?}", e)))?;
  127|      0|        Ok(())
  128|      0|    }
  129|       |
  130|      0|    fn set_scale(&self, scale: f32) -> Result<(), ObsError> {
  131|      0|        log::trace!("Set scale {scale}");
  132|      0|        let mut m = self
  133|      0|            .manager
  134|      0|            .write()
  135|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
  136|      0|        m.scale = scale;
  137|      0|        Ok(())
  138|      0|    }
  139|       |
  140|      0|    fn get_scale(&self) -> Result<f32, ObsError> {
  141|      0|        let m = self
  142|      0|            .manager
  143|      0|            .read()
  144|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
  145|      0|        Ok(m.scale)
  146|      0|    }
  147|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\display\window_manager\show_hide.rs:
    1|       |use std::sync::atomic::Ordering;
    2|       |
    3|       |use windows::Win32::UI::WindowsAndMessaging::{ShowWindow, SW_HIDE, SW_SHOWNA};
    4|       |
    5|       |use crate::display::ObsDisplayRef;
    6|       |use crate::utils::ObsError;
    7|       |
    8|       |pub trait ShowHideTrait {
    9|       |    /// Shows the window.
   10|       |    fn show(&mut self) -> Result<(), ObsError>;
   11|       |
   12|       |    /// Hides the window.
   13|       |    fn hide(&mut self) -> Result<(), ObsError>;
   14|       |
   15|       |    /// Returns true if the window is visible.
   16|       |    fn is_visible(&self) -> Result<bool, ObsError>;
   17|       |}
   18|       |
   19|       |impl ShowHideTrait for ObsDisplayRef {
   20|       |    /// Shows the window.
   21|       |    ///
   22|       |    /// # Panics
   23|       |    /// Panics if the internal lock is poisoned.
   24|      0|    fn show(&mut self) -> Result<(), ObsError> {
   25|      0|        log::trace!("show");
   26|      0|        let m = self
   27|      0|            .manager
   28|      0|            .read()
   29|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   30|      0|        unsafe {
   31|      0|            let _ = ShowWindow(m.hwnd.0, SW_SHOWNA);
   32|      0|        }
   33|       |
   34|      0|        m.is_hidden.store(false, Ordering::Relaxed);
   35|      0|        Ok(())
   36|      0|    }
   37|       |
   38|      0|    fn hide(&mut self) -> Result<(), ObsError> {
   39|      0|        log::trace!("hide");
   40|      0|        let m = self
   41|      0|            .manager
   42|      0|            .read()
   43|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   44|      0|        unsafe {
   45|      0|            let _ = ShowWindow(m.hwnd.0, SW_HIDE);
   46|      0|        }
   47|       |
   48|      0|        m.is_hidden.store(true, Ordering::Relaxed);
   49|      0|        Ok(())
   50|      0|    }
   51|       |
   52|      0|    fn is_visible(&self) -> Result<bool, ObsError> {
   53|      0|        let m = self
   54|      0|            .manager
   55|      0|            .read()
   56|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
   57|      0|        Ok(!m.is_hidden.load(Ordering::Relaxed))
   58|      0|    }
   59|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\encoders\audio.rs:
    1|       |use libobs::audio_output;
    2|       |use std::{borrow::Borrow, ptr, sync::Arc};
    3|       |
    4|       |use crate::{
    5|       |    data::ObsData,
    6|       |    impl_obs_drop, run_with_obs,
    7|       |    runtime::ObsRuntime,
    8|       |    unsafe_send::Sendable,
    9|       |    utils::{AudioEncoderInfo, ObsError, ObsString},
   10|       |};
   11|       |
   12|       |#[derive(Debug)]
   13|       |#[allow(dead_code)]
   14|       |pub struct ObsAudioEncoder {
   15|       |    pub(crate) encoder: Sendable<*mut libobs::obs_encoder_t>,
   16|       |    pub(crate) id: ObsString,
   17|       |    pub(crate) name: ObsString,
   18|       |    pub(crate) settings: Option<ObsData>,
   19|       |    pub(crate) hotkey_data: Option<ObsData>,
   20|       |    pub(crate) runtime: ObsRuntime,
   21|       |}
   22|       |
   23|       |impl ObsAudioEncoder {
   24|       |    /// Info: the handler attribute is no longer needed and kept for compatibility. The `handler` parameter will be removed in a future release.
   25|      7|    pub fn new_from_info(
   26|      7|        info: AudioEncoderInfo,
   27|      7|        mixer_idx: usize,
   28|      7|        runtime: ObsRuntime,
   29|      7|    ) -> Result<Arc<Self>, ObsError> {
   30|      7|        let settings_ptr = match info.settings.borrow() {
   31|      7|            Some(x) => x.as_ptr(),
   32|      0|            None => Sendable(ptr::null_mut()),
   33|       |        };
   34|       |
   35|      7|        let hotkey_data_ptr = match info.hotkey_data.borrow() {
   36|      0|            Some(x) => x.as_ptr(),
   37|      7|            None => Sendable(ptr::null_mut()),
   38|       |        };
   39|       |
   40|      7|        let id_ptr = info.id.as_ptr();
   41|      7|        let name_ptr = info.name.as_ptr();
   42|       |
   43|      7|        let encoder = run_with_obs!(
   44|      7|            runtime,
   45|       |            (hotkey_data_ptr, settings_ptr, id_ptr, name_ptr),
   46|       |            move || unsafe {
   47|      7|                let ptr = libobs::obs_audio_encoder_create(
   48|      7|                    id_ptr,
   49|      7|                    name_ptr,
   50|      7|                    settings_ptr,
   51|      7|                    mixer_idx,
   52|      7|                    hotkey_data_ptr,
   53|       |                );
   54|      7|                Sendable(ptr)
   55|      7|            }
   56|      0|        )?;
   57|       |
   58|      7|        if encoder.0.is_null() {
   59|      0|            return Err(ObsError::NullPointer);
   60|      7|        }
   61|       |
   62|      7|        Ok(Arc::new(Self {
   63|      7|            encoder,
   64|      7|            id: info.id,
   65|      7|            name: info.name,
   66|      7|            settings: info.settings,
   67|      7|            hotkey_data: info.hotkey_data,
   68|      7|            runtime,
   69|      7|        }))
   70|      7|    }
   71|       |
   72|       |    /// This is only needed once for global audio context
   73|      0|    pub fn set_audio_context(
   74|      0|        &mut self,
   75|      0|        handler: Sendable<*mut audio_output>,
   76|      0|    ) -> Result<(), ObsError> {
   77|      0|        let encoder_ptr = self.encoder.clone();
   78|       |
   79|      0|        run_with_obs!(self.runtime, (handler, encoder_ptr), move || unsafe {
   80|      0|            libobs::obs_encoder_set_audio(encoder_ptr, handler)
   81|      0|        })
   82|      0|    }
   83|       |}
   84|       |
   85|       |impl_obs_drop!(ObsAudioEncoder, (encoder), move || unsafe {
   86|      7|    libobs::obs_encoder_release(encoder)
   87|      7|});

E:\Rust\libobs-rs\libobs-wrapper\src\encoders\enums.rs:
    1|       |use std::{convert::Infallible, str::FromStr};
    2|       |
    3|       |use crate::utils::ObsString;
    4|       |
    5|       |macro_rules! encoder_enum {
    6|       |    ($name:ident, { $($plugin:literal: [ $($(#[$attr:meta])* $variant:ident,)* ],)* }) => { paste::paste! {
    7|       |        #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
    8|       |        #[allow(non_camel_case_types)]
    9|       |        pub enum $name {
   10|       |            $(
   11|       |                $(
   12|       |                    #[doc = "From plugin: `" $plugin "`"]
   13|       |                    $(#[$attr])*
   14|       |                    [<$variant:upper>],
   15|       |                )*
   16|       |            )*
   17|       |            Other(String),
   18|       |        }
   19|       |
   20|       |        impl FromStr for $name {
   21|       |            type Err = Infallible;
   22|     35|            fn from_str(s: &str) -> Result<Self, Self::Err> {
   23|       |                #[allow(deprecated)]
   24|     35|                return Ok(match s {
   25|      7|                    $( $( stringify!($variant) => Self::[<$variant:upper>], )* )*
   26|      0|                    e => Self::Other(e.to_string()),
   27|       |                });
   28|     35|            }
   29|       |        }
   30|       |        impl From<$name> for ObsString {
   31|      8|            fn from(v: $name) -> ObsString {
   32|       |                #[allow(deprecated)]
   33|      8|                return match v {
   34|      7|                    $( $( $name::[<$variant:upper>] => ObsString::new(stringify!($variant)), )* )*
   35|      0|                    $name::Other(e) => ObsString::new(&e),
   36|       |                };
   37|      8|            }
   38|       |        }
   39|       |    } };
   40|       |}
   41|       |
   42|       |// These lists were produced using
   43|       |//   rg "struct obs_encoder_info [^\*].*=" -A 4
   44|       |// on the OBS codebase, which lists all of the encoders and their types, as well as their
   45|       |// capabilities (including whether they're deprecated or not).
   46|       |
   47|       |encoder_enum!(
   48|       |    ObsVideoEncoderType,
   49|       |    {
   50|       |        "obs-ffmpeg": [
   51|       |            h264_texture_amf,
   52|       |            h265_texture_amf,
   53|       |            av1_texture_amf,
   54|       |            ffmpeg_vaapi,
   55|       |            ffmpeg_vaapi_tex,
   56|       |            av1_ffmpeg_vaapi,
   57|       |            av1_ffmpeg_vaapi_tex,
   58|       |            hevc_ffmpeg_vaapi,
   59|       |            hevc_ffmpeg_vaapi_tex,
   60|       |            ffmpeg_openh264,
   61|       |            #[deprecated]
   62|       |            ffmpeg_nvenc,
   63|       |            #[deprecated]
   64|       |            ffmpeg_hevc_nvenc,
   65|       |            ffmpeg_svt_av1,
   66|       |            ffmpeg_aom_av1,
   67|       |        ],
   68|       |        "obs-nvenc": [
   69|       |            #[deprecated]
   70|       |            obs_nvenc_h264_cuda,
   71|       |            #[deprecated]
   72|       |            obs_nvenc_hevc_cuda,
   73|       |            #[deprecated]
   74|       |            obs_nvenc_av1_cuda,
   75|       |            obs_nvenc_h264_tex,
   76|       |            obs_nvenc_hevc_tex,
   77|       |            obs_nvenc_av1_tex,
   78|       |            #[deprecated]
   79|       |            jim_nvenc,
   80|       |            #[deprecated]
   81|       |            jim_hevc_nvenc,
   82|       |            #[deprecated]
   83|       |            jim_av1_nvenc,
   84|       |            obs_nvenc_h264_soft,
   85|       |            obs_nvenc_hevc_soft,
   86|       |            obs_nvenc_av1_soft,
   87|       |        ],
   88|       |        "obs-qsv11": [
   89|       |            obs_qsv11,
   90|       |            obs_qsv11_soft,
   91|       |            obs_qsv11_v2,
   92|       |            obs_qsv11_soft_v2,
   93|       |            obs_qsv11_av1,
   94|       |            obs_qsv11_av1_soft,
   95|       |            obs_qsv11_hevc,
   96|       |            obs_qsv11_hevc_soft,
   97|       |        ],
   98|       |        "obs-x264": [
   99|       |            obs_x264,
  100|       |        ],
  101|       |    }
  102|       |);
  103|       |
  104|       |encoder_enum!(
  105|       |    ObsAudioEncoderType,
  106|       |    {
  107|       |        "obs-ffmpeg": [
  108|       |            ffmpeg_aac,
  109|       |            ffmpeg_opus,
  110|       |            ffmpeg_pcm_s16le,
  111|       |            ffmpeg_pcm_s24le,
  112|       |            ffmpeg_pcm_f32le,
  113|       |            ffmpeg_alac,
  114|       |            ffmpeg_flac,
  115|       |        ],
  116|       |        "obs-libfdk": [
  117|       |            libfdk_aac,
  118|       |        ],
  119|       |    }
  120|       |);

E:\Rust\libobs-rs\libobs-wrapper\src\encoders\mod.rs:
    1|       |use std::{ffi::CStr, os::raw::c_char};
    2|       |
    3|       |use num_traits::ToPrimitive;
    4|       |
    5|       |use crate::{
    6|       |    context::ObsContext,
    7|       |    enums::ObsEncoderType,
    8|       |    run_with_obs,
    9|       |    runtime::ObsRuntime,
   10|       |    utils::{ObsError, ENCODER_HIDE_FLAGS},
   11|       |};
   12|       |
   13|       |pub mod audio;
   14|       |mod enums;
   15|       |mod property_helper;
   16|       |pub use property_helper::*;
   17|       |pub mod video;
   18|       |pub use enums::*;
   19|       |
   20|       |pub trait ObsContextEncoders {
   21|       |    fn best_video_encoder(&self) -> Result<ObsVideoEncoderBuilder, ObsError>;
   22|       |
   23|       |    fn best_audio_encoder(&self) -> Result<ObsAudioEncoderBuilder, ObsError>;
   24|       |
   25|       |    fn available_audio_encoders(&self) -> Result<Vec<ObsAudioEncoderBuilder>, ObsError>;
   26|       |
   27|       |    fn available_video_encoders(&self) -> Result<Vec<ObsVideoEncoderBuilder>, ObsError>;
   28|       |}
   29|       |
   30|      7|fn get_encoders_raw(
   31|      7|    encoder_type: ObsEncoderType,
   32|      7|    runtime: &ObsRuntime,
   33|      7|) -> Result<Vec<String>, ObsError> {
   34|      7|    let type_primitive = encoder_type.to_i32().unwrap();
   35|       |
   36|      7|    run_with_obs!(runtime, move || {
   37|      7|        let mut n = 0;
   38|      7|        let mut encoders = Vec::new();
   39|       |
   40|      7|        let mut ptr: *const c_char = unsafe { std::mem::zeroed() };
   41|    105|        while unsafe { libobs::obs_enum_encoder_types(n, &mut ptr) } {
   42|     98|            n += 1;
   43|     98|            let cstring = unsafe { CStr::from_ptr(ptr) };
   44|     98|            if let Ok(enc) = cstring.to_str() {
   45|       |                unsafe {
   46|     98|                    let is_hidden = libobs::obs_get_encoder_caps(ptr) & ENCODER_HIDE_FLAGS != 0;
   47|     98|                    if is_hidden || libobs::obs_get_encoder_type(ptr) != type_primitive {
                                                  ^84
   48|     63|                        continue;
   49|     35|                    }
   50|       |                }
   51|       |
   52|     35|                log::debug!("Found encoder: {}", enc);
                                          ^30
   53|     35|                encoders.push(enc.into());
   54|      0|            }
   55|       |        }
   56|       |
   57|      7|        encoders.sort_unstable();
   58|      7|        encoders
   59|      7|    })
   60|      7|}
   61|       |
   62|       |impl ObsContextEncoders for ObsContext {
   63|      0|    fn best_video_encoder(&self) -> Result<ObsVideoEncoderBuilder, ObsError> {
   64|      0|        let encoders = self.available_video_encoders()?;
   65|      0|        encoders
   66|      0|            .into_iter()
   67|      0|            .next()
   68|      0|            .ok_or(ObsError::NoAvailableEncoders)
   69|      0|    }
   70|       |
   71|      0|    fn best_audio_encoder(&self) -> Result<ObsAudioEncoderBuilder, ObsError> {
   72|      0|        let encoders = self.available_audio_encoders()?;
   73|      0|        encoders
   74|      0|            .into_iter()
   75|      0|            .next()
   76|      0|            .ok_or(ObsError::NoAvailableEncoders)
   77|      0|    }
   78|       |
   79|      0|    fn available_audio_encoders(&self) -> Result<Vec<ObsAudioEncoderBuilder>, ObsError> {
   80|      0|        Ok(get_encoders_raw(ObsEncoderType::Audio, &self.runtime)?
   81|      0|            .into_iter()
   82|      0|            .map(|x| ObsAudioEncoderBuilder::new(self.clone(), &x))
   83|      0|            .collect::<Vec<_>>())
   84|      0|    }
   85|       |
   86|      7|    fn available_video_encoders(&self) -> Result<Vec<ObsVideoEncoderBuilder>, ObsError> {
   87|      7|        Ok(get_encoders_raw(ObsEncoderType::Video, &self.runtime)?
                                                                               ^0
   88|      7|            .into_iter()
   89|     35|            .map(|x| ObsVideoEncoderBuilder::new(self.clone(), &x))
                           ^7
   90|      7|            .collect::<Vec<_>>())
   91|      7|    }
   92|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\encoders\property_helper.rs:
    1|       |use std::{collections::HashMap, str::FromStr, sync::Arc};
    2|       |
    3|       |use duplicate::duplicate_item;
    4|       |
    5|       |use crate::{
    6|       |    context::ObsContext,
    7|       |    data::{
    8|       |        output::ObsOutputRef,
    9|       |        properties::{
   10|       |            get_properties_inner, ObsProperty, ObsPropertyObject, ObsPropertyObjectPrivate,
   11|       |        },
   12|       |        ObsData,
   13|       |    },
   14|       |    run_with_obs,
   15|       |    runtime::ObsRuntime,
   16|       |    unsafe_send::Sendable,
   17|       |    utils::{ObjectInfo, ObsError, ObsString},
   18|       |};
   19|       |
   20|       |use super::{
   21|       |    audio::ObsAudioEncoder, video::ObsVideoEncoder, ObsAudioEncoderType, ObsVideoEncoderType,
   22|       |};
   23|       |
   24|       |#[duplicate_item(
   25|       |    StructName EncoderType;
   26|       |    [ObsAudioEncoderBuilder] [ObsAudioEncoderType];
   27|       |    [ObsVideoEncoderBuilder] [ObsVideoEncoderType]
   28|       |)]
   29|       |#[derive(Debug)]
   30|       |pub struct StructName {
   31|       |    encoder_id: EncoderType,
   32|       |    runtime: ObsRuntime,
   33|       |    //TODO: keeping this for now, maybe it'll be useful later
   34|       |    _context: ObsContext,
   35|       |    settings: Option<ObsData>,
   36|       |    hotkey_data: Option<ObsData>,
   37|       |}
   38|       |
   39|       |#[duplicate_item(
   40|       |    StructName EncoderType;
   41|      0|    [ObsAudioEncoderBuilder] [ObsAudioEncoderType];
   42|     47|    [ObsVideoEncoderBuilder] [ObsVideoEncoderType]
   43|     47|)]
   44|     47|impl StructName {
   45|     47|    pub fn new(context: ObsContext, encoder_id: &str) -> Self {
                  ^35
   46|     47|        Self {
   47|     35|            encoder_id: EncoderType::from_str(encoder_id).unwrap(),
   48|     35|            runtime: context.runtime().clone(),
   49|     35|            _context: context,
   50|     35|            settings: None,
   51|     35|            hotkey_data: None,
   52|     35|        }
   53|     47|    }
                  ^35
   54|     47|
   55|     47|    pub fn get_encoder_id(&self) -> &EncoderType {
   56|     47|        &self.encoder_id
   57|     47|    }
   58|       |
   59|      6|    pub fn set_settings(&mut self, settings: ObsData) -> &mut Self {
   60|      6|        self.settings = Some(settings);
   61|      6|        self
   62|      6|    }
   63|       |
   64|      0|    pub fn set_hotkey_data(&mut self, hotkey_data: ObsData) -> &mut Self {
   65|      0|        self.hotkey_data = Some(hotkey_data);
   66|      0|        self
   67|      0|    }
   68|       |
   69|      0|    pub fn get_settings(&self) -> Option<&ObsData> {
   70|      0|        self.settings.as_ref()
   71|      0|    }
   72|       |
   73|      0|    pub fn get_hotkey_data(&self) -> Option<&ObsData> {
   74|      0|        self.hotkey_data.as_ref()
   75|      0|    }
   76|       |
   77|      0|    pub fn get_settings_mut(&mut self) -> Option<&mut ObsData> {
   78|      0|        self.settings.as_mut()
   79|      0|    }
   80|       |
   81|      0|    pub fn get_hotkey_data_mut(&mut self) -> Option<&mut ObsData> {
   82|      0|        self.hotkey_data.as_mut()
   83|      0|    }
   84|       |}
   85|       |
   86|       |impl ObsAudioEncoderBuilder {
   87|      0|    pub fn apply_to_context(
   88|      0|        self,
   89|      0|        output: &mut ObsOutputRef,
   90|      0|        name: &str,
   91|      0|        settings: Option<ObsData>,
   92|      0|        hotkey_data: Option<ObsData>,
   93|      0|        mixer_idx: usize,
   94|      0|    ) -> Result<Arc<ObsAudioEncoder>, ObsError> {
   95|      0|        let e_id: ObsString = self.encoder_id.into();
   96|      0|        let info = ObjectInfo::new(e_id, ObsString::new(name), settings, hotkey_data);
   97|       |
   98|      0|        output.create_and_set_audio_encoder(info, mixer_idx)
   99|      0|    }
  100|       |}
  101|       |
  102|       |impl ObsVideoEncoderBuilder {
  103|      6|    pub fn set_to_output(
  104|      6|        self,
  105|      6|        output: &mut ObsOutputRef,
  106|      6|        name: &str,
  107|      6|    ) -> Result<Arc<ObsVideoEncoder>, ObsError> {
  108|      6|        let e_id: ObsString = self.encoder_id.into();
  109|      6|        let info = ObjectInfo::new(e_id, ObsString::new(name), self.settings, self.hotkey_data);
  110|       |
  111|      6|        output.create_and_set_video_encoder(info)
  112|      6|    }
  113|       |}
  114|       |
  115|       |#[duplicate_item(
  116|       |    StructName;
  117|       |    [ObsAudioEncoderBuilder];
  118|       |    [ObsVideoEncoderBuilder]
  119|       |)]
  120|       |impl ObsPropertyObject for StructName {
  121|      0|    fn get_properties(&self) -> Result<HashMap<String, ObsProperty>, ObsError> {
  122|      0|        let properties_raw = self.get_properties_raw()?;
  123|      0|        get_properties_inner(properties_raw, self.runtime.clone())
  124|      0|    }
  125|       |}
  126|       |
  127|       |#[duplicate_item(
  128|       |    StructName;
  129|       |    [ObsAudioEncoderBuilder];
  130|       |    [ObsVideoEncoderBuilder]
  131|       |)]
  132|       |impl ObsPropertyObjectPrivate for StructName {
  133|      0|    fn get_properties_raw(&self) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError> {
  134|      0|        let encoder_name: ObsString = self.encoder_id.clone().into();
  135|      0|        let encoder_name_ptr = encoder_name.as_ptr();
  136|       |
  137|      0|        run_with_obs!(self.runtime, (encoder_name_ptr), move || unsafe {
  138|      0|            Sendable(libobs::obs_get_encoder_properties(encoder_name_ptr))
  139|      0|        })
  140|      0|    }
  141|       |
  142|      0|    fn get_properties_by_id_raw<T: Into<ObsString> + Sync + Send>(
  143|      0|        id: T,
  144|      0|        runtime: ObsRuntime,
  145|      0|    ) -> Result<Sendable<*mut libobs::obs_properties_t>, ObsError> {
  146|      0|        let id: ObsString = id.into();
  147|      0|        let id_ptr = id.as_ptr();
  148|      0|        run_with_obs!(runtime, (id_ptr), move || unsafe {
  149|      0|            Sendable(libobs::obs_get_encoder_properties(id_ptr))
  150|      0|        })
  151|      0|    }
  152|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\encoders\video.rs:
    1|       |use libobs::{obs_encoder, video_output};
    2|       |use std::{ptr, sync::Arc};
    3|       |
    4|       |use crate::{
    5|       |    data::ObsData,
    6|       |    impl_obs_drop, run_with_obs,
    7|       |    runtime::ObsRuntime,
    8|       |    unsafe_send::Sendable,
    9|       |    utils::{ObsError, ObsString, VideoEncoderInfo},
   10|       |};
   11|       |
   12|       |#[derive(Debug)]
   13|       |#[allow(dead_code)]
   14|       |pub struct ObsVideoEncoder {
   15|       |    pub(crate) encoder: Sendable<*mut obs_encoder>,
   16|       |    pub(crate) id: ObsString,
   17|       |    pub(crate) name: ObsString,
   18|       |    pub(crate) settings: Option<ObsData>,
   19|       |    pub(crate) hotkey_data: Option<ObsData>,
   20|       |    pub(crate) runtime: ObsRuntime,
   21|       |}
   22|       |
   23|       |impl ObsVideoEncoder {
   24|       |    /// Info: the handler attribute is no longer needed and kept for compatibility. The `handler` parameter will be removed in a future release.
   25|      8|    pub fn new_from_info(
   26|      8|        info: VideoEncoderInfo,
   27|      8|        runtime: ObsRuntime,
   28|      8|    ) -> Result<Arc<Self>, ObsError> {
   29|      8|        let settings_ptr = match &info.settings {
   30|      8|            Some(x) => x.as_ptr(),
   31|      0|            None => Sendable(ptr::null_mut()),
   32|       |        };
   33|       |
   34|      8|        let hotkey_data_ptr = match &info.hotkey_data {
   35|      0|            Some(x) => x.as_ptr(),
   36|      8|            None => Sendable(ptr::null_mut()),
   37|       |        };
   38|       |
   39|      8|        let id_ptr = info.id.as_ptr();
   40|      8|        let name_ptr = info.name.as_ptr();
   41|      8|        let encoder = run_with_obs!(
   42|      8|            runtime,
   43|       |            (id_ptr, name_ptr, hotkey_data_ptr, settings_ptr),
   44|       |            move || unsafe {
   45|      8|                let ptr = libobs::obs_video_encoder_create(
   46|      8|                    id_ptr,
   47|      8|                    name_ptr,
   48|      8|                    settings_ptr,
   49|      8|                    hotkey_data_ptr,
   50|       |                );
   51|      8|                Sendable(ptr)
   52|      8|            }
   53|      0|        )?;
   54|       |
   55|      8|        if encoder.0.is_null() {
   56|      0|            return Err(ObsError::NullPointer);
   57|      8|        }
   58|       |
   59|      8|        Ok(Arc::new(Self {
   60|      8|            encoder,
   61|      8|            id: info.id,
   62|      8|            name: info.name,
   63|      8|            settings: info.settings,
   64|      8|            hotkey_data: info.hotkey_data,
   65|      8|            runtime,
   66|      8|        }))
   67|      8|    }
   68|       |
   69|     21|    pub fn as_ptr(&self) -> Sendable<*mut obs_encoder> {
   70|     21|        self.encoder.clone()
   71|     21|    }
   72|       |
   73|       |    /// This is only needed once for global video context
   74|      0|    pub fn set_video_context(
   75|      0|        &mut self,
   76|      0|        handler: Sendable<*mut video_output>,
   77|      0|    ) -> Result<(), ObsError> {
   78|      0|        let self_ptr = self.as_ptr();
   79|      0|        run_with_obs!(self.runtime, (handler, self_ptr), move || unsafe {
   80|      0|            libobs::obs_encoder_set_video(self_ptr, handler);
   81|      0|        })
   82|      0|    }
   83|       |
   84|      0|    pub fn is_active(&self) -> Result<bool, ObsError> {
   85|      0|        let encoder_ptr = self.as_ptr();
   86|       |
   87|      0|        run_with_obs!(self.runtime, (encoder_ptr), move || unsafe {
   88|      0|            libobs::obs_encoder_active(encoder_ptr)
   89|      0|        })
   90|      0|    }
   91|       |
   92|      0|    pub fn update_settings(&mut self, settings: &ObsData) -> Result<(), ObsError> {
   93|      0|        let encoder_ptr = self.as_ptr();
   94|      0|        if self.is_active()? {
   95|      0|            return Err(ObsError::EncoderActive);
   96|      0|        }
   97|       |
   98|      0|        let settings_ptr = settings.as_ptr();
   99|       |
  100|      0|        run_with_obs!(self.runtime, (encoder_ptr, settings_ptr), move || unsafe {
  101|      0|            libobs::obs_encoder_update(encoder_ptr, settings_ptr);
  102|      0|        })
  103|      0|    }
  104|       |}
  105|       |
  106|       |impl_obs_drop!(ObsVideoEncoder, (encoder), move || unsafe {
  107|      8|    libobs::obs_encoder_release(encoder);
  108|      8|});

E:\Rust\libobs-rs\libobs-wrapper\src\enums.rs:
    1|       |use core::fmt;
    2|       |use std::fmt::Display;
    3|       |
    4|       |use num_derive::{FromPrimitive, ToPrimitive};
    5|       |
    6|       |#[cfg(target_os = "windows")]
    7|       |pub(crate) type OsEnumType = i32;
    8|       |#[cfg(not(target_os = "windows"))]
    9|       |pub(crate) type OsEnumType = u32;
   10|       |
   11|       |#[cfg_attr(target_os = "windows", repr(i32))]
   12|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
   13|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
   14|       |/// Describes the video output format used by the
   15|       |/// OBS video context. Used in `ObsVideoInfo`.
   16|       |pub enum ObsVideoFormat {
   17|       |    AYUV = libobs::video_format_VIDEO_FORMAT_AYUV,
   18|       |    BGR3 = libobs::video_format_VIDEO_FORMAT_BGR3,
   19|       |    BGRA = libobs::video_format_VIDEO_FORMAT_BGRA,
   20|       |    BGRX = libobs::video_format_VIDEO_FORMAT_BGRX,
   21|       |    I010 = libobs::video_format_VIDEO_FORMAT_I010,
   22|       |    I210 = libobs::video_format_VIDEO_FORMAT_I210,
   23|       |    I40A = libobs::video_format_VIDEO_FORMAT_I40A,
   24|       |    I412 = libobs::video_format_VIDEO_FORMAT_I412,
   25|       |    I420 = libobs::video_format_VIDEO_FORMAT_I420,
   26|       |    I422 = libobs::video_format_VIDEO_FORMAT_I422,
   27|       |    I42A = libobs::video_format_VIDEO_FORMAT_I42A,
   28|       |    I444 = libobs::video_format_VIDEO_FORMAT_I444,
   29|       |    NONE = libobs::video_format_VIDEO_FORMAT_NONE,
   30|       |    NV12 = libobs::video_format_VIDEO_FORMAT_NV12,
   31|       |    P010 = libobs::video_format_VIDEO_FORMAT_P010,
   32|       |    P216 = libobs::video_format_VIDEO_FORMAT_P216,
   33|       |    P416 = libobs::video_format_VIDEO_FORMAT_P416,
   34|       |    R10L = libobs::video_format_VIDEO_FORMAT_R10L,
   35|       |    RGBA = libobs::video_format_VIDEO_FORMAT_RGBA,
   36|       |    UYVY = libobs::video_format_VIDEO_FORMAT_UYVY,
   37|       |    V210 = libobs::video_format_VIDEO_FORMAT_V210,
   38|       |    Y800 = libobs::video_format_VIDEO_FORMAT_Y800,
   39|       |    YA2L = libobs::video_format_VIDEO_FORMAT_YA2L,
   40|       |    YUVA = libobs::video_format_VIDEO_FORMAT_YUVA,
   41|       |    YUY2 = libobs::video_format_VIDEO_FORMAT_YUY2,
   42|       |    YVYU = libobs::video_format_VIDEO_FORMAT_YVYU,
   43|       |}
   44|       |
   45|       |#[cfg_attr(target_os = "windows", repr(i32))]
   46|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
   47|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
   48|       |/// Describes the colorspace that an OBS video context
   49|       |/// uses. Used in `ObsVideoInfo`.
   50|       |pub enum ObsColorspace {
   51|       |    CS2100HLG = libobs::video_colorspace_VIDEO_CS_2100_HLG,
   52|       |    CS2100PQ = libobs::video_colorspace_VIDEO_CS_2100_PQ,
   53|       |    CS601 = libobs::video_colorspace_VIDEO_CS_601,
   54|       |    CS709 = libobs::video_colorspace_VIDEO_CS_709,
   55|       |    Default = libobs::video_colorspace_VIDEO_CS_DEFAULT,
   56|       |    CSRGB = libobs::video_colorspace_VIDEO_CS_SRGB,
   57|       |}
   58|       |
   59|       |#[cfg_attr(target_os = "windows", repr(i32))]
   60|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
   61|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
   62|       |/// Describes the minimum and maximum color levels that
   63|       |/// an OBS video context is allowed to encode. Used in
   64|       |/// `ObsVideoInfo.`
   65|       |pub enum ObsVideoRange {
   66|       |    Default = libobs::video_range_type_VIDEO_RANGE_DEFAULT,
   67|       |    Partial = libobs::video_range_type_VIDEO_RANGE_PARTIAL,
   68|       |    Full = libobs::video_range_type_VIDEO_RANGE_FULL,
   69|       |}
   70|       |
   71|       |#[cfg_attr(target_os = "windows", repr(i32))]
   72|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
   73|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
   74|       |/// Describes how libobs should reconcile non-matching
   75|       |/// base and output resolutions when creating a video
   76|       |/// context.
   77|       |pub enum ObsScaleType {
   78|       |    Area = libobs::obs_scale_type_OBS_SCALE_AREA,
   79|       |    Bicubic = libobs::obs_scale_type_OBS_SCALE_BICUBIC,
   80|       |    Bilinear = libobs::obs_scale_type_OBS_SCALE_BILINEAR,
   81|       |    Disable = libobs::obs_scale_type_OBS_SCALE_DISABLE,
   82|       |    Lanczos = libobs::obs_scale_type_OBS_SCALE_LANCZOS,
   83|       |    Point = libobs::obs_scale_type_OBS_SCALE_POINT,
   84|       |}
   85|       |
   86|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   87|       |/// Describes which graphics backend should be used
   88|       |/// in the OBS video context. Used in `ObsVideoInfo`.
   89|       |pub enum ObsGraphicsModule {
   90|       |    OpenGL,
   91|       |    DirectX11,
   92|       |}
   93|       |
   94|       |#[repr(i32)]
   95|       |#[derive(Copy, Clone, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
   96|       |/// Status types returned after attempting to
   97|       |/// reset the OBS video context using the
   98|       |/// function `obs_reset_video`.
   99|       |pub enum ObsResetVideoStatus {
  100|       |    /// `obs_reset_video` was successful.
  101|       |    Success = libobs::OBS_VIDEO_SUCCESS as i32,
  102|       |    /// The adapter is not supported as it
  103|       |    /// lacks capabilities.
  104|       |    NotSupported = libobs::OBS_VIDEO_NOT_SUPPORTED,
  105|       |    /// A parameter is invalid.
  106|       |    InvalidParameter = libobs::OBS_VIDEO_INVALID_PARAM,
  107|       |    /// An output is currently running, preventing
  108|       |    /// resetting the video context.
  109|       |    CurrentlyActive = libobs::OBS_VIDEO_CURRENTLY_ACTIVE,
  110|       |    /// Generic error occured when attempting to
  111|       |    /// reset the OBS video context.
  112|       |    Failure = libobs::OBS_VIDEO_FAIL,
  113|       |}
  114|       |
  115|       |/// Audio samples per second options that are
  116|       |/// supported by libobs.
  117|       |#[cfg_attr(target_os = "windows", repr(i32))]
  118|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
  119|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
  120|       |pub enum ObsSamplesPerSecond {
  121|       |    /// 44.1 kHz
  122|       |    F44100 = 44100,
  123|       |    /// 48.0 kHz
  124|       |    F48000 = 48000,
  125|       |}
  126|       |
  127|       |#[cfg_attr(target_os = "windows", repr(i32))]
  128|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
  129|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
  130|       |pub enum ObsSpeakerLayout {
  131|       |    S2Point1 = libobs::speaker_layout_SPEAKERS_2POINT1,
  132|       |    S4Point0 = libobs::speaker_layout_SPEAKERS_4POINT0,
  133|       |    S4Point1 = libobs::speaker_layout_SPEAKERS_4POINT1,
  134|       |    S5Point1 = libobs::speaker_layout_SPEAKERS_5POINT1,
  135|       |    S7Point1 = libobs::speaker_layout_SPEAKERS_7POINT1,
  136|       |    Mono = libobs::speaker_layout_SPEAKERS_MONO,
  137|       |    Stereo = libobs::speaker_layout_SPEAKERS_STEREO,
  138|       |    Unknown = libobs::speaker_layout_SPEAKERS_UNKNOWN,
  139|       |}
  140|       |
  141|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
  142|       |pub enum ObsOutputStopSignal {
  143|       |    /// Successfully stopped
  144|       |    Success,
  145|       |    /// The specified path was invalid
  146|       |    BadPath,
  147|       |    /// Failed to connect to a server
  148|       |    ConnectFailed,
  149|       |    /// Invalid stream path
  150|       |    InvalidStream,
  151|       |    /// Generic error
  152|       |    Error,
  153|       |    /// Unexpectedly disconnected
  154|       |    Disconnected,
  155|       |    /// The settings, video/audio format, or codecs are unsupported by this output
  156|       |    Unsupported,
  157|       |    /// Ran out of disk space
  158|       |    NoSpace,
  159|       |    /// Encoder error
  160|       |    EncodeError,
  161|       |}
  162|       |
  163|       |impl fmt::Display for ObsOutputStopSignal {
  164|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  165|      0|        let s = match self {
  166|      0|            ObsOutputStopSignal::Success => "Success",
  167|      0|            ObsOutputStopSignal::BadPath => "Bad Path",
  168|      0|            ObsOutputStopSignal::ConnectFailed => "Connect Failed",
  169|      0|            ObsOutputStopSignal::InvalidStream => "Invalid Stream",
  170|      0|            ObsOutputStopSignal::Error => "Error",
  171|      0|            ObsOutputStopSignal::Disconnected => "Disconnected",
  172|      0|            ObsOutputStopSignal::Unsupported => "Unsupported",
  173|      0|            ObsOutputStopSignal::NoSpace => "No Space",
  174|      0|            ObsOutputStopSignal::EncodeError => "Encode Error",
  175|       |        };
  176|      0|        write!(f, "{}", s)
  177|      0|    }
  178|       |}
  179|       |
  180|       |impl From<ObsOutputStopSignal> for i32 {
  181|      0|    fn from(val: ObsOutputStopSignal) -> Self {
  182|      0|        match val {
  183|      0|            ObsOutputStopSignal::Success => libobs::OBS_OUTPUT_SUCCESS as i32,
  184|      0|            ObsOutputStopSignal::BadPath => libobs::OBS_OUTPUT_BAD_PATH,
  185|      0|            ObsOutputStopSignal::ConnectFailed => libobs::OBS_OUTPUT_CONNECT_FAILED,
  186|      0|            ObsOutputStopSignal::InvalidStream => libobs::OBS_OUTPUT_INVALID_STREAM,
  187|      0|            ObsOutputStopSignal::Error => libobs::OBS_OUTPUT_ERROR,
  188|      0|            ObsOutputStopSignal::Disconnected => libobs::OBS_OUTPUT_DISCONNECTED,
  189|      0|            ObsOutputStopSignal::Unsupported => libobs::OBS_OUTPUT_UNSUPPORTED,
  190|      0|            ObsOutputStopSignal::NoSpace => libobs::OBS_OUTPUT_NO_SPACE,
  191|      0|            ObsOutputStopSignal::EncodeError => libobs::OBS_OUTPUT_ENCODE_ERROR,
  192|       |        }
  193|      0|    }
  194|       |}
  195|       |
  196|       |impl TryFrom<i32> for ObsOutputStopSignal {
  197|       |    type Error = &'static str;
  198|       |
  199|      9|    fn try_from(value: i32) -> Result<Self, <ObsOutputStopSignal as TryFrom<i32>>::Error> {
  200|      9|        match value {
  201|      9|            x if x == libobs::OBS_OUTPUT_SUCCESS as i32 => Ok(ObsOutputStopSignal::Success),
  202|      0|            x if x == libobs::OBS_OUTPUT_BAD_PATH => Ok(ObsOutputStopSignal::BadPath),
  203|      0|            x if x == libobs::OBS_OUTPUT_CONNECT_FAILED => Ok(ObsOutputStopSignal::ConnectFailed),
  204|      0|            x if x == libobs::OBS_OUTPUT_INVALID_STREAM => Ok(ObsOutputStopSignal::InvalidStream),
  205|      0|            x if x == libobs::OBS_OUTPUT_ERROR => Ok(ObsOutputStopSignal::Error),
  206|      0|            x if x == libobs::OBS_OUTPUT_DISCONNECTED => Ok(ObsOutputStopSignal::Disconnected),
  207|      0|            x if x == libobs::OBS_OUTPUT_UNSUPPORTED => Ok(ObsOutputStopSignal::Unsupported),
  208|      0|            x if x == libobs::OBS_OUTPUT_NO_SPACE => Ok(ObsOutputStopSignal::NoSpace),
  209|      0|            x if x == libobs::OBS_OUTPUT_ENCODE_ERROR => Ok(ObsOutputStopSignal::EncodeError),
  210|      0|            _ => Err("Invalid value"),
  211|       |        }
  212|      9|    }
  213|       |}
  214|       |
  215|       |#[cfg_attr(target_os = "windows", repr(i32))]
  216|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
  217|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
  218|       |pub enum ObsEncoderType {
  219|       |    Video = libobs::obs_encoder_type_OBS_ENCODER_VIDEO,
  220|       |    Audio = libobs::obs_encoder_type_OBS_ENCODER_AUDIO,
  221|       |}
  222|       |
  223|       |#[cfg_attr(target_os = "windows", repr(i32))]
  224|       |#[cfg_attr(not(target_os = "windows"), repr(u32))]
  225|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
  226|       |pub enum ObsLogLevel {
  227|       |    Error = libobs::LOG_ERROR,
  228|       |    Warning = libobs::LOG_WARNING,
  229|       |    Info = libobs::LOG_INFO,
  230|       |    Debug = libobs::LOG_DEBUG,
  231|       |}
  232|       |
  233|       |impl Display for ObsLogLevel {
  234|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  235|      0|        write!(f, "{:?}", self)
  236|      0|    }
  237|       |}
  238|       |
  239|       |#[cfg(feature = "color-logger")]
  240|       |impl ObsLogLevel {
  241|  1.20k|    pub fn colorize(&self, s: &str) -> String {
  242|       |        use colored::Colorize;
  243|       |
  244|  1.20k|        match self {
  245|     15|            ObsLogLevel::Error => s.on_red().to_string(),
  246|     61|            ObsLogLevel::Warning => s.yellow().to_string(),
  247|    693|            ObsLogLevel::Info => s.green().bold().to_string(),
  248|    435|            ObsLogLevel::Debug => s.blue().to_string(),
  249|       |        }
  250|  1.20k|    }
  251|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\lib.rs:
    1|       |use getters0::Getters;
    2|       |
    3|       |#[cfg(not(windows))]
    4|       |compiler_error!("libobs-wrapper can only be used in windows");
    5|       |
    6|       |pub mod context;
    7|       |pub mod crash_handler;
    8|       |pub mod data;
    9|       |pub mod display;
   10|       |pub mod encoders;
   11|       |pub mod logger;
   12|       |pub mod runtime;
   13|       |pub mod scenes;
   14|       |pub mod signals;
   15|       |pub mod sources;
   16|       |pub mod unsafe_send;
   17|       |
   18|       |pub mod enums;
   19|       |pub mod utils;
   20|       |
   21|       |// Add the macros module to the public exports
   22|       |mod macros;
   23|       |
   24|       |#[derive(Debug, Clone, Copy, Getters)]
   25|       |pub struct Vec2 {
   26|       |    #[get_mut]
   27|       |    x: f32,
   28|       |    #[get_mut]
   29|       |    y: f32,
   30|       |}
   31|       |
   32|       |impl From<libobs::vec2> for Vec2 {
   33|      1|    fn from(raw: libobs::vec2) -> Self {
   34|      1|        let inner = unsafe { raw.__bindgen_anon_1.__bindgen_anon_1 };
   35|      1|        Self {
   36|      1|            x: inner.x,
   37|      1|            y: inner.y,
   38|      1|        }
   39|      1|    }
   40|       |}
   41|       |
   42|       |impl From<Vec2> for libobs::vec2 {
   43|      1|    fn from(val: Vec2) -> Self {
   44|      1|        libobs::vec2 {
   45|      1|            __bindgen_anon_1: libobs::vec2__bindgen_ty_1 {
   46|      1|                __bindgen_anon_1: libobs::vec2__bindgen_ty_1__bindgen_ty_1 { x: val.x, y: val.y },
   47|      1|            },
   48|      1|        }
   49|      1|    }
   50|       |}
   51|       |
   52|       |#[test]
   53|      1|fn test_vec2() {
   54|      1|    let vec_val = Vec2::new(1.0, 2.0);
   55|      1|    let libobs_vec: libobs::vec2 = vec_val.into();
   56|       |
   57|      1|    let original = Vec2::from(libobs_vec);
   58|      1|    assert_eq!(original.x, 1.0);
   59|      1|    assert_eq!(original.y, 2.0);
   60|      1|    assert_ne!(original.x, 0.0);
   61|      1|    assert_ne!(original.y, 0.0);
   62|      1|}

E:\Rust\libobs-rs\libobs-wrapper\src\logger\console.rs:
    1|       |use crate::enums::ObsLogLevel;
    2|       |
    3|       |use super::ObsLogger;
    4|       |
    5|       |#[derive(Debug)]
    6|       |pub struct ConsoleLogger {
    7|       |    _private: (),
    8|       |}
    9|       |
   10|       |impl Default for ConsoleLogger {
   11|      0|    fn default() -> Self {
   12|      0|        Self::new()
   13|      0|    }
   14|       |}
   15|       |
   16|       |impl ConsoleLogger {
   17|     18|    pub fn new() -> Self {
   18|     18|        Self { _private: () }
   19|     18|    }
   20|       |}
   21|       |
   22|       |impl ObsLogger for ConsoleLogger {
   23|  1.20k|    fn log(&mut self, level: ObsLogLevel, msg: String) {
   24|  1.20k|        let level_str = format!("{:?}", level);
   25|       |
   26|       |        #[cfg(feature = "color-logger")]
   27|  1.20k|        let level_str = level.colorize(&level_str);
   28|       |
   29|  1.20k|        println!("[{}] {}", level_str, msg);
   30|  1.20k|    }
   31|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\logger\file.rs:
    1|       |use std::{fs::File, path::Path};
    2|       |
    3|       |use chrono::Local;
    4|       |
    5|       |use super::ObsLogger;
    6|       |
    7|       |/// A logger that writes logs to a file
    8|       |#[derive(Debug)]
    9|       |pub struct FileLogger {
   10|       |    file: File,
   11|       |}
   12|       |
   13|       |impl FileLogger {
   14|      0|    pub fn from_dir(dir: &Path) -> anyhow::Result<Self> {
   15|      0|        let current_local = Local::now();
   16|      0|        let custom_format = current_local.format("%Y-%m-%d-%H-%M-%S");
   17|       |
   18|       |        Ok(Self {
   19|      0|            file: File::create(dir.join(format!("obs-{}.log", custom_format)))?,
   20|       |        })
   21|      0|    }
   22|       |
   23|      0|    pub fn from_file(file: &Path) -> anyhow::Result<Self> {
   24|       |        Ok(Self {
   25|      0|            file: File::create(file)?,
   26|       |        })
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl ObsLogger for FileLogger {
   31|      0|    fn log(&mut self, level: crate::enums::ObsLogLevel, msg: String) {
   32|       |        use std::io::Write;
   33|      0|        writeln!(self.file, "[{:?}] {}", level, msg).unwrap();
   34|      0|    }
   35|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\logger\mod.rs:
    1|       |mod console;
    2|       |mod file;
    3|       |pub use console::ConsoleLogger;
    4|       |pub use file::FileLogger;
    5|       |
    6|       |use std::{fmt::Debug, os::raw::c_void, sync::Mutex};
    7|       |
    8|       |use lazy_static::lazy_static;
    9|       |use num_traits::FromPrimitive;
   10|       |use vsprintf::vsprintf;
   11|       |
   12|       |use crate::enums::ObsLogLevel;
   13|       |
   14|       |lazy_static! {
   15|       |    /// We are using this as global variable because there can only be one obs context
   16|       |    pub static ref LOGGER: Mutex<Box<dyn ObsLogger>> = Mutex::new(Box::new(ConsoleLogger::new()));
   17|       |}
   18|       |
   19|  1.13k|pub(crate) unsafe extern "C" fn extern_log_callback(
   20|  1.13k|    log_level: i32,
   21|  1.13k|    msg: *const i8,
   22|  1.13k|    args: *mut i8,
   23|  1.13k|    _params: *mut c_void,
   24|  1.13k|) {
   25|  1.13k|    let level = ObsLogLevel::from_i32(log_level);
   26|  1.13k|    if level.is_none() {
   27|      0|        eprintln!("Couldn't find log level {}", log_level);
   28|      0|        return;
   29|  1.13k|    }
   30|       |
   31|  1.13k|    let level = level.unwrap();
   32|       |
   33|  1.13k|    let formatted = vsprintf(msg, args);
   34|  1.13k|    if formatted.is_err() {
   35|      0|        eprintln!("Failed to format log message");
   36|      0|        return;
   37|  1.13k|    }
   38|       |
   39|  1.13k|    let mut logger = LOGGER.lock().unwrap();
   40|       |
   41|  1.13k|    logger.log(level, formatted.unwrap());
   42|  1.13k|}
   43|       |
   44|       |pub trait ObsLogger
   45|       |where
   46|       |    Self: Send + Debug,
   47|       |{
   48|       |    fn log(&mut self, level: ObsLogLevel, msg: String);
   49|       |}
   50|       |
   51|     54|pub(crate) fn internal_log_global(level: ObsLogLevel, msg: String) {
   52|     54|    let mut logger = LOGGER.lock().unwrap();
   53|     54|    logger.log(level, msg);
   54|     54|}

E:\Rust\libobs-rs\libobs-wrapper\src\macros.rs:
    1|       |#[macro_export]
    2|       |macro_rules! run_with_obs_impl {
    3|       |    ($self:expr, $function:ident, $operation:expr) => {
    4|       |        $crate::run_with_obs_impl!($self, $function, (), $operation)
    5|       |    };
    6|       |    ($self:expr, $function:ident, ($($var:ident),* $(,)*), $operation:expr) => {
    7|       |        {
    8|       |            $(let $var = $var.clone();)*
    9|    450|            $self.$function(move || {
   10|    387|                $(let $var = $var;)*
   11|    450|                let e = {
   12|    387|                    $(let $var = $var.0;)*
   13|       |                    $operation
   14|       |                };
   15|    450|                return e()
   16|    450|            })
   17|       |        }
   18|       |    };
   19|       |    (SEPARATE_THREAD, $self:expr, $function:ident, ($($var:ident),* $(,)*), $operation:expr) => {
   20|       |        {
   21|       |            $(let $var = $var.clone();)*
   22|       |            tokio::task::spawn_blocking(move || {
   23|       |                $self.$function(move || {
   24|       |                    $(let $var = $var;)*
   25|       |                    let e = {
   26|       |                        $(let $var = $var.0;)*
   27|       |                        $operation
   28|       |                    };
   29|       |                    return e()
   30|       |                }).unwrap()
   31|       |            })
   32|       |        }
   33|       |    };
   34|       |}
   35|       |
   36|       |#[macro_export]
   37|       |macro_rules! run_with_obs {
   38|       |    ($self:expr, $operation:expr) => {
   39|       |        {
   40|       |            $crate::run_with_obs_impl!($self, run_with_obs_result, $operation)
   41|      0|                .map_err(|e| $crate::utils::ObsError::InvocationError(e.to_string()))
   42|       |        }
   43|       |    };
   44|       |    ($self:expr, ($($var:ident),* $(,)*), $operation:expr) => {
   45|       |        {
   46|       |            $crate::run_with_obs_impl!($self, run_with_obs_result, ($($var),*), $operation)
   47|      0|                .map_err(|e| $crate::utils::ObsError::InvocationError(e.to_string()))
   48|       |        }
   49|       |    };
   50|       |}
   51|       |
   52|       |#[macro_export]
   53|       |/// This function can only be called OUTSIDE of the OBS thread.
   54|       |macro_rules! run_with_obs_blocking {
   55|       |    ($self:expr, $operation:expr) => {
   56|       |        $crate::run_with_obs_impl!($self, run_with_obs_result_blocking, (), $operation)
   57|       |        .map_err(|e| $crate::utils::ObsError::InvocationError(e.to_string()))
   58|       |    };
   59|       |    ($self:expr, ($($var:ident),* $(,)*), $operation:expr) => {
   60|       |        $crate::run_with_obs_impl!($self, run_with_obs_result_blocking, ($($var),*), $operation)
   61|       |        .map_err(|e| $crate::utils::ObsError::InvocationError(e.to_string()))
   62|       |    };
   63|       |    (SEPARATE_THREAD, $self:expr, ($($var:ident),* $(,)*), $operation:expr) => {
   64|       |        use futures_util::TryFutureExt;
   65|       |        $crate::run_with_obs_impl!(SEPARATE_THREAD, $self, run_with_obs_result_blocking, ($($var),*), $operation)
   66|       |            .map_err(|e| $crate::utils::ObsError::InvocationError(e.to_string()))
   67|       |    };
   68|       |}
   69|       |
   70|       |#[macro_export]
   71|       |macro_rules! impl_obs_drop {
   72|       |    ($struct_name: ident, $operation:expr) => {
   73|       |        $crate::impl_obs_drop!($struct_name, (), $operation);
   74|       |    };
   75|       |    ($struct_name: ident, ($($var:ident),* $(,)*), $operation:expr) => {
   76|       |        impl Drop for $struct_name {
   77|     93|            fn drop(&mut self) {
   78|     93|                log::trace!("Dropping {}...", stringify!($struct_name));
                                          ^0
   79|     93|                $(let $var = self.$var.clone();)*
   80|       |                #[cfg(not(feature="no_blocking_drops"))]
   81|       |                {
   82|     93|                    let r = $crate::run_with_obs!(self.runtime, ($($var),*), $operation);
   83|     93|                    if std::thread::panicking() {
   84|      0|                        return;
   85|     93|                    }
   86|       |
   87|     93|                    r.unwrap();
   88|       |                }
   89|       |
   90|       |                #[cfg(feature="no_blocking_drops")]
   91|       |                {
   92|       |                    let __runtime = self.runtime.clone();
   93|       |                    $crate::run_with_obs_blocking!(SEPARATE_THREAD, __runtime, ($($var),*), $operation);
   94|       |                }
   95|     93|            }
   96|       |        }
   97|       |    };
   98|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\runtime.rs:
    1|       |//! Runtime management for safe OBS API access across threads
    2|       |//!
    3|       |//! This module provides the core thread management functionality for the libobs-wrapper.
    4|       |//! It ensures that OBS API calls are always executed on the same thread, as required by
    5|       |//! the OBS API, while still allowing application code to interact with OBS from any thread.
    6|       |//!
    7|       |//! # Thread Safety
    8|       |//!
    9|       |//! The OBS C API is not thread-safe and requires that all operations occur on the same thread.
   10|       |//! The `ObsRuntime` struct creates a dedicated thread for all OBS operations and manages
   11|       |//! message passing between application threads and the OBS thread.
   12|       |//!
   13|       |//! # Blocking APIs
   14|       |//!
   15|       |//! The runtime locking APIs:
   16|       |//! - By default all operations are synchronous
   17|       |//!
   18|       |//! # Example
   19|       |//!
   20|       |//! ```no_run
   21|       |//! use libobs_wrapper::runtime::ObsRuntime;
   22|       |//! use libobs_wrapper::utils::StartupInfo;
   23|       |//!
   24|       |//! fn example() {
   25|       |//!     // Assuming that the OBS context is already initialized
   26|       |//!
   27|       |//!     // Run an operation on the OBS thread
   28|       |//!     let runtime = context.runtime();
   29|       |
   30|       |//!     runtime.run_with_obs(|| {
   31|       |//!         // This code runs on the OBS thread
   32|       |//!         println!("Running on OBS thread");
   33|       |//!     }).unwrap();
   34|       |//! }
   35|       |//! ```
   36|       |
   37|       |use std::ffi::CStr;
   38|       |use std::sync::atomic::{AtomicUsize, Ordering};
   39|       |use std::sync::mpsc::{channel, Sender};
   40|       |use std::sync::{Arc, Mutex};
   41|       |use std::{fmt::Debug, thread::JoinHandle};
   42|       |use std::{ptr, thread};
   43|       |
   44|       |use crate::crash_handler::main_crash_handler;
   45|       |use crate::enums::{ObsLogLevel, ObsResetVideoStatus};
   46|       |use crate::logger::{extern_log_callback, internal_log_global, LOGGER};
   47|       |use crate::unsafe_send::Sendable;
   48|       |use crate::utils::initialization::load_debug_privilege;
   49|       |use crate::utils::{ObsError, ObsModules, ObsString};
   50|       |use crate::{context::OBS_THREAD_ID, utils::StartupInfo};
   51|       |
   52|       |/// Command type for operations to perform on the OBS thread
   53|       |enum ObsCommand {
   54|       |    /// Execute a function on the OBS thread and send result back
   55|       |    Execute(
   56|       |        Box<dyn FnOnce() -> Box<dyn std::any::Any + Send> + Send>,
   57|       |        oneshot::Sender<Box<dyn std::any::Any + Send>>,
   58|       |    ),
   59|       |    /// Signal the OBS thread to terminate
   60|       |    Terminate,
   61|       |}
   62|       |
   63|       |/// Core runtime that manages the OBS thread
   64|       |///
   65|       |/// This struct represents the runtime environment for OBS operations.
   66|       |/// It creates and manages a dedicated thread for OBS API calls to
   67|       |/// ensure thread safety while allowing interaction from any thread.
   68|       |///
   69|       |/// # Thread Safety
   70|       |///
   71|       |/// `ObsRuntime` can be safely cloned and shared across threads. All operations
   72|       |/// are automatically dispatched to the dedicated OBS thread.
   73|       |///
   74|       |/// # Lifecycle Management
   75|       |///
   76|       |/// When the last `ObsRuntime` instance is dropped, the OBS thread is automatically
   77|       |/// shut down and all OBS resources are properly released.
   78|       |/// ```
   79|       |#[derive(Debug, Clone)]
   80|       |pub struct ObsRuntime {
   81|       |    command_sender: Arc<Sender<ObsCommand>>,
   82|       |    queued_commands: Arc<AtomicUsize>,
   83|       |    _guard: Arc<_ObsRuntimeGuard>,
   84|       |}
   85|       |
   86|       |impl ObsRuntime {
   87|       |    /// Initializes the OBS runtime.
   88|       |    ///
   89|       |    /// This function starts up OBS on a dedicated thread and prepares it for use.
   90|       |    /// It handles bootstrapping (if configured), OBS initialization, module loading,
   91|       |    /// and setup of audio/video subsystems.
   92|       |    ///
   93|       |    /// # Parameters
   94|       |    ///
   95|       |    /// * `options` - The startup configuration for OBS
   96|       |    ///
   97|       |    /// # Returns
   98|       |    ///
   99|       |    /// A `Result` containing either:
  100|       |    /// - `ObsRuntimeReturn::Done` with the initialized runtime, modules, and startup info
  101|       |    /// - `ObsRuntimeReturn::Restart` if OBS needs to be updated and the application should restart
  102|       |    /// - An `ObsError` if initialization fails
  103|       |    ///
  104|       |    /// # Examples
  105|       |    ///
  106|       |    /// ```
  107|       |    /// use libobs_wrapper::runtime::{ObsRuntime, ObsRuntimeReturn};
  108|       |    /// use libobs_wrapper::utils::StartupInfo;
  109|       |    ///
  110|       |    /// fn initialize() {
  111|       |    ///     let startup_info = StartupInfo::default();
  112|       |    ///     match ObsRuntime::startup(startup_info) {
  113|       |    ///         Ok(ObsRuntimeReturn::Done(runtime_components)) => {
  114|       |    ///             // Use the initialized runtime
  115|       |    ///         },
  116|       |    ///         Ok(ObsRuntimeReturn::Restart) => {
  117|       |    ///             // Handle restart for OBS update
  118|       |    ///         },
  119|       |    ///         Err(e) => {
  120|       |    ///             // Handle initialization error
  121|       |    ///         }
  122|       |    ///     }
  123|       |    /// }
  124|       |    /// ```
  125|       |    #[allow(unused_mut)]
  126|      9|    pub(crate) fn startup(
  127|      9|        mut options: StartupInfo,
  128|      9|    ) -> Result<(ObsRuntime, ObsModules, StartupInfo), ObsError> {
  129|       |        // Check if OBS is already running on another thread
  130|      9|        let obs_id = OBS_THREAD_ID.lock().map_err(|_e| ObsError::MutexFailure)?;
                                                                                            ^0
  131|      9|        if obs_id.is_some() {
  132|      0|            return Err(ObsError::ThreadFailure);
  133|      9|        }
  134|       |
  135|      9|        drop(obs_id);
  136|       |
  137|      9|        log::trace!("Initializing OBS context");
                                  ^0
  138|      9|        ObsRuntime::init(options)
  139|      9|            .map_err(|e| ObsError::Unexpected(format!("Failed to initialize OBS runtime: {:?}", e)))
                                                            ^0      ^0
  140|      9|    }
  141|       |
  142|       |    /// Internal initialization method
  143|       |    ///
  144|       |    /// Creates the OBS thread and performs core initialization.
  145|      9|    fn init(info: StartupInfo) -> anyhow::Result<(ObsRuntime, ObsModules, StartupInfo)> {
  146|      9|        let (command_sender, command_receiver) = channel();
  147|      9|        let (init_tx, init_rx) = oneshot::channel();
  148|      9|        let queued_commands = Arc::new(AtomicUsize::new(0));
  149|       |
  150|      9|        let queued_commands_clone = queued_commands.clone();
  151|      9|        let handle = std::thread::spawn(move || {
  152|      9|            log::trace!("Starting OBS thread");
                                      ^0
  153|       |
  154|      9|            let res = Self::initialize_inner(info);
  155|       |
  156|      9|            match res {
  157|      9|                Ok((info, modules)) => {
  158|      9|                    log::trace!("OBS context initialized successfully");
                                              ^0
  159|      9|                    let e = init_tx.send(Ok((Sendable(modules), info)));
  160|      9|                    if let Err(err) = e {
                                             ^0
  161|      0|                        log::error!("Failed to send initialization signal: {:?}", err);
  162|      9|                    }
  163|       |
  164|       |                    // Process commands until termination
  165|    467|                    while let Ok(command) = command_receiver.recv() {
  166|    467|                        match command {
  167|    458|                            ObsCommand::Execute(func, result_sender) => {
  168|    458|                                let result = func();
  169|    458|                                let _ = result_sender.send(result);
  170|    458|                                queued_commands_clone.fetch_sub(1, Ordering::SeqCst);
  171|    458|                            }
  172|      9|                            ObsCommand::Terminate => break,
  173|       |                        }
  174|       |                    }
  175|       |
  176|      9|                    let r = Self::shutdown_inner();
  177|      9|                    if let Err(err) = r {
                                             ^0
  178|      0|                        log::error!("Failed to shut down OBS context: {:?}", err);
  179|      9|                    }
  180|       |                }
  181|      0|                Err(err) => {
  182|      0|                    log::error!("Failed to initialize OBS context: {:?}", err);
  183|      0|                    let _ = init_tx.send(Err(err));
  184|       |                }
  185|       |            }
  186|      9|        });
  187|       |
  188|      9|        log::trace!("Waiting for OBS thread to initialize");
                                  ^0
  189|       |        // Wait for initialization to complete
  190|      9|        let (mut m, info) = init_rx.recv()??;
                                                        ^0^0
  191|       |
  192|      9|        let handle = Arc::new(Mutex::new(Some(handle)));
  193|      9|        let command_sender = Arc::new(command_sender);
  194|      9|        let runtime = Self {
  195|      9|            command_sender: command_sender.clone(),
  196|      9|            queued_commands,
  197|      9|            _guard: Arc::new(_ObsRuntimeGuard {
  198|      9|                handle,
  199|      9|                command_sender,
  200|      9|            }),
  201|      9|        };
  202|       |
  203|      9|        m.0.runtime = Some(runtime.clone());
  204|      9|        Ok((runtime, m.0, info))
  205|      9|    }
  206|       |
  207|       |    /// Executes an operation on the OBS thread without returning a value
  208|       |    ///
  209|       |    /// This is a convenience wrapper around `run_with_obs_result` for operations
  210|       |    /// that don't need to return a value.
  211|       |    ///
  212|       |    /// # Parameters
  213|       |    ///
  214|       |    /// * `operation` - A function to execute on the OBS thread
  215|       |    ///
  216|       |    /// # Returns
  217|       |    ///
  218|       |    /// A `Result` indicating success or failure
  219|       |    ///
  220|       |    /// # Examples
  221|       |    ///
  222|       |    /// ```
  223|       |    /// use libobs_wrapper::runtime::ObsRuntime;
  224|       |    ///
  225|       |    /// async fn example(runtime: &ObsRuntime) {
  226|       |    ///     runtime.run_with_obs(|| {
  227|       |    ///         // This code runs on the OBS thread
  228|       |    ///         println!("Hello from the OBS thread!");
  229|       |    ///     }).await.unwrap();
  230|       |    /// }
  231|       |    /// ```
  232|      0|    pub fn run_with_obs<F>(&self, operation: F) -> anyhow::Result<()>
  233|      0|    where
  234|      0|        F: FnOnce() + Send + 'static,
  235|       |    {
  236|      0|        self.run_with_obs_result(move || {
  237|      0|            operation();
  238|      0|            Result::<(), anyhow::Error>::Ok(())
  239|      0|        })??;
  240|       |
  241|      0|        Ok(())
  242|      0|    }
  243|       |
  244|       |    /// Executes an operation on the OBS thread and returns a result
  245|       |    ///
  246|       |    /// This method dispatches a task to the OBS thread and blocks and waits for the result.
  247|       |    ///
  248|       |    /// # Parameters
  249|       |    ///
  250|       |    /// * `operation` - A function to execute on the OBS thread
  251|       |    ///
  252|       |    /// # Returns
  253|       |    ///
  254|       |    /// A `Result` containing the value returned by the operation
  255|       |    ///
  256|       |    /// # Examples
  257|       |    ///
  258|       |    /// ```
  259|       |    /// use libobs_wrapper::runtime::ObsRuntime;
  260|       |    ///
  261|       |    /// async fn example(runtime: &ObsRuntime) {
  262|       |    ///     let version = runtime.run_with_obs_result(|| {
  263|       |    ///         // This code runs on the OBS thread
  264|       |    ///         unsafe { libobs::obs_get_version_string() }
  265|       |    ///     }).await.unwrap();
  266|       |    ///     
  267|       |    ///     println!("OBS Version: {:?}", version);
  268|       |    /// }
  269|       |    /// ```
  270|    458|    pub fn run_with_obs_result<F, T>(&self, operation: F) -> anyhow::Result<T>
  271|    458|    where
  272|    458|        F: FnOnce() -> T + Send + 'static,
  273|    458|        T: Send + 'static,
  274|       |    {
  275|    458|        let (tx, rx) = oneshot::channel();
  276|       |
  277|       |        // Create a wrapper closure that boxes the result as Any
  278|    458|        let wrapper = move || -> Box<dyn std::any::Any + Send> {
  279|    458|            let result = operation();
  280|    458|            Box::new(result)
  281|    458|        };
  282|       |
  283|    458|        let val = self.queued_commands.fetch_add(1, Ordering::SeqCst);
  284|    458|        if val > 50 {
  285|      0|            log::warn!("More than 50 queued commands. Try to batch them together.");
  286|    458|        }
  287|       |
  288|    458|        self.command_sender
  289|    458|            .send(ObsCommand::Execute(Box::new(wrapper), tx))
  290|    458|            .map_err(|_| anyhow::anyhow!("Failed to send command to OBS thread"))?;
                                       ^0              ^0                                      ^0
  291|       |
  292|    458|        let result = rx
  293|    458|            .recv()
  294|    458|            .map_err(|_| anyhow::anyhow!("OBS thread dropped the response channel"))?;
                                       ^0              ^0                                         ^0
  295|       |
  296|       |        // Downcast the Any type back to T
  297|    458|        let res = result
  298|    458|            .downcast::<T>()
  299|    458|            .map(|boxed| *boxed)
  300|    458|            .map_err(|_| anyhow::anyhow!("Failed to downcast result to the expected type"))?;
                                       ^0              ^0                                                ^0
  301|       |
  302|    458|        Ok(res)
  303|    458|    }
  304|       |
  305|       |    /// Initializes the libobs context and prepares it for recording.
  306|       |    ///
  307|       |    /// This method handles core OBS initialization including:
  308|       |    /// - Starting up the OBS core (`obs_startup`)
  309|       |    /// - Resetting video and audio subsystems
  310|       |    /// - Loading OBS modules
  311|       |    ///
  312|       |    /// # Parameters
  313|       |    ///
  314|       |    /// * `info` - The startup configuration for OBS
  315|       |    ///
  316|       |    /// # Returns
  317|       |    ///
  318|       |    /// A `Result` containing the updated startup info and loaded modules, or an error
  319|      9|    fn initialize_inner(mut info: StartupInfo) -> Result<(StartupInfo, ObsModules), ObsError> {
  320|       |        // Checks that there are no other threads
  321|       |        // using libobs using a static Mutex.
  322|       |        //
  323|       |        // Fun fact: this code caused a huge debate
  324|       |        // about whether AtomicBool is UB or whatever
  325|       |        // in the Rust Programming Discord server.
  326|       |        // I didn't read too closely into it because
  327|       |        // they were talking about what architecture
  328|       |        // fridges have or something.
  329|       |        //
  330|       |        // Since this function is not meant to be
  331|       |        // high-performance or called a thousand times,
  332|       |        // a Mutex is fine here.#
  333|      9|        let mut mutex_value = OBS_THREAD_ID.lock().map_err(|_e| ObsError::MutexFailure)?;
                                                                                                     ^0
  334|       |
  335|       |        // Directly checks if the value of the
  336|       |        // Mutex is false. If true, then error.
  337|       |        // We've checked already but keeping this
  338|      9|        if (*mutex_value).is_some() {
  339|      0|            return Err(ObsError::ThreadFailure);
  340|      9|        }
  341|       |
  342|       |        // If the Mutex is None, then change
  343|       |        // it to current thread ID so that no
  344|       |        // other thread can use libobs while
  345|       |        // the current thread is using it.
  346|      9|        *mutex_value = Some(thread::current().id());
  347|       |
  348|       |        // Install DLL blocklist hook here
  349|       |
  350|      9|        unsafe {
  351|      9|            libobs::obs_init_win32_crash_handler();
  352|      9|        }
  353|       |
  354|       |        // Set logger, load debug privileges and crash handler
  355|      9|        unsafe {
  356|      9|            libobs::base_set_crash_handler(Some(main_crash_handler), std::ptr::null_mut());
  357|      9|            load_debug_privilege();
  358|      9|            libobs::base_set_log_handler(Some(extern_log_callback), std::ptr::null_mut());
  359|      9|        }
  360|       |
  361|      9|        let mut log_callback = LOGGER.lock().map_err(|_e| ObsError::MutexFailure)?;
                                                                                               ^0
  362|       |
  363|      9|        *log_callback = info.logger.take().expect("Logger can never be null");
  364|      9|        drop(log_callback);
  365|       |
  366|       |        // Locale will only be used internally by
  367|       |        // libobs for logging purposes, making it
  368|       |        // unnecessary to support other languages.
  369|      9|        let locale_str = ObsString::new("en-US");
  370|      9|        let startup_status =
  371|      9|            unsafe { libobs::obs_startup(locale_str.as_ptr().0, ptr::null(), ptr::null_mut()) };
  372|       |
  373|      9|        let version = unsafe { libobs::obs_get_version_string() };
  374|      9|        let version_cstr = unsafe { CStr::from_ptr(version) };
  375|      9|        let version_str = version_cstr.to_string_lossy().into_owned();
  376|       |
  377|      9|        internal_log_global(ObsLogLevel::Info, format!("OBS {}", version_str));
  378|      9|        internal_log_global(
  379|      9|            ObsLogLevel::Info,
  380|      9|            "---------------------------------".to_string(),
  381|       |        );
  382|       |
  383|      9|        if !startup_status {
  384|      0|            return Err(ObsError::Failure);
  385|      9|        }
  386|       |
  387|      9|        let mut obs_modules = ObsModules::add_paths(&info.startup_paths);
  388|       |
  389|       |        // Note that audio is meant to only be reset
  390|       |        // once. See the link below for information.
  391|       |        //
  392|       |        // https://docs.obsproject.com/frontends
  393|      9|        unsafe {
  394|      9|            libobs::obs_reset_audio2(info.obs_audio_info.as_ptr().0);
  395|      9|        }
  396|       |
  397|       |        // Resets the video context. Note that this
  398|       |        // is similar to Self::reset_video, but it
  399|       |        // does not call that function because the
  400|       |        // ObsContext struct is not created yet,
  401|       |        // and also because there is no need to free
  402|       |        // anything tied to the OBS context.
  403|      9|        let reset_video_status = num_traits::FromPrimitive::from_i32(unsafe {
  404|      9|            libobs::obs_reset_video(info.obs_video_info.as_ptr())
  405|       |        });
  406|       |
  407|      9|        let reset_video_status = match reset_video_status {
  408|      9|            Some(x) => x,
  409|      0|            None => ObsResetVideoStatus::Failure,
  410|       |        };
  411|       |
  412|      9|        if reset_video_status != ObsResetVideoStatus::Success {
  413|      0|            return Err(ObsError::ResetVideoFailure(reset_video_status));
  414|      9|        }
  415|       |
  416|      9|        obs_modules.load_modules();
  417|       |
  418|      9|        internal_log_global(
  419|      9|            ObsLogLevel::Info,
  420|      9|            "==== Startup complete ===============================================".to_string(),
  421|       |        );
  422|       |
  423|      9|        Ok((info, obs_modules))
  424|      9|    }
  425|       |
  426|       |    /// Shuts down the OBS context and cleans up resources
  427|       |    ///
  428|       |    /// This method performs a clean shutdown of OBS, including:
  429|       |    /// - Removing sources from output channels
  430|       |    /// - Calling `obs_shutdown` to clean up OBS resources
  431|       |    /// - Removing log and crash handlers
  432|       |    /// - Checking for memory leaks
  433|      9|    fn shutdown_inner() -> Result<(), ObsError> {
  434|       |        // Clean up sources
  435|    585|        for i in 0..libobs::MAX_CHANNELS {
                          ^576
  436|    576|            unsafe { libobs::obs_set_output_source(i, ptr::null_mut()) };
  437|    576|        }
  438|       |
  439|      9|        unsafe { libobs::obs_shutdown() }
  440|       |
  441|      9|        let r = LOGGER.lock();
  442|      9|        match r {
  443|      9|            Ok(mut logger) => {
  444|      9|                logger.log(ObsLogLevel::Info, "OBS context shutdown.".to_string());
  445|      9|                let allocs = unsafe { libobs::bnum_allocs() };
  446|       |
  447|       |                // Increasing this to 1 because of whats described below
  448|      9|                let mut notice = "";
  449|      9|                let level = if allocs > 1 {
  450|      0|                    ObsLogLevel::Error
  451|       |                } else {
  452|      9|                    notice = " (this is an issue in the OBS source code that cannot be fixed)";
  453|      9|                    ObsLogLevel::Info
  454|       |                };
  455|       |                // One memory leak is expected here because OBS does not free array elements of the obs_data_path when calling obs_add_data_path
  456|       |                // even when obs_remove_data_path is called. This is a bug in OBS.
  457|      9|                logger.log(
  458|      9|                    level,
  459|      9|                    format!("Number of memory leaks: {}{}", allocs, notice),
  460|      9|                );
  461|       |
  462|       |                #[cfg(any(feature = "__panic_on_leak", test))]
  463|       |                {
  464|      9|                    assert_eq!(allocs, 1, "Memory leaks detected: {}", allocs);
                                                        ^0
  465|       |                }
  466|       |            }
  467|      0|            Err(_) => {
  468|      0|                println!("OBS context shutdown. (but couldn't lock logger)");
  469|      0|            }
  470|       |        }
  471|       |
  472|      9|        unsafe {
  473|      9|            // Clean up log and crash handler
  474|      9|            libobs::base_set_crash_handler(None, std::ptr::null_mut());
  475|      9|            libobs::base_set_log_handler(None, std::ptr::null_mut());
  476|      9|        }
  477|       |
  478|      9|        let mut mutex_value = OBS_THREAD_ID.lock().map_err(|_e| ObsError::MutexFailure)?;
                                                                                                     ^0
  479|       |
  480|      9|        *mutex_value = None;
  481|      9|        Ok(())
  482|      9|    }
  483|       |}
  484|       |
  485|       |/// Guard object to ensure proper cleanup when the runtime is dropped
  486|       |///
  487|       |/// This guard ensures that when the last reference to the runtime is dropped,
  488|       |/// the OBS thread is properly terminated and all resources are cleaned up.
  489|       |#[derive(Debug)]
  490|       |pub struct _ObsRuntimeGuard {
  491|       |    /// Thread handle for the OBS thread
  492|       |    handle: Arc<Mutex<Option<JoinHandle<()>>>>,
  493|       |    /// Sender channel for the OBS thread
  494|       |    command_sender: Arc<Sender<ObsCommand>>,
  495|       |}
  496|       |
  497|       |impl Drop for _ObsRuntimeGuard {
  498|       |    /// Ensures the OBS thread is properly shut down when the runtime is dropped
  499|      9|    fn drop(&mut self) {
  500|      9|        log::trace!("Dropping ObsRuntime and shutting down OBS thread");
                                  ^0
  501|       |        // Theoretically the queued_commands is zero and should be increased but because
  502|       |        // we are shutting down, we don't care about that.
  503|      9|        let r = self
  504|      9|            .command_sender
  505|      9|            .send(ObsCommand::Terminate)
  506|      9|            .map_err(|_| anyhow::anyhow!("Failed to send termination command to OBS thread"));
                                       ^0              ^0
  507|       |
  508|      9|        if thread::panicking() {
  509|      0|            return;
  510|      9|        }
  511|       |
  512|      9|        r.unwrap();
  513|       |        #[cfg(not(feature = "no_blocking_drops"))]
  514|       |        {
  515|       |            // Wait for the thread to finish
  516|      9|            let handle = self.handle.lock();
  517|      9|            if handle.is_err() {
  518|      0|                log::error!("Failed to lock OBS thread handle for shutdown");
  519|      0|                return;
  520|      9|            }
  521|       |
  522|      9|            let mut handle = handle.unwrap();
  523|      9|            let handle = handle.take().expect("Handle can not be empty");
  524|       |
  525|      9|            handle.join().expect("Failed to join OBS thread");
  526|       |        }
  527|      9|    }
  528|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\scenes\mod.rs:
    1|       |use std::sync::{Arc, RwLock};
    2|       |
    3|       |use getters0::Getters;
    4|       |use libobs::{obs_scene_t, obs_source_t};
    5|       |
    6|       |use crate::{
    7|       |    impl_obs_drop, impl_signal_manager, run_with_obs,
    8|       |    runtime::ObsRuntime,
    9|       |    sources::{ObsFilterRef, ObsSourceRef},
   10|       |    unsafe_send::Sendable,
   11|       |    utils::{ObsError, ObsString, SourceInfo},
   12|       |    Vec2,
   13|       |};
   14|       |
   15|       |#[derive(Debug)]
   16|       |struct _SceneDropGuard {
   17|       |    scene: Sendable<*mut obs_scene_t>,
   18|       |    runtime: ObsRuntime,
   19|       |}
   20|       |
   21|       |impl_obs_drop!(_SceneDropGuard, (scene), move || unsafe {
   22|      6|    let scene_source = libobs::obs_scene_get_source(scene);
   23|      6|    libobs::obs_source_release(scene_source);
   24|      6|    libobs::obs_scene_release(scene);
   25|      6|});
   26|       |
   27|       |#[derive(Debug, Clone, Getters)]
   28|       |#[skip_new]
   29|       |pub struct ObsSceneRef {
   30|       |    #[skip_getter]
   31|       |    scene: Arc<Sendable<*mut obs_scene_t>>,
   32|       |    name: ObsString,
   33|       |    #[get_mut]
   34|       |    pub(crate) sources: Arc<RwLock<Vec<ObsSourceRef>>>,
   35|       |    #[skip_getter]
   36|       |    pub(crate) active_scene: Arc<RwLock<Option<Sendable<*mut obs_scene_t>>>>,
   37|       |
   38|       |    #[skip_getter]
   39|       |    _guard: Arc<_SceneDropGuard>,
   40|       |
   41|       |    #[skip_getter]
   42|       |    runtime: ObsRuntime,
   43|       |
   44|       |    pub(crate) signals: Arc<ObsSceneSignals>,
   45|       |}
   46|       |
   47|       |impl ObsSceneRef {
   48|      6|    pub(crate) fn new(
   49|      6|        name: ObsString,
   50|      6|        active_scene: Arc<RwLock<Option<Sendable<*mut obs_scene_t>>>>,
   51|      6|        runtime: ObsRuntime,
   52|      6|    ) -> Result<Self, ObsError> {
   53|      6|        let name_ptr = name.as_ptr();
   54|      6|        let scene = run_with_obs!(runtime, (name_ptr), move || unsafe {
   55|      6|            Sendable(libobs::obs_scene_create(name_ptr))
   56|      6|        })?;
                        ^0
   57|       |
   58|      6|        let signals = Arc::new(ObsSceneSignals::new(&scene, runtime.clone())?);
                                                                                          ^0
   59|      6|        Ok(Self {
   60|      6|            name,
   61|      6|            scene: Arc::new(scene.clone()),
   62|      6|            sources: Arc::new(RwLock::new(vec![])),
   63|      6|            active_scene: active_scene.clone(),
   64|      6|            _guard: Arc::new(_SceneDropGuard {
   65|      6|                scene,
   66|      6|                runtime: runtime.clone(),
   67|      6|            }),
   68|      6|            runtime,
   69|      6|            signals,
   70|      6|        })
   71|      6|    }
   72|       |
   73|       |    #[deprecated = "Use ObsSceneRef::set_to_channel instead"]
   74|      0|    pub fn add_and_set(&self, channel: u32) -> Result<(), ObsError> {
   75|      0|        self.set_to_channel(channel)
   76|      0|    }
   77|       |
   78|      6|    pub fn set_to_channel(&self, channel: u32) -> Result<(), ObsError> {
   79|      6|        let mut s = self
   80|      6|            .active_scene
   81|      6|            .write()
   82|      6|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?;
                                                           ^0      ^0          ^0
   83|       |
   84|      6|        *s = Some(self.as_ptr());
   85|       |
   86|      6|        let scene_source_ptr = self.get_scene_source_ptr()?;
                                                                        ^0
   87|      6|        run_with_obs!(self.runtime, (scene_source_ptr), move || unsafe {
   88|      6|            libobs::obs_set_output_source(channel, scene_source_ptr);
   89|      6|        })
   90|      6|    }
   91|       |
   92|      6|    pub fn get_scene_source_ptr(&self) -> Result<Sendable<*mut obs_source_t>, ObsError> {
   93|      6|        let scene_ptr = self.scene.clone();
   94|      6|        run_with_obs!(self.runtime, (scene_ptr), move || unsafe {
   95|      6|            Sendable(libobs::obs_scene_get_source(scene_ptr))
   96|      6|        })
   97|      6|    }
   98|       |
   99|      5|    pub fn add_source(&mut self, info: SourceInfo) -> Result<ObsSourceRef, ObsError> {
  100|      5|        let mut source = ObsSourceRef::new(
  101|      5|            info.id,
  102|      5|            info.name,
  103|      5|            info.settings,
  104|      5|            info.hotkey_data,
  105|      5|            self.runtime.clone(),
  106|      0|        )?;
  107|       |
  108|      5|        let scene_ptr = self.scene.clone();
  109|      5|        let source_ptr = source.source.clone();
  110|       |
  111|      5|        let ptr = run_with_obs!(self.runtime, (scene_ptr, source_ptr), move || unsafe {
  112|      5|            Sendable(libobs::obs_scene_add(scene_ptr, source_ptr))
  113|      5|        })?;
                        ^0
  114|       |
  115|      5|        if ptr.0.is_null() {
  116|      0|            return Err(ObsError::NullPointer);
  117|      5|        }
  118|       |
  119|      5|        source.scene_item = Some(ptr.clone());
  120|      5|        self.sources
  121|      5|            .write()
  122|      5|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?
                                                           ^0      ^0          ^0
  123|      5|            .push(source.clone());
  124|      5|        Ok(source)
  125|      5|    }
  126|       |
  127|      0|    pub fn get_source_by_index(&self, index: usize) -> Result<Option<ObsSourceRef>, ObsError> {
  128|      0|        let r = self
  129|      0|            .sources
  130|      0|            .read()
  131|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?
  132|      0|            .get(index)
  133|      0|            .cloned();
  134|      0|        Ok(r)
  135|      0|    }
  136|       |
  137|      0|    pub fn get_source_mut(&self, name: &str) -> Result<Option<ObsSourceRef>, ObsError> {
  138|      0|        let r = self
  139|      0|            .sources
  140|      0|            .read()
  141|      0|            .map_err(|e| ObsError::LockError(format!("{:?}", e)))?
  142|      0|            .iter()
  143|      0|            .find(|x| x.name() == name)
  144|      0|            .cloned();
  145|       |
  146|      0|        Ok(r)
  147|      0|    }
  148|       |
  149|      0|    pub fn remove_source(&mut self, source: &ObsSourceRef) -> Result<(), ObsError> {
  150|      0|        let scene_item = source.scene_item.clone();
  151|      0|        let Some(scene_item_ptr) = scene_item else {
  152|      0|            return Err(ObsError::SourceNotFound);
  153|       |        };
  154|       |
  155|      0|        run_with_obs!(self.runtime, (scene_item_ptr), move || unsafe {
  156|       |            // Remove the scene item
  157|      0|            libobs::obs_sceneitem_remove(scene_item_ptr);
  158|       |            // Release the scene item reference
  159|      0|            libobs::obs_sceneitem_release(scene_item_ptr);
  160|      0|        })?;
  161|       |
  162|      0|        Ok(())
  163|      0|    }
  164|       |
  165|      0|    pub fn add_source_filter(
  166|      0|        &self,
  167|      0|        source: &ObsSourceRef,
  168|      0|        filter_ref: &ObsFilterRef,
  169|      0|    ) -> Result<(), ObsError> {
  170|      0|        let source_ptr = source.source.clone();
  171|      0|        let filter_ptr = filter_ref.source.clone();
  172|      0|        run_with_obs!(self.runtime, (source_ptr, filter_ptr), move || unsafe {
  173|      0|            libobs::obs_source_filter_add(source_ptr, filter_ptr);
  174|      0|        })?;
  175|      0|        Ok(())
  176|      0|    }
  177|       |
  178|      0|    pub fn remove_source_filter(
  179|      0|        &self,
  180|      0|        source: &ObsSourceRef,
  181|      0|        filter_ref: &ObsFilterRef,
  182|      0|    ) -> Result<(), ObsError> {
  183|      0|        let source_ptr = source.source.clone();
  184|      0|        let filter_ptr = filter_ref.source.clone();
  185|      0|        run_with_obs!(self.runtime, (source_ptr, filter_ptr), move || unsafe {
  186|      0|            libobs::obs_source_filter_remove(source_ptr, filter_ptr);
  187|      0|        })?;
  188|      0|        Ok(())
  189|      0|    }
  190|       |
  191|      0|    pub fn get_source_position(&self, source: &ObsSourceRef) -> Result<Vec2, ObsError> {
  192|      0|        let scene_item = source.scene_item.clone();
  193|      0|        let Some(scene_item_ptr) = scene_item else {
  194|      0|            return Err(ObsError::SourceNotFound);
  195|       |        };
  196|       |
  197|      0|        let position = run_with_obs!(self.runtime, (scene_item_ptr), move || unsafe {
  198|      0|            let mut main_pos: libobs::vec2 = std::mem::zeroed();
  199|      0|            libobs::obs_sceneitem_get_pos(scene_item_ptr, &mut main_pos);
  200|      0|            Vec2::from(main_pos)
  201|      0|        })?;
  202|       |
  203|      0|        Ok(position)
  204|      0|    }
  205|       |
  206|      0|    pub fn get_source_scale(&self, source: &ObsSourceRef) -> Result<Vec2, ObsError> {
  207|      0|        let scene_item = source.scene_item.clone();
  208|      0|        let Some(scene_item_ptr) = scene_item else {
  209|      0|            return Err(ObsError::SourceNotFound);
  210|       |        };
  211|       |
  212|      0|        let scale = run_with_obs!(self.runtime, (scene_item_ptr), move || unsafe {
  213|      0|            let mut main_pos: libobs::vec2 = std::mem::zeroed();
  214|      0|            libobs::obs_sceneitem_get_scale(scene_item_ptr, &mut main_pos);
  215|      0|            Vec2::from(main_pos)
  216|      0|        })?;
  217|       |
  218|      0|        Ok(scale)
  219|      0|    }
  220|       |
  221|      0|    pub fn set_source_position(
  222|      0|        &self,
  223|      0|        source: &ObsSourceRef,
  224|      0|        position: Vec2,
  225|      0|    ) -> Result<(), ObsError> {
  226|      0|        let scene_item = source.scene_item.clone();
  227|      0|        let Some(scene_item_ptr) = scene_item else {
  228|      0|            return Err(ObsError::SourceNotFound);
  229|       |        };
  230|       |
  231|      0|        run_with_obs!(self.runtime, (scene_item_ptr), move || unsafe {
  232|      0|            libobs::obs_sceneitem_set_pos(scene_item_ptr, &position.into());
  233|      0|        })?;
  234|       |
  235|      0|        Ok(())
  236|      0|    }
  237|       |
  238|      0|    pub fn set_source_scale(&self, source: &ObsSourceRef, scale: Vec2) -> Result<(), ObsError> {
  239|      0|        let scene_item = source.scene_item.clone();
  240|      0|        let Some(scene_item_ptr) = scene_item else {
  241|      0|            return Err(ObsError::SourceNotFound);
  242|       |        };
  243|       |
  244|      0|        run_with_obs!(self.runtime, (scene_item_ptr), move || unsafe {
  245|      0|            libobs::obs_sceneitem_set_scale(scene_item_ptr, &scale.into());
  246|      0|        })?;
  247|       |
  248|      0|        Ok(())
  249|      0|    }
  250|       |
  251|      6|    pub fn as_ptr(&self) -> Sendable<*mut obs_scene_t> {
  252|      6|        Sendable(self.scene.0)
  253|      6|    }
  254|       |}
  255|       |
  256|       |impl_signal_manager!(|scene_ptr| unsafe {
  257|     12|    let source_ptr = libobs::obs_scene_get_source(scene_ptr);
  258|       |
  259|     12|    libobs::obs_source_get_signal_handler(source_ptr)
  260|     12|}, ObsSceneSignals for ObsSceneRef<*mut libobs::obs_scene_t>, [
  261|       |    "item_add": {
  262|       |        struct ItemAddSignal {
  263|       |            POINTERS {
  264|       |                item: *mut libobs::obs_sceneitem_t,
  265|       |            }
  266|       |        }
  267|       |    },
  268|       |    "item_remove": {
  269|       |        struct ItemRemoveSignal {
  270|       |            POINTERS {
  271|       |                item: *mut libobs::obs_sceneitem_t,
  272|       |            }
  273|       |        }
  274|       |    },
  275|       |    "reorder": {},
  276|       |    "refresh": {},
  277|       |    "item_visible": {
  278|       |        struct ItemVisibleSignal {
  279|       |            visible: bool;
  280|       |            POINTERS {
  281|       |                item: *mut libobs::obs_sceneitem_t,
  282|       |            }
  283|       |        }
  284|       |    },
  285|       |    "item_locked": {
  286|       |        struct ItemLockedSignal {
  287|       |            locked: bool;
  288|       |            POINTERS {
  289|       |                item: *mut libobs::obs_sceneitem_t,
  290|       |            }
  291|       |        }
  292|       |    },
  293|       |    "item_select": {
  294|       |        struct ItemSelectSignal {
  295|       |            POINTERS {
  296|       |                item: *mut libobs::obs_sceneitem_t,
  297|       |            }
  298|       |        }
  299|       |    },
  300|       |    "item_deselect": {
  301|       |        struct ItemDeselectSignal {
  302|       |            POINTERS {
  303|       |                item: *mut libobs::obs_sceneitem_t,
  304|       |            }
  305|       |        }
  306|       |    },
  307|       |    "item_transform": {
  308|       |        struct ItemTransformSignal {
  309|       |            POINTERS {
  310|       |                item: *mut libobs::obs_sceneitem_t,
  311|       |            }
  312|       |        }
  313|       |    }
  314|       |]);

E:\Rust\libobs-rs\libobs-wrapper\src\signals.rs:
    1|       |#[macro_export]
    2|       |#[doc(hidden)]
    3|       |macro_rules! __signals_impl_primitive_handler {
    4|       |    () => {move || {
    5|       |        Ok(())
    6|       |    }};
    7|       |
    8|       |    // Match against all primitive types
    9|       |    ($field_name: ident, i8) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, i8) };
   10|       |    ($field_name: ident, i16) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, i16) };
   11|       |    ($field_name: ident, i32) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, i32) };
   12|       |    ($field_name: ident, i64) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, i64) };
   13|       |    ($field_name: ident, i128) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, i128) };
   14|       |    ($field_name: ident, isize) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, isize) };
   15|       |
   16|       |    ($field_name: ident, u8) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, u8) };
   17|       |    ($field_name: ident, u16) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, u16) };
   18|       |    ($field_name: ident, u32) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, u32) };
   19|       |    ($field_name: ident, u64) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, u64) };
   20|       |    ($field_name: ident, u128) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, u128) };
   21|       |    ($field_name: ident, usize) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, usize) };
   22|       |
   23|       |    ($field_name: ident, f32) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, f32) };
   24|       |    ($field_name: ident, f64) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, f64) };
   25|       |
   26|       |    ($field_name: ident, bool) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, bool) };
   27|       |    ($field_name: ident, char) => { $crate::__signals_impl_primitive_handler!(__inner, $field_name, char) };
   28|       |
   29|       |    ($field_name: ident, String) => {
   30|      9|        move |__internal_calldata|  {
   31|      9|            let mut $field_name = std::ptr::null_mut();
   32|      9|            let obs_str = $crate::utils::ObsString::new(stringify!($field_name));
   33|      9|            let success = libobs::calldata_get_string(
   34|      9|                __internal_calldata,
   35|      9|                obs_str.as_ptr().0,
   36|      9|                &mut $field_name as *const _ as _,
   37|       |            );
   38|       |
   39|      9|            if !success {
   40|      0|                return Err(anyhow::anyhow!(
   41|      0|                    "Failed to get {} from calldata",
   42|      0|                    stringify!($field_name)
   43|      0|                ));
   44|      9|            }
   45|       |
   46|      9|            let $field_name = std::ffi::CStr::from_ptr($field_name).to_str()?;
                                                                                          ^0
   47|       |
   48|      9|            Result::<_, anyhow::Error>::Ok($field_name.to_owned())
   49|      9|        }
   50|       |    };
   51|       |
   52|       |    // For any other type, return false
   53|       |    ($field_name: ident, $other:ty) => { $crate::__signals_impl_primitive_handler!(__enum $field_name, $other) };
   54|       |
   55|       |    (__inner, $field_name: ident, $field_type: ty) => {
   56|      9|        move |__internal_calldata| {
   57|      9|            let mut $field_name = std::mem::zeroed::<$field_type>();
   58|      9|            let obs_str = $crate::utils::ObsString::new(stringify!($field_name));
   59|      9|            let success = libobs::calldata_get_data(
   60|      9|                __internal_calldata,
   61|      9|                obs_str.as_ptr().0,
   62|      9|                &mut $field_name as *const _ as *mut std::ffi::c_void,
   63|      9|                std::mem::size_of::<$field_type>(),
   64|       |            );
   65|       |
   66|      9|            if !success {
   67|      0|                return Err(anyhow::anyhow!(
   68|      0|                    "Failed to get {} from calldata",
   69|      0|                    stringify!($field_name)
   70|      0|                ));
   71|      9|            }
   72|       |
   73|      9|            Result::<_, anyhow::Error>::Ok($field_name)
   74|      9|        }
   75|       |    };
   76|       |    (__ptr, $field_name: ident, $field_type: ty) => {
   77|     17|        move |__internal_calldata| {
   78|     17|            let mut $field_name = std::mem::zeroed::<$field_type>();
   79|     17|            let obs_str = $crate::utils::ObsString::new(stringify!($field_name));
   80|     17|            let success = libobs::calldata_get_data(
   81|     17|                __internal_calldata,
   82|     17|                obs_str.as_ptr().0,
   83|     17|                &mut $field_name as *const _ as *mut std::ffi::c_void,
   84|     17|                std::mem::size_of::<$field_type>(),
   85|       |            );
   86|       |
   87|     17|            if !success {
   88|      0|                return Err(anyhow::anyhow!(
   89|      0|                    "Failed to get {} from calldata",
   90|      0|                    stringify!($field_name)
   91|      0|                ));
   92|     17|            }
   93|       |
   94|     17|            Result::<_, anyhow::Error>::Ok($crate::unsafe_send::Sendable($field_name))
   95|     17|        }
   96|       |    };
   97|       |    (__enum $field_name: ident, $enum_type: ty) => {
   98|      9|        move |__internal_calldata| {
   99|      9|            let code = $crate::__signals_impl_primitive_handler!(__inner, $field_name, i64)(__internal_calldata)?;
                                                                                                                              ^0
  100|      9|            let en = <$enum_type>::try_from(code as i32);
  101|      9|            if let Err(e) = en {
                                     ^0
  102|      0|                anyhow::bail!("Failed to convert code to {}: {}", stringify!($field_name), e);
  103|      9|            }
  104|       |
  105|      9|            Result::<_, anyhow::Error>::Ok(en.unwrap())
  106|      9|        }
  107|       |    }
  108|       |}
  109|       |
  110|       |#[macro_export]
  111|       |#[doc(hidden)]
  112|       |macro_rules! __signals_impl_signal {
  113|       |    ($ptr: ty, $signal_name: literal, $field_name: ident: $gen_type:ty) => {
  114|       |        paste::paste! {
  115|       |            type [<__Private $signal_name:camel Type >] = $gen_type;
  116|       |            lazy_static::lazy_static! {
  117|       |                static ref [<$signal_name:snake:upper _SENDERS>]: std::sync::Arc<std::sync::RwLock<std::collections::HashMap<$crate::unsafe_send::SendableComp<$ptr>, tokio::sync::broadcast::Sender<$gen_type>>>> = std::sync::Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));
  118|       |            }
  119|       |
  120|      9|            unsafe fn [< $signal_name:snake _handler_inner>](cd: *mut libobs::calldata_t) -> anyhow::Result<$gen_type> {
  121|      9|                let e = $crate::__signals_impl_primitive_handler!($field_name, $gen_type)(cd);
  122|       |
  123|      9|                e
  124|      9|            }
  125|       |        }
  126|       |
  127|       |    };
  128|       |    ($ptr: ty, $signal_name: literal, ) => {
  129|       |        paste::paste! {
  130|       |            type [<__Private $signal_name:camel Type >] = ();
  131|       |            lazy_static::lazy_static! {
  132|       |                static ref [<$signal_name:snake:upper _SENDERS>]: std::sync::Arc<std::sync::RwLock<std::collections::HashMap<$crate::unsafe_send::SendableComp<$ptr>, tokio::sync::broadcast::Sender<()>>>> = std::sync::Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));
  133|       |            }
  134|       |
  135|     56|            unsafe fn [< $signal_name:snake _handler_inner>](_cd: *mut libobs::calldata_t) -> anyhow::Result<()> {
  136|     56|                Ok(())
  137|     56|            }
  138|       |        }
  139|       |
  140|       |    };
  141|       |    ($ptr: ty, $signal_name: literal, struct $name: ident {
  142|       |        $($field_name: ident: $field_type: ty),* $(,)*
  143|       |    }) => {
  144|       |        $crate::__signals_impl_signal!($ptr, $signal_name, struct $name {
  145|       |            $($field_name: $field_type),*;
  146|       |            POINTERS {}
  147|       |        });
  148|       |    };
  149|       |    ($ptr: ty, $signal_name: literal, struct $name: ident {
  150|       |        POINTERS
  151|       |        {$($ptr_field_name: ident: $ptr_field_type: ty),* $(,)*}
  152|       |    }) => {
  153|       |        $crate::__signals_impl_signal!($ptr, $signal_name, struct $name {
  154|       |            ;POINTERS { $($ptr_field_name: $ptr_field_type),* }
  155|       |        });
  156|       |    };
  157|       |    ($ptr: ty, $signal_name: literal, struct $name: ident {
  158|       |        $($field_name: ident: $field_type: ty),* $(,)*;
  159|       |        POINTERS
  160|       |        {$($ptr_field_name: ident: $ptr_field_type: ty),* $(,)*}
  161|       |    }) => {
  162|       |        paste::paste! {
  163|       |            type [<__Private $signal_name:camel Type >] = $name;
  164|       |            lazy_static::lazy_static! {
  165|       |                static ref [<$signal_name:snake:upper _SENDERS>]: std::sync::Arc<std::sync::RwLock<std::collections::HashMap<$crate::unsafe_send::SendableComp<$ptr>, tokio::sync::broadcast::Sender<$name>>>> = std::sync::Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));
  166|       |            }
  167|       |
  168|       |            #[derive(Debug, Clone)]
  169|       |            pub struct $name {
  170|       |                $(pub $field_name: $field_type,)*
  171|       |                $(pub $ptr_field_name: $crate::unsafe_send::Sendable<$ptr_field_type>,)*
  172|       |            }
  173|       |
  174|     17|            unsafe fn [< $signal_name:snake _handler_inner>](cd: *mut libobs::calldata_t) -> anyhow::Result<$name> {
  175|       |                $(
  176|      3|                    let $field_name = $crate::__signals_impl_primitive_handler!($field_name, $field_type)(cd)?;
                                                                                                                           ^0
  177|       |                )*
  178|       |                $(
  179|     17|                    let $ptr_field_name = $crate::__signals_impl_primitive_handler!(__ptr, $ptr_field_name, $ptr_field_type)(cd)?;
                                      ^14                                                                                                     ^0
  180|       |                )*
  181|       |
  182|     17|                Ok($name {
  183|     17|                    $($field_name,)*
  184|     17|                    $($ptr_field_name,)*
  185|     17|                })
  186|     17|            }
  187|       |        }
  188|       |    }
  189|       |}
  190|       |
  191|       |#[macro_export]
  192|       |macro_rules! impl_signal_manager {
  193|       |    ($handler_getter: expr, $name: ident for $ref: ident<$ptr: ty>, [
  194|       |        $($(#[$attr:meta])* $signal_name: literal: { $($inner_def:tt)* }),* $(,)*
  195|       |    ]) => {
  196|       |        paste::paste! {
  197|       |            $($crate::__signals_impl_signal!($ptr, $signal_name, $($inner_def)*);)*
  198|       |
  199|       |            $(
  200|     82|            extern "C" fn [< $signal_name:snake _handler>](obj_ptr: *mut std::ffi::c_void, __internal_calldata: *mut libobs::calldata_t) {
  201|       |                #[allow(unused_unsafe)]
  202|     82|                let res = unsafe { [< $signal_name:snake _handler_inner>](__internal_calldata) };
  203|     82|                if res.is_err() {
  204|      0|                    log::warn!("Error processing signal {}: {:?}", stringify!($signal_name), res.err());
  205|      0|                    return;
  206|     82|                }
  207|       |
  208|     82|                let res = res.unwrap();
  209|     82|                let senders = [<$signal_name:snake:upper _SENDERS>].read();
  210|     82|                if let Err(e) = senders {
                                         ^0
  211|      0|                    log::warn!("Failed to acquire read lock for signal {}: {}", stringify!($signal_name), e);
  212|      0|                    return;
  213|     82|                }
  214|       |
  215|     82|                let senders = senders.unwrap();
  216|     82|                let senders = senders.get(&$crate::unsafe_send::SendableComp(obj_ptr as $ptr));
  217|     82|                if senders.is_none() {
  218|      0|                    log::warn!("No sender found for signal {}", stringify!($signal_name));
  219|      0|                    return;
  220|     82|                }
  221|       |
  222|     82|                let senders = senders.unwrap();
  223|     82|                let _ = senders.send(res);
  224|     82|            })*
  225|       |
  226|       |            #[derive(Debug)]
  227|       |            pub struct $name {
  228|       |                pointer: $crate::unsafe_send::SendableComp<$ptr>,
  229|       |                runtime: $crate::runtime::ObsRuntime
  230|       |            }
  231|       |
  232|       |            impl $name {
  233|     19|                pub(crate) fn new(ptr: &Sendable<$ptr>, runtime: $crate::runtime::ObsRuntime) -> Result<Self, $crate::utils::ObsError> {
  234|       |                    use $crate::{utils::ObsString, unsafe_send::SendableComp};
  235|     19|                    let pointer =  SendableComp(ptr.0);
  236|       |
  237|       |                    $(
  238|     19|                        let senders = [<$signal_name:snake:upper _SENDERS>].clone();
  239|     19|                        let senders = senders.write();
  240|     19|                        if senders.is_err() {
  241|      0|                            return Err($crate::utils::ObsError::LockError("Failed to acquire write lock for signal senders".to_string()));
  242|     19|                        }
  243|       |
  244|     19|                        let (tx, [<_ $signal_name:snake _rx>]) = tokio::sync::broadcast::channel(16);
  245|     19|                        let mut senders = senders.unwrap();
  246|     19|                        senders.insert(pointer.clone(), tx);
  247|       |                    )*
  248|       |
  249|     19|                    $crate::run_with_obs!(runtime, (pointer), move || {
  250|     19|                            let handler = ($handler_getter)(pointer);
  251|       |                            $(
  252|     19|                                let signal = ObsString::new($signal_name);
  253|     19|                                unsafe {
  254|     19|                                    libobs::signal_handler_connect(
  255|     19|                                        handler,
  256|     19|                                        signal.as_ptr().0,
  257|     19|                                        Some([< $signal_name:snake _handler>]),
  258|     19|                                        pointer as *mut std::ffi::c_void,
  259|     19|                                    );
  260|     19|                                };
  261|       |                            )*
  262|     19|                    })?;
                                    ^0
  263|       |
  264|     19|                    Ok(Self {
  265|     19|                        pointer,
  266|     19|                        runtime
  267|     19|                    })
  268|     19|                }
  269|       |
  270|       |                $(
  271|       |                    $(#[$attr])*
  272|     18|                    pub fn [<on_ $signal_name:snake>](&self) -> Result<tokio::sync::broadcast::Receiver<[<__Private $signal_name:camel Type >]>, $crate::utils::ObsError> {
  273|     18|                        let handlers = [<$signal_name:snake:upper _SENDERS>].read();
  274|     18|                        if handlers.is_err() {
  275|      0|                            return Err($crate::utils::ObsError::LockError("Failed to acquire read lock for signal senders".to_string()));
  276|     18|                        }
  277|       |
  278|     18|                        let handlers = handlers.unwrap();
  279|     18|                        let rx = handlers.get(&self.pointer)
  280|     18|                            .ok_or_else(|| $crate::utils::ObsError::NoSenderError)?
                                                                                                ^0
  281|     18|                            .subscribe();
  282|       |
  283|     18|                        Ok(rx)
  284|     18|                    }
  285|       |                )*
  286|       |            }
  287|       |
  288|       |            impl Drop for $name {
  289|     19|                fn drop(&mut self) {
  290|     19|                    log::trace!("Dropping signal manager {}...", stringify!($name));
                                              ^0
  291|       |
  292|       |                    #[allow(unused_variables)]
  293|     19|                    let ptr = self.pointer.clone();
  294|       |                    #[allow(unused_variables)]
  295|     19|                    let runtime = self.runtime.clone();
  296|       |
  297|       |                    //TODO make this non blocking
  298|     19|                    let future = $crate::run_with_obs!(runtime, (ptr), move || {
  299|       |                        #[allow(unused_variables)]
  300|     19|                        let handler = ($handler_getter)(ptr);
  301|       |                        $(
  302|     19|                            let signal = $crate::utils::ObsString::new($signal_name);
  303|     19|                            unsafe {
  304|     19|                                libobs::signal_handler_disconnect(
  305|     19|                                    handler,
  306|     19|                                    signal.as_ptr().0,
  307|     19|                                    Some([< $signal_name:snake _handler>]),
  308|     19|                                    ptr as *mut std::ffi::c_void,
  309|     19|                                );
  310|     19|                            }
  311|       |                        )*
  312|     19|                    });
  313|       |
  314|     19|                    let r = {
  315|       |                        $(
  316|     19|                            let handlers = [<$signal_name:snake:upper _SENDERS>].write();
  317|     19|                            if handlers.is_err() {
  318|      0|                                log::warn!("Failed to acquire write lock for signal {} senders during drop", stringify!($signal_name));
  319|      0|                                return;
  320|     19|                            }
  321|       |
  322|     19|                            let mut handlers = handlers.unwrap();
  323|     19|                            handlers.remove(&self.pointer);
  324|       |                        )*
  325|       |
  326|     19|                        future
  327|       |                    };
  328|       |
  329|     19|                    if std::thread::panicking() {
  330|      0|                        return;
  331|     19|                    }
  332|       |
  333|     19|                    r.unwrap();
  334|     19|                }
  335|       |            }
  336|       |        }
  337|       |    };
  338|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\sources\builder.rs:
    1|       |use crate::{data::ObsObjectBuilder, scenes::ObsSceneRef, utils::ObsError};
    2|       |
    3|       |use super::ObsSourceRef;
    4|       |
    5|       |pub trait ObsSourceBuilder: ObsObjectBuilder {
    6|      0|    fn add_to_scene(self, scene: &mut ObsSceneRef) -> Result<ObsSourceRef, ObsError>
    7|      0|    where
    8|      0|        Self: Sized,
    9|       |    {
   10|      0|        let s = self.build()?;
   11|      0|        scene.add_source(s)
   12|      0|    }
   13|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\sources\mod.rs:
    1|       |mod builder;
    2|       |pub use builder::*;
    3|       |
    4|       |use libobs::{obs_scene_item, obs_source_t};
    5|       |
    6|       |use crate::{
    7|       |    data::{immutable::ImmutableObsData, ObsData},
    8|       |    impl_obs_drop, impl_signal_manager, run_with_obs,
    9|       |    runtime::ObsRuntime,
   10|       |    unsafe_send::Sendable,
   11|       |    utils::{traits::ObsUpdatable, ObsError, ObsString},
   12|       |};
   13|       |
   14|       |use std::sync::Arc;
   15|       |
   16|       |#[derive(Debug, Clone)]
   17|       |#[allow(dead_code)]
   18|       |pub struct ObsSourceRef {
   19|       |    pub(crate) source: Sendable<*mut obs_source_t>,
   20|       |    pub(crate) id: ObsString,
   21|       |    pub(crate) name: ObsString,
   22|       |    pub(crate) settings: Arc<ImmutableObsData>,
   23|       |    pub(crate) hotkey_data: Arc<ImmutableObsData>,
   24|       |    pub(crate) scene_item: Option<Sendable<*mut obs_scene_item>>,
   25|       |
   26|       |    _guard: Arc<_ObsSourceGuard>,
   27|       |    pub(crate) runtime: ObsRuntime,
   28|       |    pub(crate) signal_manager: Arc<ObsSourceSignals>,
   29|       |}
   30|       |
   31|       |impl ObsSourceRef {
   32|      5|    pub fn new<T: Into<ObsString> + Sync + Send, K: Into<ObsString> + Sync + Send>(
   33|      5|        id: T,
   34|      5|        name: K,
   35|      5|        mut settings: Option<ObsData>,
   36|      5|        mut hotkey_data: Option<ObsData>,
   37|      5|        runtime: ObsRuntime,
   38|      5|    ) -> Result<Self, ObsError> {
   39|      5|        let id = id.into();
   40|      5|        let name = name.into();
   41|       |
   42|      5|        let settings = match settings.take() {
   43|      5|            Some(x) => ImmutableObsData::from(x),
   44|      0|            None => ImmutableObsData::new(&runtime)?,
   45|       |        };
   46|       |
   47|      5|        let hotkey_data = match hotkey_data.take() {
   48|      5|            Some(x) => ImmutableObsData::from(x),
   49|      0|            None => ImmutableObsData::new(&runtime)?,
   50|       |        };
   51|       |
   52|      5|        let hotkey_data_ptr = hotkey_data.as_ptr();
   53|      5|        let settings_ptr = settings.as_ptr();
   54|      5|        let id_ptr = id.as_ptr();
   55|      5|        let name_ptr = name.as_ptr();
   56|       |
   57|      5|        let source = run_with_obs!(
   58|      5|            runtime,
   59|       |            (hotkey_data_ptr, settings_ptr, id_ptr, name_ptr),
   60|       |            move || unsafe {
   61|      5|                Sendable(libobs::obs_source_create(
   62|      5|                    id_ptr,
   63|      5|                    name_ptr,
   64|      5|                    settings_ptr,
   65|      5|                    hotkey_data_ptr,
   66|      5|                ))
   67|      5|            }
   68|      0|        )?;
   69|       |
   70|      5|        if source.0.is_null() {
   71|      0|            return Err(ObsError::NullPointer);
   72|      5|        }
   73|       |
   74|      5|        let signals = ObsSourceSignals::new(&source, runtime.clone())?;
                                                                                   ^0
   75|      5|        Ok(Self {
   76|      5|            source: source.clone(),
   77|      5|            id,
   78|      5|            name,
   79|      5|            settings: Arc::new(settings),
   80|      5|            hotkey_data: Arc::new(hotkey_data),
   81|      5|            _guard: Arc::new(_ObsSourceGuard {
   82|      5|                source,
   83|      5|                runtime: runtime.clone(),
   84|      5|            }),
   85|      5|            scene_item: None,
   86|      5|            runtime,
   87|      5|            signal_manager: Arc::new(signals),
   88|      5|        })
   89|      5|    }
   90|       |
   91|      0|    pub fn settings(&self) -> &ImmutableObsData {
   92|      0|        &self.settings
   93|      0|    }
   94|       |
   95|      0|    pub fn hotkey_data(&self) -> &ImmutableObsData {
   96|      0|        &self.hotkey_data
   97|      0|    }
   98|       |
   99|      0|    pub fn name(&self) -> String {
  100|      0|        self.name.to_string()
  101|      0|    }
  102|       |
  103|      0|    pub fn id(&self) -> String {
  104|      0|        self.id.to_string()
  105|      0|    }
  106|       |
  107|      0|    pub fn signal_manager(&self) -> Arc<ObsSourceSignals> {
  108|      0|        self.signal_manager.clone()
  109|      0|    }
  110|       |}
  111|       |
  112|       |impl ObsUpdatable for ObsSourceRef {
  113|      4|    fn update_raw(&mut self, data: ObsData) -> Result<(), ObsError> {
  114|      4|        let data_ptr = data.as_ptr();
  115|      4|        let source_ptr = self.source.clone();
  116|      4|        log::trace!("Updating source: {:?}", self.source);
                                  ^0
  117|      4|        run_with_obs!(self.runtime, (source_ptr, data_ptr), move || unsafe {
  118|      4|            libobs::obs_source_update(source_ptr, data_ptr);
  119|      4|        })
  120|      4|    }
  121|       |
  122|      0|    fn reset_and_update_raw(&mut self, data: ObsData) -> Result<(), ObsError> {
  123|      0|        let source_ptr = self.source.clone();
  124|      0|        run_with_obs!(self.runtime, (source_ptr), move || unsafe {
  125|      0|            libobs::obs_source_reset_settings(source_ptr, data.as_ptr().0);
  126|      0|        })
  127|      0|    }
  128|       |
  129|      1|    fn runtime(&self) -> ObsRuntime {
  130|      1|        self.runtime.clone()
  131|      1|    }
  132|       |
  133|      0|    fn get_settings(&self) -> Result<ImmutableObsData, ObsError> {
  134|      0|        log::trace!("Getting settings for source: {:?}", self.source);
  135|      0|        let source_ptr = self.source.clone();
  136|      0|        let res = run_with_obs!(self.runtime, (source_ptr), move || unsafe {
  137|      0|            Sendable(libobs::obs_source_get_settings(source_ptr))
  138|      0|        })?;
  139|       |
  140|      0|        log::trace!("Got settings: {:?}", res);
  141|      0|        Ok(ImmutableObsData::from_raw(res, self.runtime.clone()))
  142|      0|    }
  143|       |}
  144|       |
  145|     10|impl_signal_manager!(|ptr| unsafe { libobs::obs_source_get_signal_handler(ptr) }, ObsSourceSignals for ObsSourceRef<*mut libobs::obs_source_t>, [
  146|       |    "destroy": {},
  147|       |    "remove": {},
  148|       |    "update": {},
  149|       |    "save": {},
  150|       |    "load": {},
  151|       |    "activate": {},
  152|       |    "deactivate": {},
  153|       |    "show": {},
  154|       |    "hide": {},
  155|       |    "mute": { struct MuteSignal {
  156|       |        muted: bool
  157|       |    } },
  158|       |    "push_to_mute_changed": {struct PushToMuteChangedSignal {
  159|       |        enabled: bool
  160|       |    }},
  161|       |    "push_to_mute_delay": {struct PushToMuteDelaySignal {
  162|       |        delay: i64
  163|       |    }},
  164|       |    "push_to_talk_changed": {struct PushToTalkChangedSignal {
  165|       |        enabled: bool
  166|       |    }},
  167|       |    "push_to_talk_delay": {struct PushToTalkDelaySignal {
  168|       |        delay: i64
  169|       |    }},
  170|       |    "enable": {struct EnableSignal {
  171|       |        enabled: bool
  172|       |    }},
  173|       |    "rename": {struct NewNameSignal {
  174|       |        new_name: String,
  175|       |        prev_name: String
  176|       |    }},
  177|       |    "update_properties": {},
  178|       |    "update_flags": {struct UpdateFlagsSignal {
  179|       |        flags: i64
  180|       |    }},
  181|       |    "audio_sync": {struct AudioSyncSignal {
  182|       |        offset: i64,
  183|       |    }},
  184|       |    "audio_balance": {struct AudioBalanceSignal {
  185|       |        balance: f64,
  186|       |    }},
  187|       |    "audio_mixers": {struct AudioMixersSignal {
  188|       |        mixers: i64,
  189|       |    }},
  190|       |    "audio_activate": {},
  191|       |    "audio_deactivate": {},
  192|       |    "filter_add": {struct FilterAddSignal {
  193|       |        POINTERS {
  194|       |            filter: *mut libobs::obs_source_t,
  195|       |        }
  196|       |    }},
  197|       |    "filter_remove": {struct FilterRemoveSignal {
  198|       |        POINTERS {
  199|       |            filter: *mut libobs::obs_source_t,
  200|       |        }
  201|       |    }},
  202|       |    "reorder_filters": {},
  203|       |    "transition_start": {},
  204|       |    "transition_video_stop": {},
  205|       |    "transition_stop": {},
  206|       |    "media_started": {},
  207|       |    "media_ended":{},
  208|       |    "media_pause": {},
  209|       |    "media_play": {},
  210|       |    "media_restart": {},
  211|       |    "media_stopped": {},
  212|       |    "media_next": {},
  213|       |    "media_previous": {},
  214|       |    /// This is just for sources that are of the `game-capture`, `window-capture` or `win-wasapi` type. Other sources will never emit this signal.
  215|       |    //TODO Add support for the `linux-capture` type as it does not contain the `title` field (its 'name' instead)
  216|       |    "hooked": {struct HookedSignal {
  217|       |        title: String,
  218|       |        class: String,
  219|       |        executable: String;
  220|       |        POINTERS {
  221|       |            source: *mut libobs::obs_source_t,
  222|       |        }
  223|       |    }},
  224|       |    /// This is just for sources that are of the `game-capture`, `window-capture` or `win-wasapi` type. Other sources will never emit this signal.
  225|       |    //TODO Add support for the `linux-capture` type as it does not contain the `title` field (its 'name' instead)
  226|       |    "unhooked": {struct UnhookedSignal {
  227|       |        POINTERS {
  228|       |            source: *mut libobs::obs_source_t,
  229|       |        }
  230|       |    }}
  231|       |]);
  232|       |
  233|       |#[derive(Debug)]
  234|       |struct _ObsSourceGuard {
  235|       |    source: Sendable<*mut obs_source_t>,
  236|       |    runtime: ObsRuntime,
  237|       |}
  238|       |
  239|       |impl_obs_drop!(_ObsSourceGuard, (source), move || unsafe {
  240|      5|    libobs::obs_source_release(source);
  241|      5|});
  242|       |
  243|       |pub type ObsFilterRef = ObsSourceRef;

E:\Rust\libobs-rs\libobs-wrapper\src\utils\error.rs:
    1|       |use std::fmt::Display;
    2|       |
    3|       |use crate::enums::ObsResetVideoStatus;
    4|       |
    5|       |/// Error type for OBS function calls.
    6|       |#[derive(Clone, Debug, PartialEq, Eq)]
    7|       |pub enum ObsError {
    8|       |    /// The `obs_startup` function failed on libobs.
    9|       |    Failure,
   10|       |    /// Failed to lock mutex describing whether there is a
   11|       |    /// thread using libobs or not. Report to crate maintainer.
   12|       |    MutexFailure,
   13|       |    /// Some or no thread is already using libobs. This is a bug!
   14|       |    ThreadFailure,
   15|       |    /// Unable to reset video.
   16|       |    ResetVideoFailure(ObsResetVideoStatus),
   17|       |    /// Unable to reset video because the program attempted to
   18|       |    /// change the graphics module. This is a bug!
   19|       |    ResetVideoFailureGraphicsModule,
   20|       |    /// Unable to reset video because some outputs were still active.
   21|       |    ResetVideoFailureOutputActive,
   22|       |    /// The function returned a null pointer, often indicating
   23|       |    /// an error with creating the object of the requested
   24|       |    /// pointer.
   25|       |    NullPointer,
   26|       |    OutputAlreadyActive,
   27|       |    OutputStartFailure(Option<String>),
   28|       |    OutputStopFailure(Option<String>),
   29|       |    OutputPauseFailure(Option<String>),
   30|       |    OutputNotFound,
   31|       |    SourceNotFound,
   32|       |
   33|       |    /// Native error from the Windows API when creating a display
   34|       |    DisplayCreationError(String),
   35|       |
   36|       |    OutputSaveBufferFailure(String),
   37|       |
   38|       |    /// The obs thread couldn't be called
   39|       |    InvocationError(String),
   40|       |
   41|       |    JsonParseError,
   42|       |    /// Couldn't get the sender of the signal
   43|       |    NoSenderError,
   44|       |    NoAvailableEncoders,
   45|       |    /// Error locking a mutex or RwLock
   46|       |    LockError(String),
   47|       |    Unexpected(String),
   48|       |
   49|       |    /// Encoder is still active, stop the attached output before proceeding
   50|       |    EncoderActive,
   51|       |}
   52|       |
   53|       |impl Display for ObsError {
   54|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   55|      0|        write!(f, "OBS Error: ")?;
   56|       |
   57|      0|        match self {
   58|      0|            ObsError::Failure => write!(f, "`obs-startup` function failed on libobs"),
   59|      0|            ObsError::MutexFailure => write!(f, "Failed to lock mutex describing whether there is a thread using libobs or not. Report to crate maintainer."),
   60|      0|            ObsError::ThreadFailure => write!(f, "Some or no thread is already using libobs. This is a bug!"),
   61|      0|            ObsError::ResetVideoFailure(status) => write!(f, "Could not reset obs video. Status: {:?}", status),
   62|      0|            ObsError::ResetVideoFailureGraphicsModule => write!(f, "Unable to reset video because the program attempted to change the graphics module. This is a bug!"),
   63|      0|            ObsError::ResetVideoFailureOutputActive => write!(f, "Unable to reset video because some outputs were still active."),
   64|      0|            ObsError::NullPointer => write!(f, "The function returned a null pointer, often indicating an error with creating the object of the requested pointer."),
   65|      0|            ObsError::OutputAlreadyActive => write!(f, "Output is already active."),
   66|      0|            ObsError::OutputStartFailure(s) => write!(f, "Output failed to start. Error is {:?}", s),
   67|      0|            ObsError::OutputStopFailure(s) => write!(f, "Output failed to stop. Error is {:?}", s),
   68|      0|            ObsError::OutputNotFound => write!(f, "Output not found."),
   69|      0|            ObsError::DisplayCreationError(e) => write!(f, "Native error from the Windows API when creating a display: {:?}", e),
   70|      0|            ObsError::OutputSaveBufferFailure(e) => write!(f, "Couldn't save output buffer: {:?}", e),
   71|      0|            ObsError::SourceNotFound => write!(f, "Source not found."),
   72|      0|            ObsError::InvocationError(e) => write!(f, "The obs thread couldn't be called: {:?}", e),
   73|      0|            ObsError::JsonParseError => write!(f, "Failed to parse JSON data."),
   74|      0|            ObsError::NoSenderError => write!(f, "Couldn't get the sender of the signal."),
   75|      0|            ObsError::NoAvailableEncoders => write!(f, "No available encoders found."),
   76|      0|            ObsError::OutputPauseFailure(s) => write!(f, "Output failed to pause. Error is {:?}", s),
   77|      0|            ObsError::LockError(e) => write!(f, "Error locking a mutex or RwLock: {:?}", e),
   78|      0|            ObsError::Unexpected(e) => write!(f, "Unexpected error: {:?}", e),
   79|      0|            ObsError::EncoderActive => write!(f, "Encoder is still active, stop the attached output before proceeding"),
   80|       |        }
   81|      0|    }
   82|       |}
   83|       |
   84|       |impl std::error::Error for ObsError {}

E:\Rust\libobs-rs\libobs-wrapper\src\utils\info\mod.rs:
    1|       |mod startup;
    2|       |pub use startup::*;
    3|       |
    4|       |use crate::data::ObsData;
    5|       |
    6|       |use super::ObsString;
    7|       |
    8|       |#[derive(Debug)]
    9|       |pub struct ObjectInfo {
   10|       |    pub id: ObsString,
   11|       |    pub name: ObsString,
   12|       |    pub settings: Option<ObsData>,
   13|       |    pub hotkey_data: Option<ObsData>,
   14|       |}
   15|       |
   16|       |impl ObjectInfo {
   17|     28|    pub fn new(
   18|     28|        id: impl Into<ObsString>,
   19|     28|        name: impl Into<ObsString>,
   20|     28|        settings: Option<ObsData>,
   21|     28|        hotkey_data: Option<ObsData>,
   22|     28|    ) -> Self {
   23|     28|        let id = id.into();
   24|     28|        let name = name.into();
   25|       |
   26|     28|        Self {
   27|     28|            id,
   28|     28|            name,
   29|     28|            settings,
   30|     28|            hotkey_data,
   31|     28|        }
   32|     28|    }
   33|       |}
   34|       |
   35|       |pub type OutputInfo = ObjectInfo;
   36|       |pub type SourceInfo = ObjectInfo;
   37|       |pub type FilterInfo = ObjectInfo;
   38|       |pub type AudioEncoderInfo = ObjectInfo;
   39|       |pub type VideoEncoderInfo = ObjectInfo;

E:\Rust\libobs-rs\libobs-wrapper\src\utils\info\startup.rs:
    1|       |use crate::{
    2|       |    context::ObsContext,
    3|       |    data::{audio::ObsAudioInfo, video::ObsVideoInfo},
    4|       |    logger::{ConsoleLogger, ObsLogger},
    5|       |    utils::{ObsError, ObsPath, ObsString},
    6|       |};
    7|       |
    8|       |/// Contains information to start a libobs context.
    9|       |/// This is passed to the creation of `ObsContext`.
   10|       |#[derive(Debug)]
   11|       |pub struct StartupInfo {
   12|       |    pub(crate) startup_paths: StartupPaths,
   13|       |    pub(crate) obs_video_info: ObsVideoInfo,
   14|       |    pub(crate) obs_audio_info: ObsAudioInfo,
   15|       |    // Option because logger is taken when creating
   16|       |    pub(crate) logger: Option<Box<dyn ObsLogger + Sync + Send>>,
   17|       |}
   18|       |
   19|       |impl StartupInfo {
   20|      1|    pub fn new() -> StartupInfo {
   21|      1|        Self::default()
   22|      1|    }
   23|       |
   24|      0|    pub fn set_startup_paths(mut self, paths: StartupPaths) -> Self {
   25|      0|        self.startup_paths = paths;
   26|      0|        self
   27|      0|    }
   28|       |
   29|      1|    pub fn set_video_info(mut self, ovi: ObsVideoInfo) -> Self {
   30|      1|        self.obs_video_info = ovi;
   31|      1|        self
   32|      1|    }
   33|       |
   34|      0|    pub fn get_video_info(&self) -> &ObsVideoInfo {
   35|      0|        &self.obs_video_info
   36|      0|    }
   37|       |
   38|      0|    pub fn set_logger(mut self, logger: Box<dyn ObsLogger + Sync + Send>) -> Self {
   39|      0|        self.logger = Some(logger);
   40|      0|        self
   41|      0|    }
   42|       |
   43|      0|    pub fn start(self) -> Result<ObsContext, ObsError> {
   44|      0|        ObsContext::new(self)
   45|      0|    }
   46|       |}
   47|       |
   48|       |impl Default for StartupInfo {
   49|      9|    fn default() -> StartupInfo {
   50|      9|        Self {
   51|      9|            startup_paths: StartupPaths::default(),
   52|      9|            obs_video_info: ObsVideoInfo::default(),
   53|      9|            obs_audio_info: ObsAudioInfo::default(),
   54|      9|            logger: Some(Box::new(ConsoleLogger::new())),
   55|      9|        }
   56|      9|    }
   57|       |}
   58|       |
   59|       |/// Contains the necessary paths for starting the
   60|       |/// libobs context built from `ObsPath`.
   61|       |///
   62|       |/// Note that these strings are copied when parsed,
   63|       |/// meaning that these can be freed immediately
   64|       |/// after all three strings have been used.
   65|       |#[derive(Clone, Debug)]
   66|       |pub struct StartupPaths {
   67|       |    libobs_data_path: ObsString,
   68|       |    plugin_bin_path: ObsString,
   69|       |    plugin_data_path: ObsString,
   70|       |}
   71|       |
   72|       |impl StartupPaths {
   73|      0|    pub fn new(
   74|      0|        libobs_data_path: ObsPath,
   75|      0|        plugin_bin_path: ObsPath,
   76|      0|        plugin_data_path: ObsPath,
   77|      0|    ) -> StartupPaths {
   78|      0|        Self {
   79|      0|            libobs_data_path: libobs_data_path.build(),
   80|      0|            plugin_bin_path: plugin_bin_path.build(),
   81|      0|            plugin_data_path: plugin_data_path.build(),
   82|      0|        }
   83|      0|    }
   84|       |
   85|     18|    pub fn libobs_data_path(&self) -> &ObsString {
   86|     18|        &(self.libobs_data_path)
   87|     18|    }
   88|       |
   89|      9|    pub fn plugin_bin_path(&self) -> &ObsString {
   90|      9|        &(self.plugin_bin_path)
   91|      9|    }
   92|       |
   93|      9|    pub fn plugin_data_path(&self) -> &ObsString {
   94|      9|        &(self.plugin_data_path)
   95|      9|    }
   96|       |}
   97|       |
   98|       |impl Default for StartupPaths {
   99|      9|    fn default() -> Self {
  100|      9|        StartupPathsBuilder::new().build()
  101|      9|    }
  102|       |}
  103|       |
  104|       |#[derive(Clone, Debug)]
  105|       |pub struct StartupPathsBuilder {
  106|       |    libobs_data_path: ObsPath,
  107|       |    plugin_bin_path: ObsPath,
  108|       |    plugin_data_path: ObsPath,
  109|       |}
  110|       |
  111|       |impl StartupPathsBuilder {
  112|      9|    fn new() -> Self {
  113|      9|        Self {
  114|      9|            libobs_data_path: ObsPath::from_relative("data/libobs"),
  115|      9|            plugin_bin_path: ObsPath::from_relative("obs-plugins/64bit"),
  116|      9|            plugin_data_path: ObsPath::from_relative("data/obs-plugins/%module%"),
  117|      9|        }
  118|      9|    }
  119|       |
  120|      9|    pub fn build(self) -> StartupPaths {
  121|      9|        StartupPaths {
  122|      9|            libobs_data_path: self.libobs_data_path.build(),
  123|      9|            plugin_bin_path: self.plugin_bin_path.build(),
  124|      9|            plugin_data_path: self.plugin_data_path.build(),
  125|      9|        }
  126|      9|    }
  127|       |
  128|      0|    pub fn libobs_data_path(mut self, value: ObsPath) -> Self {
  129|      0|        self.libobs_data_path = value;
  130|      0|        self
  131|      0|    }
  132|       |
  133|      0|    pub fn plugin_bin_path(mut self, value: ObsPath) -> Self {
  134|      0|        self.plugin_bin_path = value;
  135|      0|        self
  136|      0|    }
  137|       |
  138|      0|    pub fn plugin_data_path(mut self, value: ObsPath) -> Self {
  139|      0|        self.plugin_data_path = value;
  140|      0|        self
  141|      0|    }
  142|       |}
  143|       |
  144|       |impl Default for StartupPathsBuilder {
  145|      0|    fn default() -> StartupPathsBuilder {
  146|      0|        Self::new()
  147|      0|    }
  148|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\utils\initialization.rs:
    1|       |//! This is derived from the frontend/obs-main.cpp.
    2|       |
    3|       |use windows::{
    4|       |    core::PCWSTR,
    5|       |    Win32::{
    6|       |        Foundation::{CloseHandle, HANDLE, LUID},
    7|       |        Security::{
    8|       |            AdjustTokenPrivileges, LookupPrivilegeValueW, SE_DEBUG_NAME, SE_INC_BASE_PRIORITY_NAME,
    9|       |            SE_PRIVILEGE_ENABLED, TOKEN_ADJUST_PRIVILEGES, TOKEN_PRIVILEGES, TOKEN_QUERY,
   10|       |        },
   11|       |        System::Threading::{GetCurrentProcess, OpenProcessToken},
   12|       |    },
   13|       |};
   14|       |
   15|      9|pub fn load_debug_privilege() {
   16|       |    unsafe {
   17|      9|        let flags = TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY;
   18|      9|        let mut tp = TOKEN_PRIVILEGES::default();
   19|      9|        let mut token = HANDLE::default();
   20|      9|        let mut val = LUID::default();
   21|       |
   22|      9|        if OpenProcessToken(GetCurrentProcess(), flags, &mut token).is_err() {
   23|      0|            return;
   24|      9|        }
   25|       |
   26|      9|        if LookupPrivilegeValueW(PCWSTR::null(), SE_DEBUG_NAME, &mut val).is_ok() {
   27|      9|            tp.PrivilegeCount = 1;
   28|      9|            tp.Privileges[0].Luid = val;
   29|      9|            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
   30|       |
   31|      9|            let res = AdjustTokenPrivileges(
   32|      9|                token,
   33|       |                false,
   34|      9|                Some(&tp),
   35|      9|                std::mem::size_of::<TOKEN_PRIVILEGES>() as u32,
   36|      9|                None,
   37|      9|                None,
   38|       |            );
   39|      9|            if let Err(e) = res {
                                     ^0
   40|      0|                // Use a logging mechanism compatible with your Rust application
   41|      0|                eprintln!("Could not set privilege to debug process: {e:?}");
   42|      9|            }
   43|      0|        }
   44|       |
   45|      9|        if LookupPrivilegeValueW(PCWSTR::null(), SE_INC_BASE_PRIORITY_NAME, &mut val).is_ok() {
   46|      9|            tp.PrivilegeCount = 1;
   47|      9|            tp.Privileges[0].Luid = val;
   48|      9|            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
   49|       |
   50|      9|            let res = AdjustTokenPrivileges(
   51|      9|                token,
   52|       |                false,
   53|      9|                Some(&tp),
   54|      9|                std::mem::size_of::<TOKEN_PRIVILEGES>() as u32,
   55|      9|                None,
   56|      9|                None,
   57|       |            );
   58|       |
   59|      9|            if let Err(e) = res {
                                     ^0
   60|      0|                // Use a logging mechanism compatible with your Rust application
   61|      0|                eprintln!("Could not set privilege to increase GPU priority {e:?}");
   62|      9|            }
   63|      0|        }
   64|       |
   65|      9|        let _ = CloseHandle(token);
   66|       |    }
   67|      9|}

E:\Rust\libobs-rs\libobs-wrapper\src\utils\mod.rs:
    1|       |mod error;
    2|       |mod info;
    3|       |pub(crate) mod initialization;
    4|       |mod obs_string;
    5|       |mod path;
    6|       |pub mod traits;
    7|       |
    8|       |use std::ffi::CStr;
    9|       |
   10|       |pub use error::*;
   11|       |pub use info::*;
   12|       |use libobs::obs_module_failure_info;
   13|       |pub use obs_string::*;
   14|       |pub use path::*;
   15|       |
   16|       |use crate::{
   17|       |    enums::ObsLogLevel, logger::internal_log_global, run_with_obs, runtime::ObsRuntime,
   18|       |    unsafe_send::Sendable,
   19|       |};
   20|       |
   21|       |#[derive(Debug)]
   22|       |pub struct ObsModules {
   23|       |    paths: StartupPaths,
   24|       |
   25|       |    /// A pointer to the module failure info structure.
   26|       |    info: Option<Sendable<obs_module_failure_info>>,
   27|       |    pub(crate) runtime: Option<ObsRuntime>,
   28|       |}
   29|       |
   30|       |impl ObsModules {
   31|      9|    pub fn add_paths(paths: &StartupPaths) -> Self {
   32|      9|        unsafe {
   33|      9|            libobs::obs_add_data_path(paths.libobs_data_path().as_ptr().0);
   34|      9|            libobs::obs_add_module_path(
   35|      9|                paths.plugin_bin_path().as_ptr().0,
   36|      9|                paths.plugin_data_path().as_ptr().0,
   37|      9|            );
   38|      9|        }
   39|       |
   40|      9|        Self {
   41|      9|            paths: paths.clone(),
   42|      9|            info: None,
   43|      9|            runtime: None,
   44|      9|        }
   45|      9|    }
   46|       |
   47|      9|    pub fn load_modules(&mut self) {
   48|      9|        unsafe {
   49|      9|            let mut failure_info: obs_module_failure_info = std::mem::zeroed();
   50|      9|            internal_log_global(
   51|      9|                ObsLogLevel::Info,
   52|      9|                "---------------------------------".to_string(),
   53|      9|            );
   54|      9|            libobs::obs_load_all_modules2(&mut failure_info);
   55|      9|            internal_log_global(
   56|      9|                ObsLogLevel::Info,
   57|      9|                "---------------------------------".to_string(),
   58|      9|            );
   59|      9|            libobs::obs_log_loaded_modules();
   60|      9|            internal_log_global(
   61|      9|                ObsLogLevel::Info,
   62|      9|                "---------------------------------".to_string(),
   63|      9|            );
   64|      9|            libobs::obs_post_load_modules();
   65|      9|            self.info = Some(Sendable(failure_info));
   66|      9|        }
   67|       |
   68|      9|        self.log_if_failed();
   69|      9|    }
   70|       |
   71|      9|    pub fn log_if_failed(&self) {
   72|      9|        if self.info.as_ref().is_none_or(|x| x.0.count == 0) {
   73|      9|            return;
   74|      0|        }
   75|       |
   76|      0|        let info = &self.info.as_ref().unwrap().0;
   77|      0|        let mut failed_modules = Vec::new();
   78|      0|        for i in 0..info.count {
   79|      0|            let module = unsafe { info.failed_modules.add(i) };
   80|      0|            let plugin_name = unsafe { CStr::from_ptr(*module) };
   81|      0|            failed_modules.push(plugin_name.to_string_lossy());
   82|      0|        }
   83|       |
   84|      0|        internal_log_global(
   85|      0|            ObsLogLevel::Warning,
   86|      0|            format!("Failed to load modules: {}", failed_modules.join(", ")),
   87|       |        );
   88|      9|    }
   89|       |}
   90|       |
   91|       |impl Drop for ObsModules {
   92|      9|    fn drop(&mut self) {
   93|      9|        log::trace!("Dropping ObsModules and removing module paths...");
                                  ^0
   94|       |
   95|      9|        let paths = self.paths.clone();
   96|      9|        let runtime = self.runtime.take().unwrap();
   97|       |
   98|       |        #[cfg(not(feature = "no_blocking_drops"))]
   99|       |        {
  100|      9|            let r = run_with_obs!(runtime, move || unsafe {
  101|      9|                libobs::obs_remove_data_path(paths.libobs_data_path().as_ptr().0);
  102|      9|            });
  103|       |
  104|      9|            if std::thread::panicking() {
  105|      0|                return;
  106|      9|            }
  107|       |
  108|      9|            r.unwrap();
  109|       |        }
  110|       |
  111|       |        #[cfg(feature = "no_blocking_drops")]
  112|       |        {
  113|       |            let _ = tokio::task::spawn_blocking(move || unsafe {
  114|       |                run_with_obs!(runtime, move || unsafe {
  115|       |                    libobs::obs_remove_data_path(paths.libobs_data_path().as_ptr().0);
  116|       |                })
  117|       |                .unwrap();
  118|       |            });
  119|       |        }
  120|      9|    }
  121|       |}
  122|       |
  123|       |pub const ENCODER_HIDE_FLAGS: u32 =
  124|       |    libobs::OBS_ENCODER_CAP_DEPRECATED | libobs::OBS_ENCODER_CAP_INTERNAL;

E:\Rust\libobs-rs\libobs-wrapper\src\utils\obs_string.rs:
    1|       |//! String handling utilities for OBS API integration
    2|       |//!
    3|       |//! This module provides safe string handling between Rust and the OBS C API.
    4|       |//! The core type `ObsString` wraps C-compatible strings in a memory-safe way,
    5|       |//! ensuring proper lifetime management and UTF-8 validation.
    6|       |
    7|       |use std::ffi::CString;
    8|       |use std::fmt;
    9|       |use std::os::raw::c_char;
   10|       |
   11|       |use crate::unsafe_send::Sendable;
   12|       |
   13|       |/// String wrapper for OBS function calls.
   14|       |///
   15|       |/// `ObsString` provides safe interaction with OBS C API functions that require
   16|       |/// C-style strings. It wraps `CString` internally with convenient helper functions
   17|       |/// for converting between Rust strings and C-compatible strings.
   18|       |///
   19|       |/// # Safety
   20|       |///
   21|       |/// - Any NUL byte in input strings is stripped during conversion to prevent panicking
   22|       |/// - Memory is properly managed to prevent use-after-free and memory leaks
   23|       |/// - Automatically handles conversion between Rust's UTF-8 strings and C's NUL-terminated strings
   24|       |///
   25|       |/// # Examples
   26|       |///
   27|       |/// ```
   28|       |/// use libobs_wrapper::utils::ObsString;
   29|       |///
   30|       |/// // Create an ObsString from a Rust string
   31|       |/// let obs_string = ObsString::new("Hello, OBS!");
   32|       |///
   33|       |/// // Use in OBS API calls
   34|       |/// unsafe {
   35|       |///     let ptr = obs_string.as_ptr();
   36|       |///     // Pass ptr.0 to OBS functions
   37|       |/// }
   38|       |/// ```
   39|       |#[derive(Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord)]
   40|       |pub struct ObsString {
   41|       |    /// The underlying C string representation
   42|       |    c_string: CString,
   43|       |}
   44|       |
   45|       |impl ObsString {
   46|       |    /// Creates a new `ObsString` from a string slice.
   47|       |    ///
   48|       |    /// Any NUL bytes in the input are automatically stripped to prevent
   49|       |    /// panicking when converting to a C string.
   50|       |    ///
   51|       |    /// # Examples
   52|       |    ///
   53|       |    /// ```
   54|       |    /// use libobs_wrapper::utils::ObsString;
   55|       |    ///
   56|       |    /// let obs_string = ObsString::new("source_name");
   57|       |    /// ```
   58|    732|    pub fn new<S: AsRef<str>>(s: S) -> Self {
   59|    732|        let s = s.as_ref().replace("\0", "");
   60|    732|        Self {
   61|    732|            c_string: CString::new(s).unwrap(),
   62|    732|        }
   63|    732|    }
   64|       |
   65|       |    /// Returns a pointer to the underlying C string along with sendable wrapper.
   66|       |    ///
   67|       |    /// The returned pointer is suitable for passing to OBS C API functions.
   68|       |    ///
   69|       |    /// # Examples
   70|       |    ///
   71|       |    /// ```
   72|       |    /// use libobs_wrapper::utils::ObsString;
   73|       |    ///
   74|       |    /// let obs_string = ObsString::new("source_name");
   75|       |    /// let ptr = obs_string.as_ptr();
   76|       |    ///
   77|       |    /// // Use ptr.0 in OBS API calls
   78|       |    /// ```
   79|    995|    pub fn as_ptr(&self) -> Sendable<*const c_char> {
   80|    995|        Sendable(self.c_string.as_ptr())
   81|    995|    }
   82|       |}
   83|       |impl fmt::Display for ObsString {
   84|       |    /// Converts the `ObsString` back to a Rust `String` for display.
   85|       |    ///
   86|       |    /// # Examples
   87|       |    ///
   88|       |    /// ```
   89|       |    /// use libobs_wrapper::utils::ObsString;
   90|       |    ///
   91|       |    /// let obs_string = ObsString::new("Hello");
   92|       |    /// assert_eq!(format!("{}", obs_string), "Hello");
   93|       |    /// ```
   94|      3|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   95|      3|        write!(f, "{}", self.c_string.to_string_lossy())
   96|      3|    }
   97|       |}
   98|       |
   99|       |impl From<&str> for ObsString {
  100|       |    /// Creates an `ObsString` from a string slice.
  101|       |    ///
  102|       |    /// # Examples
  103|       |    ///
  104|       |    /// ```
  105|       |    /// use libobs_wrapper::utils::ObsString;
  106|       |    ///
  107|       |    /// let obs_string: ObsString = "Hello".into();
  108|       |    /// ```
  109|    254|    fn from(value: &str) -> Self {
  110|    254|        let value = value.replace("\0", "");
  111|    254|        Self {
  112|    254|            c_string: CString::new(value).unwrap(),
  113|    254|        }
  114|    254|    }
  115|       |}
  116|       |
  117|       |impl From<Vec<u8>> for ObsString {
  118|       |    /// Creates an `ObsString` from a vector of bytes.
  119|       |    ///
  120|       |    /// Any NUL bytes in the input are automatically filtered out.
  121|       |    ///
  122|       |    /// # Examples
  123|       |    ///
  124|       |    /// ```
  125|       |    /// use libobs_wrapper::utils::ObsString;
  126|       |    ///
  127|       |    /// let bytes = b"Hello".to_vec();
  128|       |    /// let obs_string: ObsString = bytes.into();
  129|       |    /// ```
  130|      0|    fn from(mut value: Vec<u8>) -> Self {
  131|      0|        value.retain(|&c| c != 0);
  132|      0|        Self {
  133|      0|            c_string: CString::new(value).unwrap(),
  134|      0|        }
  135|      0|    }
  136|       |}
  137|       |
  138|       |impl From<String> for ObsString {
  139|       |    /// Creates an `ObsString` from a `String`.
  140|       |    ///
  141|       |    /// # Examples
  142|       |    ///
  143|       |    /// ```
  144|       |    /// use libobs_wrapper::utils::ObsString;
  145|       |    ///
  146|       |    /// let s = String::from("Hello");
  147|       |    /// let obs_string: ObsString = s.into();
  148|       |    /// ```
  149|      0|    fn from(value: String) -> Self {
  150|      0|        let value = value.replace("\0", "");
  151|      0|        Self {
  152|      0|            c_string: CString::new(value).unwrap(),
  153|      0|        }
  154|      0|    }
  155|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\utils\path.rs:
    1|       |use std::{
    2|       |    env,
    3|       |    path::{Path, PathBuf},
    4|       |};
    5|       |
    6|       |use super::ObsString;
    7|       |
    8|       |/// Builds into an `ObsString` that represents a path used
    9|       |/// by libobs.
   10|       |///
   11|       |/// Note that only this path only supports UTF-8 for the
   12|       |/// entire absolute path because libobs only supports
   13|       |/// UTF-8.
   14|       |#[derive(Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord)]
   15|       |pub struct ObsPath {
   16|       |    path: PathBuf,
   17|       |}
   18|       |
   19|       |impl ObsPath {
   20|       |    /// Creates a new `ObsPath` strictly using the path
   21|       |    /// `path_str` without any modifications.
   22|       |    ///
   23|       |    /// If you want to create a relative path, use
   24|       |    /// `ObsPath::from_relative`.
   25|      0|    pub fn new(path_str: &str) -> Self {
   26|      0|        Self {
   27|      0|            path: Path::new(path_str).into(),
   28|      0|        }
   29|      0|    }
   30|       |
   31|       |    /// Creates a new `ObsPath` with `path_str`
   32|       |    /// appended to the path of the directory which the
   33|       |    /// executable file is in.
   34|       |    ///
   35|       |    /// If you want to create an absolute path, use
   36|       |    /// `ObsPath::new`.
   37|     37|    pub fn from_relative(path_str: &str) -> Self {
   38|     37|        let mut relative_path = env::current_exe().unwrap();
   39|       |
   40|     37|        relative_path.pop();
   41|       |
   42|     37|        let obs_path = Self {
   43|     37|            path: relative_path,
   44|     37|        };
   45|       |
   46|     37|        let path_str = path_str.trim_matches('/');
   47|       |
   48|     37|        obs_path.push(path_str)
   49|     37|    }
   50|       |
   51|       |    /// Modifies the path to point to the path
   52|       |    /// `path_str` appended to the current path which
   53|       |    /// `ObsPath` is pointing to.
   54|     37|    pub fn push(mut self, value: &str) -> Self {
   55|     37|        let split = value.split(['/', '\\'].as_ref());
   56|       |
   57|    110|        for item in split {
                          ^73
   58|     73|            if !item.is_empty() {
   59|     73|                self.path.push(item);
   60|     73|            }
                          ^0
   61|       |        }
   62|       |
   63|     37|        self
   64|     37|    }
   65|       |
   66|       |    /// Modifies the path to point to its current
   67|       |    /// parent. This is analogous to `Obs::push(".")`.
   68|      0|    pub fn pop(mut self) -> Self {
   69|      0|        self.path.pop();
   70|      0|        self
   71|      0|    }
   72|       |
   73|       |    /// Consumes the `ObsPath` to create a new
   74|       |    /// immutable ObsString that encodes a UTF-8
   75|       |    /// C-type string which describes the path that
   76|       |    /// the `ObsPath` is pointing to.
   77|       |    ///
   78|       |    /// Note that this function is lossy in that
   79|       |    /// any non-Unicode data is completely removed
   80|       |    /// from the string. This is because libobs
   81|       |    /// does not support non-Unicode characters in
   82|       |    /// its path.
   83|     37|    pub fn build(self) -> ObsString {
   84|     37|        let mut bytes = self.path.display().to_string().replace("\\", "/");
   85|       |
   86|     37|        if self.path.is_dir() {
   87|     18|            bytes += "/";
   88|     19|        }
   89|     37|        let obs_string = ObsString::from(bytes.as_str());
   90|       |
   91|     37|        drop(self);
   92|     37|        obs_string
   93|     37|    }
   94|       |}
   95|       |
   96|       |impl From<ObsPath> for ObsString {
   97|      0|    fn from(val: ObsPath) -> Self {
   98|      0|        val.build()
   99|      0|    }
  100|       |}

E:\Rust\libobs-rs\libobs-wrapper\src\utils\traits\mod.rs:
    1|       |use crate::{
    2|       |    data::{immutable::ImmutableObsData, ObsData, ObsObjectUpdater},
    3|       |    runtime::ObsRuntime,
    4|       |};
    5|       |
    6|       |use super::ObsError;
    7|       |
    8|       |pub trait ObsUpdatable {
    9|       |    /// Updates the object with the current settings.
   10|       |    /// For examples please take a look at the [Github repository](https://github.com/joshprk/libobs-rs/blob/main/examples).
   11|      1|    fn create_updater<'a, T: ObsObjectUpdater<'a, ToUpdate = Self> + Send + Sync>(
   12|      1|        &'a mut self,
   13|      1|    ) -> Result<T, ObsError>
   14|      1|    where
   15|      1|        Self: Sized + Send + Sync,
   16|       |    {
   17|      1|        let runtime = self.runtime();
   18|      1|        T::create_update(runtime, self)
   19|      1|    }
   20|       |
   21|       |    fn runtime(&self) -> ObsRuntime;
   22|       |
   23|       |    // We don't really need a mut here, but we do it anyway to give the dev a *feeling* of changing something
   24|       |    fn update_raw(&mut self, data: ObsData) -> Result<(), ObsError>;
   25|       |    fn reset_and_update_raw(&mut self, data: ObsData) -> Result<(), ObsError>;
   26|       |    fn get_settings(&self) -> Result<ImmutableObsData, ObsError>;
   27|       |}

